<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Using C.O.R.E. to work on mesh network routing protocols</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Using C.O.R.E. to work on mesh network routing protocols</h1>
</header>
<section data-field="subtitle" class="p-summary">
C.O.R.E. may sound like the name of a 1980’s superhero team, but it is actually a tool that simulates wired and wifi networks, right down…
</section>
<section data-field="body" class="e-content">
<section name="4c0a" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="82cf" id="82cf" class="graf graf--h3 graf--leading graf--title">Using C.O.R.E. to work on mesh network routing protocols</h3><p name="295e" id="295e" class="graf graf--p graf-after--h3">C.O.R.E. may sound like the name of a 1980’s superhero team, but it is actually a tool that simulates wired and wifi networks, right down to the radio waves. For this reason I am trying to use it to test my modifications to Babel, an ad-hoc “mesh” routing protocol.</p><p name="2819" id="2819" class="graf graf--p graf-after--p">First, let’s look at the alternatives that I evaluated before settling on CORE.</p><h4 name="9698" id="9698" class="graf graf--h4 graf-after--p">Simple container network</h4><p name="2ae7" id="2ae7" class="graf graf--p graf-after--h4">The first thing I tried was just using some containers in a network, and then using the Linux tools <code class="markup--code markup--p-code">iptables</code> and/or <code class="markup--code markup--p-code">tc</code> to selectively drop and delay packets between pairs of nodes to simulate a lossy radio network. This would obviously not uncover complex real-world network dynamics, but no simulation will do this perfectly.</p><p name="7d18" id="7d18" class="graf graf--p graf-after--p">The advantage of this approach could be simplicity (maybe). It’s also a good way to improve my chops with the Linux network utilities.</p><p name="9d29" id="9d29" class="graf graf--p graf-after--p">One example of this is <a href="https://github.com/axn/mlc" data-href="https://github.com/axn/mlc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">mlc</a>, written by Axel Neuman, the creator of the BMX6 routing protocol. Unfortunately, this package requires a lot of manual setup, and hasn’t been updated in a few years. It’s still something I will get familiar with, but I may evaluate some other more polished tools first. This technique starts to lose its simplicity the further you try to take it.</p><h4 name="be66" id="be66" class="graf graf--h4 graf-after--p">Mininet</h4><p name="9cfb" id="9cfb" class="graf graf--p graf-after--h4">Mininet is a more polished tool that sees a lot of use in the software defined networking (SDN) community. It can create networks of virtual computers connected to SDN-controlled OpenFlow switches.</p><p name="7b9d" id="7b9d" class="graf graf--p graf-after--p">Mininet looks nice, because it is relatively lightweight, with all functionality programmable through a REPL or a nice Python API. The API is pretty well documented and there are many examples.</p><p name="e7c9" id="e7c9" class="graf graf--p graf-after--p">I’m intending to revisit Mininet, but to use it effectively I think that I would need to get pretty familiar with OpenFlow and the concepts of SDN, and then use it to simulate a mesh network. No doubt that these are interesting and valuable skills, but maybe it would be better to spend time learning something actually targeted at the wireless mesh use-case.</p><p name="0ccf" id="0ccf" class="graf graf--p graf-after--p">Mininet-wifi</p><p name="2f64" id="2f64" class="graf graf--p graf-after--p">Mininet wifi adds WLAN simulation capability to mininet, with what looks like some pretty slick packet loss simulation stuff. However, it appears to be geared towards simulation of access points in a centrally-configured SDN network, not use in an ad-hoc mesh network.</p><h4 name="d8f3" id="d8f3" class="graf graf--h4 graf-after--p">CORE</h4><p name="88ce" id="88ce" class="graf graf--p graf-after--h4">CORE intimidated me with complexity at first, in addition it is not as well documented as Mininet. However, after getting it started (with the help of a very convenient VM), I found that it seems to be a capable toolkit. You get a window where you can drop nodes and link them together to form connections. Or, you can create a WLAN network and allow it to calculate connectivity based on the node’s positions on the screen. CORE also integrates EMANE, which is a much more full-featured wifi simulation suite. Finally, CORE can also import mobility scripts, which allow you to automate the movement of nodes on the canvas to see how well routing protocols do with mobility.</p><h4 name="b2a0" id="b2a0" class="graf graf--h4 graf-after--p">IMUNES</h4><p name="5477" id="5477" class="graf graf--p graf-after--h4">CORE is built on top of IMUNES, which is another network simulator with a visual interface. It looks good, and is under more active development, but CORE seems simpler to get going for a mesh simulation.</p><h3 name="10fe" id="10fe" class="graf graf--h3 graf-after--p">Using CORE</h3><p name="28ff" id="28ff" class="graf graf--p graf-after--h3">CORE has a pre-built VM image available to make it easy to get going. I installed VirtualBox to run the image, and started it up.</p><figure name="680b" id="680b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*Og9KuaHVbaDScTIe.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*Og9KuaHVbaDScTIe.png"></div></figure><p name="7670" id="7670" class="graf graf--p graf-after--figure">Clicking on the icon, you’re greeted with a blank canvas with some toolbars to the side. Click on the toolbar button with the router symbol (network-layer virtual nodes), select the “MDR” type, and place a few of them on the canvas. Then click on the button below it (link-layer nodes) and place a WLAN node, which looks like a little cloud. Right clicking the WLAN node brings up a menu that has the option “Link to all routers”. Clicking this links all nodes to the WLAN network and gives them IP addresses.</p><figure name="c40e" id="c40e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*09gOcWwwrZe82yRi.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*09gOcWwwrZe82yRi.png"></div></figure><p name="23b0" id="23b0" class="graf graf--p graf-after--figure">Clicking the play button starts the simulation. If the nodes are close enough together, green lines will form, representing the connections between them. If you double click on one of the nodes, it opens up a terminal. From here, you can try to ping other nodes. To get a quick overview of connection health, I like to use the command <code class="markup--code markup--p-code">ping -f &lt;ip address&gt;</code>. The <code class="markup--code markup--p-code">-f</code> flag formats the output in a special way. Each time it sends a ping, it prints a dot. Each time it receives a response, it prints a backspace, deleting the prior dot. This effectively means that dots correspond to timed-out pings. If the line of dots grows rapidly, a lot of packets are being dropped. If it grows slowly or not at all, most packets are arriving at their destination.</p><figure name="32d4" id="32d4" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*llqTnRgV8PDKA8z0.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*llqTnRgV8PDKA8z0.png"></div></figure><p name="fafd" id="fafd" class="graf graf--p graf-after--figure">You can move nodes around while the ping command is running. If you move two nodes far enough away from each other that the green line between them disappears, all packets will suddenly start being dropped. If the green line is there, all packets are received. This is obviously not a very sophisticated simulation. This will not work for testing routing protocols, which must be able to find the best route among links of varying reliability.</p><figure name="0537" id="0537" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*gwqkuAF_n1QjEdQ4.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*gwqkuAF_n1QjEdQ4.png"></div></figure><p name="cb53" id="cb53" class="graf graf--p graf-after--figure">Luckily the CORE emulator includes <a href="http://www.nrl.navy.mil/itd/ncs/products/emane" data-href="http://www.nrl.navy.mil/itd/ncs/products/emane" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">EMANE</a>, which simulates the lower-level networking stack (tcp, wifi, and below), and the physical layer (radio waves). With EMANE, moving nodes further away from each other increases the drop rate and the latency. I didn’t necessarily need the level of physical accuracy that it provides, but hey, it’s pretty cool. Right click on the WLAN node, and select one of the EMANE models.</p><figure name="33d1" id="33d1" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*sc0WC7ErHlTGTyMd.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*sc0WC7ErHlTGTyMd.png"></div></figure><p name="d30a" id="d30a" class="graf graf--p graf-after--figure">Ok, let’s run Babel on our nodes. Clone the Babel repo, and make and install it etc. Now double click on one of the router nodes to bring up the terminal. You should be able to type something like <code class="markup--code markup--p-code">/home/core/babeld/babeld eth0 -d 1</code> to start babel. The <code class="markup--code markup--p-code">-d 1</code> flag puts it into debug mode so that it prints logs to the terminal, and we can verify that it is running.</p><p name="1d70" id="1d70" class="graf graf--p graf-after--p">Next, we need to set up a custom service to make Babel start automatically on new nodes. Go to <code class="markup--code markup--p-code">~/.core/myservices</code> and read README.txt. I’m not going to duplicate what it says there, but my Babel service looks like this:</p><p name="f53b" id="f53b" class="graf graf--p graf-after--p">babel.py</p><pre name="8e4d" id="8e4d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">&#39;&#39;&#39; Babel service &#39;&#39;&#39; import os from core.service import CoreService, addservice from core.misc.ipaddr import IPv4Prefix, IPv6Prefix class BabelMod(CoreService): &#39;&#39;&#39; This is for babel &#39;&#39;&#39; # a unique name is required, without spaces _name = &quot;BabelMod&quot; # you can create your own group here _group = &quot;Routing&quot; # this controls the starting order vs other enabled services _startindex = 50 # list of startup commands, also may be generated during startup _startup = (&#39;sh /home/core/myservices/babel.sh&#39;,) # list of shutdown commands _shutdown = (&#39;rm log&#39;) # this line is required to add the above class to the list of available services addservice(BabelMod)</code></pre><p name="8736" id="8736" class="graf graf--p graf-after--pre">babel.sh</p><pre name="7425" id="7425" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">#!/bin/sh touch log /home/core/babeld/babeld eth0 -d 1 &gt; log</code></pre><p name="e4d2" id="e4d2" class="graf graf--p graf-after--pre">Restart CORE to install the new service.</p><figure name="fdba" id="fdba" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*WxKfqwXXr7P43QYM.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*WxKfqwXXr7P43QYM.png"></div></figure><p name="3018" id="3018" class="graf graf--p graf-after--figure">Let’s make a new node type which will only route using your new Babel service. First, click on the network-layer nodes button and select “edit node types”. In this window, there’s an “add new node type” button under the list of existing node types. I called mine “babel”, and gave it a purple icon. Click on the “Services” button and make sure that only the “IPForward”, and the new “BabelMod” services are selected.</p><figure name="f505" id="f505" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*teG9COTZFfRWz_u5.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*teG9COTZFfRWz_u5.png"></div></figure><p name="13d9" id="13d9" class="graf graf--p graf-after--figure">Now you should be able to place nodes on the canvas, and have their babel instances start talking to each other. Since we piped the output of Babel to the <code class="markup--code markup--p-code">log</code> file, we can get some insight into its operation. Double click on a node to open its terminal and type <code class="markup--code markup--p-code">tail -f log</code> to see what Babel is logging.</p><figure name="715b" id="715b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*peWJ2xXeuqmWdcL8.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*peWJ2xXeuqmWdcL8.png"></div></figure><p name="49b8" id="49b8" class="graf graf--p graf-after--figure">Now that we have Babel running, we can try to see if we can get it to do some routing. Place 4 babel nodes on the canvas, 2 far apart from each other and 2 in the middle. Make one of the middle nodes a much better route than the other (closer to the 2 end nodes). Wait a few seconds, and you will see that the end nodes have routes to each other going through the better-placed middle node (you can check with Widgets-&gt;Observer Widgets-&gt;IPv4 Routes). You can also ping from one end node to the other to monitor packet loss.</p><figure name="a3f1" id="a3f1" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="0*230RmKeQ_g50pclc.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/0*230RmKeQ_g50pclc.png"></div></figure><p name="0d96" id="0d96" class="graf graf--p graf-after--figure graf--trailing">Now switch the positions of the middle nodes. You will see the packet loss jump, as the end nodes attempt to route packets through the middle node which is now in a bad position. After around 30 seconds, you will see throughput improve again as the new route is learned. If you check the routing tables of the end nodes, you will see that they contain the new and better route.</p></div></div></section><section name="8141" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="a531" id="a531" class="graf graf--p graf--leading graf--trailing"><em class="markup--em markup--p-em">Originally published at </em><a href="http://altheamesh.com/blog/using-core-for-network-simulation/" data-href="http://altheamesh.com/blog/using-core-for-network-simulation/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">altheamesh.com</em></a><em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/devops" class="p-tag">DevOps</a>, <a href="https://medium.com/tag/mesh-networks" class="p-tag">Mesh Networks</a>, <a href="https://medium.com/tag/containers" class="p-tag">Containers</a>, <a href="https://medium.com/tag/routing" class="p-tag">Routing</a></p><p>By <a href="https://medium.com/@jtremback" class="p-author h-card">Jehan </a> on <a href="https://medium.com/p/d1c77c118eb7"><time class="dt-published" datetime="2016-08-01T00:00:00.000Z">August 1, 2016</time></a>.</p><p><a href="https://medium.com/@jtremback/using-c-o-r-e-to-work-on-mesh-network-routing-protocols-d1c77c118eb7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 9, 2019.</p></footer></article></body></html>