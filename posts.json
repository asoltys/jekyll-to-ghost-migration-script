{"posts":[{"id":"5c2f90c52b5def72fffcc753","uuid":"24470e70-72d2-4962-aeb8-bba36fcb1023","title":"Proportional hashlocks","slug":"proportional-hashlocks","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"code\",{\"code\":\"condition(secrets)\\n  // An array of 1000 hashed secrets\\n  hashes = [xyz123, abc789, ... ]\\n  numerator = 0\\n\\n  // A 'for' loop that will run 1000 times\\n  for i in 0..1000:\\n    // If the hashed secret is correct\\n    if sha3(secrets[i]) === hashes[i]:\\n      // Add 1 to the numerator\\n      numerator++\\n\\n  // Return the fraction of secrets that were correct\\n  // (the total transfer amount will be proportional to this)\\n  return numerator / 1000\"}],[\"code\",{\"code\":\"List of 1000 hashes: xyz123, abc789, ...\\n\\nNumerator: 0\\n\\nTake this list of hashes and compare them to a list of secrets that you\\nwill be given. Hash each secret in the secrets list, and compare it to\\nthe corresponding hash from the hash list. If they match, add 1 to\\nNumerator.\\n\\nreturn Numerator / 1000\"}]],\"markups\":[[\"em\"],[\"a\",[\"href\",\"{% post_url 2015-12-2-universal-payment-channels %}\"]],[\"a\",[\"href\",\"https://github.com/BumblebeeBat/FlyingFox\"]],[\"code\"]],\"sections\":[[1,\"p\",[[0,[0],0,\"This post assumes a pretty in-depth understanding of UPC and various cryptography concepts. Read \"],[0,[1],1,\"the UPC blog post\"],[0,[],1,\" if you haven't already.\"]]],[1,\"p\",[[0,[],0,\"In an incentivized mesh network, some nodes will be stationary, and some will move. We can set up payment channels between the stationary nodes, and they can pay one another with those. But what about mobile nodes who may only be within range of one another for short amounts of time? A payment channel takes at least a few minutes to set up, if we're going to wait for a sufficient number of confirmations (or even longer if it's a conventional currency and we're dealing with a bank). This is why we have multihop payments. By routing a payment across several existing payment channels, we don't have to wait for a new channel to be set up.\"]]],[1,\"p\",[[0,[],0,\"Multihop payments can result in a lot of network traffic if we don't know what route the payment will take. Depending on the payment routing protocol, there may be a search of the network for every multihop payment (RPR, a payment channel routing protocol, currently does this).\"]]],[1,\"p\",[[0,[],0,\"Instead of having smart conditions return either true or false we can have them return a fraction (see \"],[0,[2],1,\"Flying Fox\"],[0,[],0,\"). The transfer amount of the hashlock is multiplied by the fraction. This way, smart conditions have fine grained control over what fraction of a payment gets transfered. This gives us the option to build more sophisticated smart conditions.\"]]],[1,\"p\",[[0,[],0,\"The proportional hashlock gives us the ability to build a sort of higher level micropayment channel that sits on top of a multihop payment which is released incrementally. Its properties are similar to a low level payment channel in that individual payments are very cheap, and either participant can leave at any time and get all the money they are entitled to. However, this channel only goes one way.\"]]],[1,\"h2\",[[0,[],0,\"Proportional hashlock smart condition:\"]]],[10,0],[1,\"p\",[[0,[],0,\"(roughly translates as)\"]]],[10,1],[1,\"p\",[[0,[],0,\"With a proportional hashlock, the amount of payment released is proportional to the number of correct secrets that are supplied when the condition is evaluated. Here's how to use it to make an incremental multihop payment:\"]]],[1,\"p\",[[0,[3],1,\"Alice -- Bob -- Charlie -- Doris -- Erin\"]]],[1,\"p\",[[0,[],0,\"Alice would like to pay Erin.\"]]],[3,\"ul\",[[[0,[],0,\"A large multihop payment is set up from Alice to Erin, using payments with proportional hashlocks.\"]],[[0,[],0,\"Alice sends Erin secrets proportional to the amount that she wishes to pay. For instance, with the example smart condition above, a single $1000 payment could be released in $1 increments.\"]],[[0,[],0,\"Each time Alice wants to pay a dollar, she sends the Erin one of the secrets. Erin checks whether it works to unlock a fraction of the payment.\"]],[[0,[],0,\"If it does, it considers the payment complete (At this point, the channel could be closed and Erin would be able to redeem 1 1/1000 of the channel amount, or $1).\"]]]],[1,\"h2\",[[0,[],0,\"Caching\"]]],[1,\"p\",[[0,[],0,\"What if Erin caches secrets without passing them on to Doris? If Doris then sends Erin another payment on that channel that would result in Doris not having enough liquidity to honor the cached secrets, Erin is incentivized to refuse that payment (and possibly request that Doris close out the channel and open a new channel with more liquidity). Until that point, Erin can cache the secrets as much as she wants. This is good if the number of individual payments is very high.\"]]],[1,\"h2\",[[0,[],0,\"Closing the proportional hashlock\"]]],[1,\"p\",[[0,[],0,\"What happens if Alice and Erin never make another payment? Doris can request that Erin sign an update transaction eliminating the proportional hashlock.\"]]],[1,\"p\",[[0,[],0,\"What if Charlie wants to close the proportional hashlock? He can let Doris know that he wants to do this. At this point Doris can request that Erin sign an update transaction eliminating the proportional hashlock. If Doris does not do this, then Charlie can simply close the channel between him and Doris.\"]]],[1,\"h2\",[[0,[],0,\"Possible exploit? Alice sends the secrets to Charlie:\"]]],[1,\"p\",[[0,[],0,\"What if Alice sends secrets to Charlie instead of Erin? Charlie will be able to redeem the proportion of the payment that Alice sent him the secrets for, and so will Bob. In effect, Alice is paying Charlie. Now, if Alice sends those same secrets to Erin, Erin can use them to get a payment from Doris. Doris can use them to get a payment from Charlie.\"]]],[1,\"p\",[[0,[],0,\"So Charlie can't trust a payment from Alice, unless he can get Doris to agree to close their proportional hashlock immediately afterwards. But this doesn't matter, because Charlie is not supposed to be receiving the secrets from Alice anyway.\"]]],[1,\"h2\",[[0,[],0,\"What is it good for?\"]]],[1,\"p\",[[0,[],0,\"The actions taken in this scenario, and the incentives, are similar to a scenario where Alice sends Erin a series of separate normal multihop payments over the same set of intermediary nodes. The difference is that a payment of a certain size can be set up beforehand and then released slowly, with secrets flowing in one direction, without new payments needing to be set up. The secrets are also cache-able, and can be released in blocks. Also, the payment can be routed as one payment, which can reduce routing traffic. A lot of these goals could probably be accomplished in the routing protocol, but depending on how it was done, they could compromise the strong anonymity guarantees offered by routing protocols such as RPR.\"]]]]}","html":"<p><em>This post assumes a pretty in-depth understanding of UPC and various cryptography concepts. Read <a href=\"{% post_url 2015-12-2-universal-payment-channels %}\">the UPC blog post</a> if you haven&#39;t already.</em></p>\n\n<p>In an incentivized mesh network, some nodes will be stationary, and some will move. We can set up payment channels between the stationary nodes, and they can pay one another with those. But what about mobile nodes who may only be within range of one another for short amounts of time? A payment channel takes at least a few minutes to set up, if we&#39;re going to wait for a sufficient number of confirmations (or even longer if it&#39;s a conventional currency and we&#39;re dealing with a bank). This is why we have multihop payments. By routing a payment across several existing payment channels, we don&#39;t have to wait for a new channel to be set up.</p>\n\n<p>Multihop payments can result in a lot of network traffic if we don&#39;t know what route the payment will take. Depending on the payment routing protocol, there may be a search of the network for every multihop payment (RPR, a payment channel routing protocol, currently does this).</p>\n\n<p>Instead of having smart conditions return either true or false we can have them return a fraction (see <a href=\"https://github.com/BumblebeeBat/FlyingFox\">Flying Fox</a>). The transfer amount of the hashlock is multiplied by the fraction. This way, smart conditions have fine grained control over what fraction of a payment gets transfered. This gives us the option to build more sophisticated smart conditions.</p>\n\n<p>The proportional hashlock gives us the ability to build a sort of higher level micropayment channel that sits on top of a multihop payment which is released incrementally. Its properties are similar to a low level payment channel in that individual payments are very cheap, and either participant can leave at any time and get all the money they are entitled to. However, this channel only goes one way.</p>\n\n<h2>Proportional hashlock smart condition:</h2>\n\n<pre><code>condition(secrets)\n  // An array of 1000 hashed secrets\n  hashes = [xyz123, abc789, ... ]\n  numerator = 0\n\n  // A &#39;for&#39; loop that will run 1000 times\n  for i in 0..1000:\n    // If the hashed secret is correct\n    if sha3(secrets[i]) === hashes[i]:\n      // Add 1 to the numerator\n      numerator++\n\n  // Return the fraction of secrets that were correct\n  // (the total transfer amount will be proportional to this)\n  return numerator / 1000</code></pre>\n\n<p>(roughly translates as)</p>\n\n<pre><code>List of 1000 hashes: xyz123, abc789, ...\n\nNumerator: 0\n\nTake this list of hashes and compare them to a list of secrets that you\nwill be given. Hash each secret in the secrets list, and compare it to\nthe corresponding hash from the hash list. If they match, add 1 to\nNumerator.\n\nreturn Numerator / 1000</code></pre>\n\n<p>With a proportional hashlock, the amount of payment released is proportional to the number of correct secrets that are supplied when the condition is evaluated. Here&#39;s how to use it to make an incremental multihop payment:</p>\n\n<p><code>Alice -- Bob -- Charlie -- Doris -- Erin</code></p>\n\n<p>Alice would like to pay Erin.</p>\n\n<ul><li><p>A large multihop payment is set up from Alice to Erin, using payments with proportional hashlocks.</p></li><li><p>Alice sends Erin secrets proportional to the amount that she wishes to pay. For instance, with the example smart condition above, a single $1000 payment could be released in $1 increments.</p></li><li><p>Each time Alice wants to pay a dollar, she sends the Erin one of the secrets. Erin checks whether it works to unlock a fraction of the payment.</p></li><li><p>If it does, it considers the payment complete (At this point, the channel could be closed and Erin would be able to redeem 1 1/1000 of the channel amount, or $1).</p></li></ul>\n\n<h2>Caching</h2>\n\n<p>What if Erin caches secrets without passing them on to Doris? If Doris then sends Erin another payment on that channel that would result in Doris not having enough liquidity to honor the cached secrets, Erin is incentivized to refuse that payment (and possibly request that Doris close out the channel and open a new channel with more liquidity). Until that point, Erin can cache the secrets as much as she wants. This is good if the number of individual payments is very high.</p>\n\n<h2>Closing the proportional hashlock</h2>\n\n<p>What happens if Alice and Erin never make another payment? Doris can request that Erin sign an update transaction eliminating the proportional hashlock.</p>\n\n<p>What if Charlie wants to close the proportional hashlock? He can let Doris know that he wants to do this. At this point Doris can request that Erin sign an update transaction eliminating the proportional hashlock. If Doris does not do this, then Charlie can simply close the channel between him and Doris.</p>\n\n<h2>Possible exploit? Alice sends the secrets to Charlie:</h2>\n\n<p>What if Alice sends secrets to Charlie instead of Erin? Charlie will be able to redeem the proportion of the payment that Alice sent him the secrets for, and so will Bob. In effect, Alice is paying Charlie. Now, if Alice sends those same secrets to Erin, Erin can use them to get a payment from Doris. Doris can use them to get a payment from Charlie.</p>\n\n<p>So Charlie can&#39;t trust a payment from Alice, unless he can get Doris to agree to close their proportional hashlock immediately afterwards. But this doesn&#39;t matter, because Charlie is not supposed to be receiving the secrets from Alice anyway.</p>\n\n<h2>What is it good for?</h2>\n\n<p>The actions taken in this scenario, and the incentives, are similar to a scenario where Alice sends Erin a series of separate normal multihop payments over the same set of intermediary nodes. The difference is that a payment of a certain size can be set up beforehand and then released slowly, with secrets flowing in one direction, without new payments needing to be set up. The secrets are also cache-able, and can be released in blocks. Also, the payment can be routed as one payment, which can reduce routing traffic. A lot of these goals could probably be accomplished in the routing protocol, but depending on how it was done, they could compromise the strong anonymity guarantees offered by routing protocols such as RPR.</p>","comment_id":null,"plaintext":"*This post assumes a pretty in-depth understanding of UPC and various cryptography concepts. Read [the UPC blog post]({% post_url 2015-12-2-universal-payment-channels %}) if you haven't already.*\n\nIn an incentivized mesh network, some nodes will be stationary, and some will move. We can set up payment channels between the stationary nodes, and they can pay one another with those. But what about mobile nodes who may only be within range of one another for short amounts of time? A payment channel takes at least a few minutes to set up, if we're going to wait for a sufficient number of confirmations (or even longer if it's a conventional currency and we're dealing with a bank). This is why we have multihop payments. By routing a payment across several existing payment channels, we don't have to wait for a new channel to be set up.\n\nMultihop payments can result in a lot of network traffic if we don't know what route the payment will take. Depending on the payment routing protocol, there may be a search of the network for every multihop payment (RPR, a payment channel routing protocol, currently does this).\n\nInstead of having smart conditions return either true or false we can have them return a fraction (see [Flying Fox](https://github.com/BumblebeeBat/FlyingFox)). The transfer amount of the hashlock is multiplied by the fraction. This way, smart conditions have fine grained control over what fraction of a payment gets transfered. This gives us the option to build more sophisticated smart conditions.\n\nThe proportional hashlock gives us the ability to build a sort of higher level micropayment channel that sits on top of a multihop payment which is released incrementally. Its properties are similar to a low level payment channel in that individual payments are very cheap, and either participant can leave at any time and get all the money they are entitled to. However, this channel only goes one way.\n\n## Proportional hashlock smart condition:\n\n    condition(secrets)\n      // An array of 1000 hashed secrets\n      hashes = [xyz123, abc789, ... ]\n      numerator = 0\n\n      // A 'for' loop that will run 1000 times\n      for i in 0..1000:\n        // If the hashed secret is correct\n        if sha3(secrets[i]) === hashes[i]:\n          // Add 1 to the numerator\n          numerator++\n\n      // Return the fraction of secrets that were correct\n      // (the total transfer amount will be proportional to this)\n      return numerator / 1000\n\n(roughly translates as)\n\n    List of 1000 hashes: xyz123, abc789, ...\n\n    Numerator: 0\n\n    Take this list of hashes and compare them to a list of secrets that you\n    will be given. Hash each secret in the secrets list, and compare it to\n    the corresponding hash from the hash list. If they match, add 1 to\n    Numerator.\n\n    return Numerator / 1000\n\nWith a proportional hashlock, the amount of payment released is proportional to the number of correct secrets that are supplied when the condition is evaluated. Here's how to use it to make an incremental multihop payment:\n\n`Alice -- Bob -- Charlie -- Doris -- Erin`\n\nAlice would like to pay Erin.\n\n- A large multihop payment is set up from Alice to Erin, using payments with proportional hashlocks.\n\n- Alice sends Erin secrets proportional to the amount that she wishes to pay. For instance, with the example smart condition above, a single $1000 payment could be released in $1 increments.\n\n- Each time Alice wants to pay a dollar, she sends the Erin one of the secrets. Erin checks whether it works to unlock a fraction of the payment.\n\n- If it does, it considers the payment complete (At this point, the channel could be closed and Erin would be able to redeem 1 1/1000 of the channel amount, or $1).\n\n## Caching\n\nWhat if Erin caches secrets without passing them on to Doris? If Doris then sends Erin another payment on that channel that would result in Doris not having enough liquidity to honor the cached secrets, Erin is incentivized to refuse that payment (and possibly request that Doris close out the channel and open a new channel with more liquidity). Until that point, Erin can cache the secrets as much as she wants. This is good if the number of individual payments is very high.\n\n## Closing the proportional hashlock\n\nWhat happens if Alice and Erin never make another payment? Doris can request that Erin sign an update transaction eliminating the proportional hashlock.\n\nWhat if Charlie wants to close the proportional hashlock? He can let Doris know that he wants to do this. At this point Doris can request that Erin sign an update transaction eliminating the proportional hashlock. If Doris does not do this, then Charlie can simply close the channel between him and Doris.\n\n## Possible exploit? Alice sends the secrets to Charlie:\n\nWhat if Alice sends secrets to Charlie instead of Erin? Charlie will be able to redeem the proportion of the payment that Alice sent him the secrets for, and so will Bob. In effect, Alice is paying Charlie. Now, if Alice sends those same secrets to Erin, Erin can use them to get a payment from Doris. Doris can use them to get a payment from Charlie.\n\nSo Charlie can't trust a payment from Alice, unless he can get Doris to agree to close their proportional hashlock immediately afterwards. But this doesn't matter, because Charlie is not supposed to be receiving the secrets from Alice anyway.\n\n## What is it good for?\n\nThe actions taken in this scenario, and the incentives, are similar to a scenario where Alice sends Erin a series of separate normal multihop payments over the same set of intermediary nodes. The difference is that a payment of a certain size can be set up beforehand and then released slowly, with secrets flowing in one direction, without new payments needing to be set up. The secrets are also cache-able, and can be released in blocks. Also, the payment can be routed as one payment, which can reduce routing traffic. A lot of these goals could probably be accomplished in the routing protocol, but depending on how it was done, they could compromise the strong anonymity guarantees offered by routing protocols such as RPR.\n\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2015-12-17 00:00:00","created_by":"1","updated_at":"2015-12-17 00:00:00","updated_by":"1","published_at":"2015-12-17 00:00:00","published_by":"1","custom_excerpt":"The proportional hashlock gives us the ability to build a sort of higher level micropayment channel that sits on top of a multihop payment which is released incrementally.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc754","uuid":"6d06eac9-4c7e-43c8-8fbe-5dd5dd973322","title":"Universal Payment Channels","slug":"universal-payment-channels","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-1.png\",\"alt\":\"Step 1\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-2.png\",\"alt\":\"Step 2\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-3.png\",\"alt\":\"Step 3\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-4.png\",\"alt\":\"Step 4\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-5.png\",\"alt\":\"Step 5\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-6.png\",\"alt\":\"Step 6\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-7.png\",\"alt\":\"Step 7\",\"title\":\"\"}],[\"image\",{\"src\":\"{{ site.url }}/images/upc-step-8.png\",\"alt\":\"Step 8\",\"title\":\"\"}]],\"markups\":[[\"a\",[\"href\",\"{{ site.url }}/documents/universal-payment-channels.pdf\"]],[\"a\",[\"href\",\"https://github.com/BumblebeeBat/FlyingFox\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"Costless, instantaneous payments let us use money in a completely new way. Conventional payment processors impose arbitrary fees and delays, and cryptocurrencies can function only with inevitable confirmation times and blockchain bloat. Free from these constraints, we can create a new class of applications.\"]]],[1,\"p\",[[0,[],0,\"For instance, incentivized mesh networks. These are networks of independently owned routers which are automatically compensated by the network. In an incentivized mesh network, individuals could invest in providing internet service to their neighbors without the overhead of an ISP business. Also, due to the fact that individual routers compete with one another in such networks, consumers would be free from the monopolistic pricing which characterizes existing ISPs.\"]]],[1,\"p\",[[0,[],0,\"Incentivized mesh networks function by having routers pay their neighbors to forward packets. Nodes could pay per packet, but this would normally impose a huge overhead. Processing these payments with conventional currencies would result in an at least an API call to the payment processor with every payment. It would also likely result in a database entry at the payment processor. Processing these payments with a cryptocurrency (saving each and every one to the blockchain) would quickly result in a very bloated blockchain. Payment packets would vastly outnumber data packets.\"]]],[1,\"p\",[[0,[],0,\"Nodes could keep a tally of payments to one another to reduce the total number of payments. This requires nodes to trust one another. If I am paying you to forward my packets, either I put a deposit down with you, or you extend me credit. In the former scenario, I need to trust you, while in the latter, you need to trust me. The less the amount of credit or deposit is, the larger the number payments will need to be sent.\"]]],[1,\"h2\",[[0,[],0,\"Payment Channels\"]]],[1,\"p\",[[0,[],0,\"What if there was a way to transfer money without trusting the other party, and without incurring the costs of a blockchain or conventional payment? Payment channels can do this. In a payment channel, two parties deposit money with a third entity that both trust. If the channel is to transfer conventional currency, a bank or payment processor plays the role of trusted third party and holds onto the money. Both parties must trust the integrity of that bank or payment processor. If the channel holds cryptocurrency, a contract on a blockchain locks the funds from both parties. Both parties must then trust the integrity of that blockchain.\"]]],[10,0],[1,\"p\",[[0,[],0,\"The bank or the blockchain will transfer the locked funds back to the channel participants upon receiving a message signed by both.\"]]],[1,\"p\",[[0,[],0,\"Upon receiving this message, the bank or blockchain also updates the amounts to be transfered back. If Alice and Bob both deposited $100 to open the channel, and close it with balances of $95 and $105, Alice has effectively given Bob $5. So, to pay Bob, Alice signs a message updating her balance to $95 and Bob's balance to $105. She sends this message only to Bob, without contacting the bank or the blockchain that the channel is open with. If Bob wants to get his money out, he simply posts the last signed message to the bank or the blockchain.\"]]],[10,1],[10,2],[1,\"p\",[[0,[],0,\"There's one issue though- someone could cheat. Let's say that Alice makes a payment to Bob and the balances are updated to Alice- $50 and Bob- $150. Then Alice makes a payment to Bob, reversing the balances to Alice- $150, Bob- $50. Bob could take the old message where he has $150 and post it, cheating Alice out of $100.\"]]],[10,3],[1,\"p\",[[0,[],0,\"How to prevent this? We need some way for the bank or the blockchain to find out whether a message represents the account balances that Alice and Bob most recently agreed on. If Alice and Bob put a sequence number on each message and increment it every message, either of them can prove if one message is more recent than another. If the bank or blockchain then waits a certain length of time (or \\\"hold period\\\") before transferring the money back, it gives either party a chance to prove that the other is cheating.\"]]],[10,4],[1,\"p\",[[0,[],0,\"What if Alice and Bob don't want to wait to get their money out? They can simply sign a message with a hold time of 0. This means that the bank or blockchain will immediately transfer the money to their accounts. The only situation in which the hold time will actually be a factor is a situation where one of the parties wants to close the channel and the other is unresponsive or uncommunicative.\"]]],[10,5],[1,\"p\",[[0,[],0,\"This is the foundation of Universal Payment Channels (technical details in the \"],[0,[0],1,\"white paper\"],[0,[],0,\").\"]]],[1,\"h2\",[[0,[],0,\"Multihop payments {#multihop}\"]]],[1,\"p\",[[0,[],0,\"Back to the incentivized mesh example: If Alice and Bob both have nodes in an incentivized mesh network, they can open a channel in whatever currency they wish, and exchange packets and payments to their heart's content. But what about mobile nodes? Alice has a cell phone, and happens to walk into range of Charlie's wifi hotspot. Charlie could forward Alice's packets on to their destination, but he's going to need some payment from Alice. Charlie and Alice don't have a channel open- how will Alice pay Charlie?\"]]],[1,\"p\",[[0,[],0,\"What if both Alice and Charlie have channels open with Bob? Alice could send Bob a payment, who would then send Charlie a payment. But now Alice needs to trust Bob.\"]]],[1,\"h4\",[[0,[],0,\"Smart conditions and hashlocks\"]]],[1,\"p\",[[0,[],0,\"We have to make sure that Bob can't steal the money. UPC allows us to make payments with pieces of code called \\\"smart conditions\\\". The bank or blockchain evaluates the smart condition, to find out whether it should transfer some money. We can make a type of smart condition called a hashlock which allows us to trustlessly route payments through one or more intermediary nodes. A hashlock basically says: \\\"transfer this amount of money if you are given the string that hashes to this hash\\\".\"]]],[1,\"p\",[[0,[],0,\"A hashing function turns whatever value you give it into a random-looking string of characters, known as a \\\"hash\\\". For instance, the string \\\"alfred\\\" might be turned into \\\"d8si32\\\" by a hashing function. This has two interesting properties: the same hashing function will always turn \\\"alfred\\\" into \\\"d8si32\\\", and someone who has \\\"d8si32\\\" has no way of knowing that it was derived from \\\"alfred\\\". So, if Jim wants Gregory to be able to recognize that someone has the correct secret word, but Jim doesn't want to actually give Gregory the secret, Jim can give Gregory a hash of the secret. If someone gives Gregory a word they claim is the secret, Gregory can hash it and find out whether it is the correct word.\"]]],[1,\"h4\",[[0,[],0,\"Trustless multihop payments with hashlocks\"]]],[1,\"p\",[[0,[],0,\"To route a payment through Bob, Alice sends Charlie a secret, and the amount of the payment. Alice then sends a payment to Bob, hashlocked with the secret she sent Charlie. Bob sends his own payment message to Charlie, hashlocked with the same secret, and containing a payment of the same amount.\"]]],[10,6],[1,\"p\",[[0,[],0,\"To unlock the payment from Bob, Charlie reveals the secret to him, which allows Bob to unlock the payment from Alice.\"]]],[10,7],[1,\"p\",[[0,[],0,\"This all happens as fast as packets can be forwarded, and doesn't store anything on the blockchain or bank servers. It's an ideal mechanism to handle the high volume of payments that need to be processed by an incentivized mesh network.\"]]],[1,\"p\",[[0,[],0,\"You may be wondering- how do we know that Bob is the best intermediary node to route payments from Alice to Charlie? Stay tuned for the next post, about Reactive Payment Routing, a routing protocol which finds the cheapest path for payments.\"]]],[1,\"p\",[[0,[],0,\"For a more complete overview of UPC, see the \"],[0,[0],1,\"white paper\"],[0,[],0,\".\"]]],[1,\"p\",[[0,[],0,\"Acknowledgement: Payment channels utilizing a hold period in this way were, to the best of my knowledge, first introduced in Zackary Hess's \"],[0,[1],1,\"Flying Fox\"],[0,[],0,\".\"]]]]}","html":"<p>Costless, instantaneous payments let us use money in a completely new way. Conventional payment processors impose arbitrary fees and delays, and cryptocurrencies can function only with inevitable confirmation times and blockchain bloat. Free from these constraints, we can create a new class of applications.</p>\n\n<p>For instance, incentivized mesh networks. These are networks of independently owned routers which are automatically compensated by the network. In an incentivized mesh network, individuals could invest in providing internet service to their neighbors without the overhead of an ISP business. Also, due to the fact that individual routers compete with one another in such networks, consumers would be free from the monopolistic pricing which characterizes existing ISPs.</p>\n\n<p>Incentivized mesh networks function by having routers pay their neighbors to forward packets. Nodes could pay per packet, but this would normally impose a huge overhead. Processing these payments with conventional currencies would result in an at least an API call to the payment processor with every payment. It would also likely result in a database entry at the payment processor. Processing these payments with a cryptocurrency (saving each and every one to the blockchain) would quickly result in a very bloated blockchain. Payment packets would vastly outnumber data packets.</p>\n\n<p>Nodes could keep a tally of payments to one another to reduce the total number of payments. This requires nodes to trust one another. If I am paying you to forward my packets, either I put a deposit down with you, or you extend me credit. In the former scenario, I need to trust you, while in the latter, you need to trust me. The less the amount of credit or deposit is, the larger the number payments will need to be sent.</p>\n\n<h2>Payment Channels</h2>\n\n<p>What if there was a way to transfer money without trusting the other party, and without incurring the costs of a blockchain or conventional payment? Payment channels can do this. In a payment channel, two parties deposit money with a third entity that both trust. If the channel is to transfer conventional currency, a bank or payment processor plays the role of trusted third party and holds onto the money. Both parties must trust the integrity of that bank or payment processor. If the channel holds cryptocurrency, a contract on a blockchain locks the funds from both parties. Both parties must then trust the integrity of that blockchain.</p>\n\n<p><img alt=\"Step 1\" src=\"{{ site.url }}/images/upc-step-1.png\"/></p>\n\n<p>The bank or the blockchain will transfer the locked funds back to the channel participants upon receiving a message signed by both.</p>\n\n<p>Upon receiving this message, the bank or blockchain also updates the amounts to be transfered back. If Alice and Bob both deposited $100 to open the channel, and close it with balances of $95 and $105, Alice has effectively given Bob $5. So, to pay Bob, Alice signs a message updating her balance to $95 and Bob&#39;s balance to $105. She sends this message only to Bob, without contacting the bank or the blockchain that the channel is open with. If Bob wants to get his money out, he simply posts the last signed message to the bank or the blockchain.</p>\n\n<p><img alt=\"Step 2\" src=\"{{ site.url }}/images/upc-step-2.png\"/>\n<img alt=\"Step 3\" src=\"{{ site.url }}/images/upc-step-3.png\"/></p>\n\n<p>There&#39;s one issue though- someone could cheat. Let&#39;s say that Alice makes a payment to Bob and the balances are updated to Alice- $50 and Bob- $150. Then Alice makes a payment to Bob, reversing the balances to Alice- $150, Bob- $50. Bob could take the old message where he has $150 and post it, cheating Alice out of $100.</p>\n\n<p><img alt=\"Step 4\" src=\"{{ site.url }}/images/upc-step-4.png\"/></p>\n\n<p>How to prevent this? We need some way for the bank or the blockchain to find out whether a message represents the account balances that Alice and Bob most recently agreed on. If Alice and Bob put a sequence number on each message and increment it every message, either of them can prove if one message is more recent than another. If the bank or blockchain then waits a certain length of time (or &quot;hold period&quot;) before transferring the money back, it gives either party a chance to prove that the other is cheating.</p>\n\n<p><img alt=\"Step 5\" src=\"{{ site.url }}/images/upc-step-5.png\"/></p>\n\n<p>What if Alice and Bob don&#39;t want to wait to get their money out? They can simply sign a message with a hold time of 0. This means that the bank or blockchain will immediately transfer the money to their accounts. The only situation in which the hold time will actually be a factor is a situation where one of the parties wants to close the channel and the other is unresponsive or uncommunicative.</p>\n\n<p><img alt=\"Step 6\" src=\"{{ site.url }}/images/upc-step-6.png\"/></p>\n\n<p>This is the foundation of Universal Payment Channels (technical details in the <a href=\"{{ site.url }}/documents/universal-payment-channels.pdf\">white paper</a>).</p>\n\n<h2>Multihop payments {#multihop}</h2>\n\n<p>Back to the incentivized mesh example: If Alice and Bob both have nodes in an incentivized mesh network, they can open a channel in whatever currency they wish, and exchange packets and payments to their heart&#39;s content. But what about mobile nodes? Alice has a cell phone, and happens to walk into range of Charlie&#39;s wifi hotspot. Charlie could forward Alice&#39;s packets on to their destination, but he&#39;s going to need some payment from Alice. Charlie and Alice don&#39;t have a channel open- how will Alice pay Charlie?</p>\n\n<p>What if both Alice and Charlie have channels open with Bob? Alice could send Bob a payment, who would then send Charlie a payment. But now Alice needs to trust Bob.</p>\n\n<h4>Smart conditions and hashlocks</h4>\n\n<p>We have to make sure that Bob can&#39;t steal the money. UPC allows us to make payments with pieces of code called &quot;smart conditions&quot;. The bank or blockchain evaluates the smart condition, to find out whether it should transfer some money. We can make a type of smart condition called a hashlock which allows us to trustlessly route payments through one or more intermediary nodes. A hashlock basically says: &quot;transfer this amount of money if you are given the string that hashes to this hash&quot;.</p>\n\n<blockquote><p>A hashing function turns whatever value you give it into a random-looking string of characters, known as a &quot;hash&quot;. For instance, the string &quot;alfred&quot; might be turned into &quot;d8si32&quot; by a hashing function. This has two interesting properties: the same hashing function will always turn &quot;alfred&quot; into &quot;d8si32&quot;, and someone who has &quot;d8si32&quot; has no way of knowing that it was derived from &quot;alfred&quot;. So, if Jim wants Gregory to be able to recognize that someone has the correct secret word, but Jim doesn&#39;t want to actually give Gregory the secret, Jim can give Gregory a hash of the secret. If someone gives Gregory a word they claim is the secret, Gregory can hash it and find out whether it is the correct word.</p></blockquote>\n\n<h4>Trustless multihop payments with hashlocks</h4>\n\n<p>To route a payment through Bob, Alice sends Charlie a secret, and the amount of the payment. Alice then sends a payment to Bob, hashlocked with the secret she sent Charlie. Bob sends his own payment message to Charlie, hashlocked with the same secret, and containing a payment of the same amount.</p>\n\n<p><img alt=\"Step 7\" src=\"{{ site.url }}/images/upc-step-7.png\"/></p>\n\n<p>To unlock the payment from Bob, Charlie reveals the secret to him, which allows Bob to unlock the payment from Alice.</p>\n\n<p><img alt=\"Step 8\" src=\"{{ site.url }}/images/upc-step-8.png\"/></p>\n\n<p>This all happens as fast as packets can be forwarded, and doesn&#39;t store anything on the blockchain or bank servers. It&#39;s an ideal mechanism to handle the high volume of payments that need to be processed by an incentivized mesh network.</p>\n\n<p>You may be wondering- how do we know that Bob is the best intermediary node to route payments from Alice to Charlie? Stay tuned for the next post, about Reactive Payment Routing, a routing protocol which finds the cheapest path for payments.</p>\n\n<p>For a more complete overview of UPC, see the <a href=\"{{ site.url }}/documents/universal-payment-channels.pdf\">white paper</a>.</p>\n\n<p>Acknowledgement: Payment channels utilizing a hold period in this way were, to the best of my knowledge, first introduced in Zackary Hess&#39;s <a href=\"https://github.com/BumblebeeBat/FlyingFox\">Flying Fox</a>.</p>","comment_id":null,"plaintext":"Costless, instantaneous payments let us use money in a completely new way. Conventional payment processors impose arbitrary fees and delays, and cryptocurrencies can function only with inevitable confirmation times and blockchain bloat. Free from these constraints, we can create a new class of applications.\n\nFor instance, incentivized mesh networks. These are networks of independently owned routers which are automatically compensated by the network. In an incentivized mesh network, individuals could invest in providing internet service to their neighbors without the overhead of an ISP business. Also, due to the fact that individual routers compete with one another in such networks, consumers would be free from the monopolistic pricing which characterizes existing ISPs.\n\nIncentivized mesh networks function by having routers pay their neighbors to forward packets. Nodes could pay per packet, but this would normally impose a huge overhead. Processing these payments with conventional currencies would result in an at least an API call to the payment processor with every payment. It would also likely result in a database entry at the payment processor. Processing these payments with a cryptocurrency (saving each and every one to the blockchain) would quickly result in a very bloated blockchain. Payment packets would vastly outnumber data packets.\n\nNodes could keep a tally of payments to one another to reduce the total number of payments. This requires nodes to trust one another. If I am paying you to forward my packets, either I put a deposit down with you, or you extend me credit. In the former scenario, I need to trust you, while in the latter, you need to trust me. The less the amount of credit or deposit is, the larger the number payments will need to be sent.\n\n## Payment Channels\n\nWhat if there was a way to transfer money without trusting the other party, and without incurring the costs of a blockchain or conventional payment? Payment channels can do this. In a payment channel, two parties deposit money with a third entity that both trust. If the channel is to transfer conventional currency, a bank or payment processor plays the role of trusted third party and holds onto the money. Both parties must trust the integrity of that bank or payment processor. If the channel holds cryptocurrency, a contract on a blockchain locks the funds from both parties. Both parties must then trust the integrity of that blockchain.\n\n![Step 1]({{ site.url }}/images/upc-step-1.png)\n\nThe bank or the blockchain will transfer the locked funds back to the channel participants upon receiving a message signed by both.\n\nUpon receiving this message, the bank or blockchain also updates the amounts to be transfered back. If Alice and Bob both deposited $100 to open the channel, and close it with balances of $95 and $105, Alice has effectively given Bob $5. So, to pay Bob, Alice signs a message updating her balance to $95 and Bob's balance to $105. She sends this message only to Bob, without contacting the bank or the blockchain that the channel is open with. If Bob wants to get his money out, he simply posts the last signed message to the bank or the blockchain.\n\n![Step 2]({{ site.url }}/images/upc-step-2.png)\n![Step 3]({{ site.url }}/images/upc-step-3.png)\n\nThere's one issue though- someone could cheat. Let's say that Alice makes a payment to Bob and the balances are updated to Alice- $50 and Bob- $150. Then Alice makes a payment to Bob, reversing the balances to Alice- $150, Bob- $50. Bob could take the old message where he has $150 and post it, cheating Alice out of $100.\n\n![Step 4]({{ site.url }}/images/upc-step-4.png)\n\nHow to prevent this? We need some way for the bank or the blockchain to find out whether a message represents the account balances that Alice and Bob most recently agreed on. If Alice and Bob put a sequence number on each message and increment it every message, either of them can prove if one message is more recent than another. If the bank or blockchain then waits a certain length of time (or \"hold period\") before transferring the money back, it gives either party a chance to prove that the other is cheating.\n\n![Step 5]({{ site.url }}/images/upc-step-5.png)\n\nWhat if Alice and Bob don't want to wait to get their money out? They can simply sign a message with a hold time of 0. This means that the bank or blockchain will immediately transfer the money to their accounts. The only situation in which the hold time will actually be a factor is a situation where one of the parties wants to close the channel and the other is unresponsive or uncommunicative.\n\n![Step 6]({{ site.url }}/images/upc-step-6.png)\n\nThis is the foundation of Universal Payment Channels (technical details in the [white paper]({{ site.url }}/documents/universal-payment-channels.pdf)).\n\n## Multihop payments {#multihop}\n\nBack to the incentivized mesh example: If Alice and Bob both have nodes in an incentivized mesh network, they can open a channel in whatever currency they wish, and exchange packets and payments to their heart's content. But what about mobile nodes? Alice has a cell phone, and happens to walk into range of Charlie's wifi hotspot. Charlie could forward Alice's packets on to their destination, but he's going to need some payment from Alice. Charlie and Alice don't have a channel open- how will Alice pay Charlie?\n\nWhat if both Alice and Charlie have channels open with Bob? Alice could send Bob a payment, who would then send Charlie a payment. But now Alice needs to trust Bob.\n\n#### Smart conditions and hashlocks\n\nWe have to make sure that Bob can't steal the money. UPC allows us to make payments with pieces of code called \"smart conditions\". The bank or blockchain evaluates the smart condition, to find out whether it should transfer some money. We can make a type of smart condition called a hashlock which allows us to trustlessly route payments through one or more intermediary nodes. A hashlock basically says: \"transfer this amount of money if you are given the string that hashes to this hash\".\n\n> A hashing function turns whatever value you give it into a random-looking string of characters, known as a \"hash\". For instance, the string \"alfred\" might be turned into \"d8si32\" by a hashing function. This has two interesting properties: the same hashing function will always turn \"alfred\" into \"d8si32\", and someone who has \"d8si32\" has no way of knowing that it was derived from \"alfred\". So, if Jim wants Gregory to be able to recognize that someone has the correct secret word, but Jim doesn't want to actually give Gregory the secret, Jim can give Gregory a hash of the secret. If someone gives Gregory a word they claim is the secret, Gregory can hash it and find out whether it is the correct word.\n\n#### Trustless multihop payments with hashlocks\n\nTo route a payment through Bob, Alice sends Charlie a secret, and the amount of the payment. Alice then sends a payment to Bob, hashlocked with the secret she sent Charlie. Bob sends his own payment message to Charlie, hashlocked with the same secret, and containing a payment of the same amount.\n\n![Step 7]({{ site.url }}/images/upc-step-7.png)\n\nTo unlock the payment from Bob, Charlie reveals the secret to him, which allows Bob to unlock the payment from Alice.\n\n![Step 8]({{ site.url }}/images/upc-step-8.png)\n\nThis all happens as fast as packets can be forwarded, and doesn't store anything on the blockchain or bank servers. It's an ideal mechanism to handle the high volume of payments that need to be processed by an incentivized mesh network.\n\nYou may be wondering- how do we know that Bob is the best intermediary node to route payments from Alice to Charlie? Stay tuned for the next post, about Reactive Payment Routing, a routing protocol which finds the cheapest path for payments.\n\nFor a more complete overview of UPC, see the [white paper]({{ site.url }}/documents/universal-payment-channels.pdf).\n\nAcknowledgement: Payment channels utilizing a hold period in this way were, to the best of my knowledge, first introduced in Zackary Hess's [Flying Fox](https://github.com/BumblebeeBat/FlyingFox).\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2015-12-02 00:00:00","created_by":"1","updated_at":"2015-12-02 00:00:00","updated_by":"1","published_at":"2015-12-02 00:00:00","published_by":"1","custom_excerpt":"Costless, instantaneous payments let us use money in a completely new way. Conventional payment processors impose arbitrary fees and delays, and cryptocurrencies can function only with inevitable confirmation times and blockchain bloat. Free from these constraints, we can create a new class of appli","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc755","uuid":"45eb2eed-e0af-4049-93d1-94cd4b6cf307","title":"CCC lightning talk","slug":"ccc-lightning-talks","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"I gave a quick overview of Althea and UPC at Chaos Computer Congress 2015. It's a nice easy starting point to understand some of the concepts involved.\"]]],[1,\"p\",[[0,[],0,\"<iframe width=\\\"560\\\" height=\\\"315\\\" src=\\\"https://www.youtube.com/embed/zMp2jAHquns?start=6588\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>\"]]]]}","html":"<p>I gave a quick overview of Althea and UPC at Chaos Computer Congress 2015. It&#39;s a nice easy starting point to understand some of the concepts involved.</p>\n\n<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/zMp2jAHquns?start=6588&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</p>","comment_id":null,"plaintext":"I gave a quick overview of Althea and UPC at Chaos Computer Congress 2015. It's a nice easy starting point to understand some of the concepts involved.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/zMp2jAHquns?start=6588\" frameborder=\"0\" allowfullscreen></iframe>","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-01-14 00:00:00","created_by":"1","updated_at":"2016-01-14 00:00:00","updated_by":"1","published_at":"2016-01-14 00:00:00","published_by":"1","custom_excerpt":"I gave a quick overview of Althea and UPC at Chaos Computer Congress 2015. It's a nice easy starting point to understand some of the concepts involved.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc756","uuid":"a3b3da52-5240-4901-9a78-c756ade529d3","title":"Development update","slug":"development-update","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"/blog/althea-paper/\"]],[\"a\",[\"href\",\"/blog/ccc-lightning-talks/\"]],[\"a\",[\"href\",\"https://fastd.readthedocs.io/en/v18/\"]],[\"a\",[\"href\",\"https://www.wireguard.io\"]],[\"code\"],[\"a\",[\"href\",\"http://www.netsec.ethz.ch/publications/papers/sead-journal.pdf\"]],[\"a\",[\"href\",\"https://www.reddit.com/r/altheamesh/comments/5mh5ur/development_update/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"If you've read my \"],[0,[0],1,\"whitepaper\"],[0,[],0,\" and watched my \"],[0,[1],1,\"presentations\"],[0,[],0,\", you can see the general direction I've been pursuing for Althea. Since then, I've been getting deep into the implementation details. As I've worked, I've found several ways to simplify Althea and make it more realistic for use in real-world networks.\"]]],[1,\"p\",[[0,[],0,\"What I was trying to do was this: Nodes propagate pricing information to one another using a distance vector routing protocol (Babel), and then pay neighbors for data sent. They also pay the exit node (a node with internet access) of their choosing, who in turn pays to have the data sent back to them. They make sure that quality along the way is consistent with what is advertised by using speed tests. The service is binary: nodes pay each other an agreed-upon rate for connectivity, or they don't get service.\"]]],[1,\"p\",[[0,[],0,\"I'm now working on a new scheme that simplifies and tweaks some stuff:\"]]],[3,\"ul\",[[[0,[],0,\"I'm not addressing routing at all. The ideal routing configuration for any given network depends on a lot of factors, and mandating a certain routing protocol will limit the usefulness in different scenarios. Anything from manually entered routes, to ad-hoc protocols, to centrally administered SDN could work.\"]],[[0,[],0,\"I no longer am making any distinction between normal nodes and exit servers. This distinction will still exist, of course, but Althea won't be involved with it.\"]],[[0,[],0,\"Nodes will pay for both upstream and downstream service, instead of the pay-for-forward model I was using before.\"]]]],[1,\"p\",[[0,[],0,\"What's left is a piece of software that looks like this: \"]]],[3,\"ul\",[[[0,[],0,\"Nodes set up authenticated tunnels with all their neighbors. This is so that they can tell for sure that a specific packet was routed by a specific neighbor. These are TAP tunnels like the ones used for VPNs. Two promising options are \"],[0,[2],1,\"fastd\"],[0,[],0,\" and \"],[0,[3],1,\"wireguard\"]],[[0,[],0,\"Nodes then prioritize traffic to and from their neighbors, depending on how much each neighbor is paying. Linux's \"],[0,[4],1,\"tc\"],[0,[],0,\" tool should be able to do this. This way, purchasing service is a smooth continuum, instead of a binary state.\"]]]],[1,\"p\",[[0,[],0,\"This is very simple, and will need to work together with a few other components to make a useful system.\"]]],[3,\"ul\",[[[0,[],0,\"Routing is still necessary, and it still needs to be secure. Babel, and most other routing protocols will allow nodes to cheat and direct more traffic towards themselves than they should have. There are some ideas in the direction of securing distance vector protocols such as \"],[0,[5],1,\"SEAD\"],[0,[],0,\". Another option is using centrally determined routes or SDN. It might be easier to monitor and prevent cheating with a centralized system.\"]],[[0,[],0,\"Just because nodes can choose their desired level of prioritization and compete for service with the nodes around them, doesn't mean they know what prices to pay. The simplest option is to have the pricing manually controlled, but this will be too much of an annoyance for most people. An automatic pricing system is probably a necessity for wide adoption, but I am leaving it for later.\"]]]],[1,\"p\",[[0,[6],1,\"Discuss this post on Reddit\"]]]]}","html":"<p>If you&#39;ve read my <a href=\"/blog/althea-paper/\">whitepaper</a> and watched my <a href=\"/blog/ccc-lightning-talks/\">presentations</a>, you can see the general direction I&#39;ve been pursuing for Althea. Since then, I&#39;ve been getting deep into the implementation details. As I&#39;ve worked, I&#39;ve found several ways to simplify Althea and make it more realistic for use in real-world networks.</p>\n\n<p>What I was trying to do was this: Nodes propagate pricing information to one another using a distance vector routing protocol (Babel), and then pay neighbors for data sent. They also pay the exit node (a node with internet access) of their choosing, who in turn pays to have the data sent back to them. They make sure that quality along the way is consistent with what is advertised by using speed tests. The service is binary: nodes pay each other an agreed-upon rate for connectivity, or they don&#39;t get service.</p>\n\n<p>I&#39;m now working on a new scheme that simplifies and tweaks some stuff:</p>\n\n<ul><li><p>I&#39;m not addressing routing at all. The ideal routing configuration for any given network depends on a lot of factors, and mandating a certain routing protocol will limit the usefulness in different scenarios. Anything from manually entered routes, to ad-hoc protocols, to centrally administered SDN could work.</p></li><li><p>I no longer am making any distinction between normal nodes and exit servers. This distinction will still exist, of course, but Althea won&#39;t be involved with it.</p></li><li><p>Nodes will pay for both upstream and downstream service, instead of the pay-for-forward model I was using before.</p></li></ul>\n\n<p>What&#39;s left is a piece of software that looks like this: </p>\n\n<ul><li><p>Nodes set up authenticated tunnels with all their neighbors. This is so that they can tell for sure that a specific packet was routed by a specific neighbor. These are TAP tunnels like the ones used for VPNs. Two promising options are <a href=\"https://fastd.readthedocs.io/en/v18/\">fastd</a> and <a href=\"https://www.wireguard.io\">wireguard</a></p></li><li><p>Nodes then prioritize traffic to and from their neighbors, depending on how much each neighbor is paying. Linux&#39;s <code>tc</code> tool should be able to do this. This way, purchasing service is a smooth continuum, instead of a binary state.</p></li></ul>\n\n<p>This is very simple, and will need to work together with a few other components to make a useful system.</p>\n\n<ul><li><p>Routing is still necessary, and it still needs to be secure. Babel, and most other routing protocols will allow nodes to cheat and direct more traffic towards themselves than they should have. There are some ideas in the direction of securing distance vector protocols such as <a href=\"http://www.netsec.ethz.ch/publications/papers/sead-journal.pdf\">SEAD</a>. Another option is using centrally determined routes or SDN. It might be easier to monitor and prevent cheating with a centralized system.</p></li><li><p>Just because nodes can choose their desired level of prioritization and compete for service with the nodes around them, doesn&#39;t mean they know what prices to pay. The simplest option is to have the pricing manually controlled, but this will be too much of an annoyance for most people. An automatic pricing system is probably a necessity for wide adoption, but I am leaving it for later.</p></li></ul>\n\n<p><a href=\"https://www.reddit.com/r/altheamesh/comments/5mh5ur/development_update/\">Discuss this post on Reddit</a></p>","comment_id":null,"plaintext":" \nIf you've read my [whitepaper](/blog/althea-paper/) and watched my [presentations](/blog/ccc-lightning-talks/), you can see the general direction I've been pursuing for Althea. Since then, I've been getting deep into the implementation details. As I've worked, I've found several ways to simplify Althea and make it more realistic for use in real-world networks.\n\nWhat I was trying to do was this: Nodes propagate pricing information to one another using a distance vector routing protocol (Babel), and then pay neighbors for data sent. They also pay the exit node (a node with internet access) of their choosing, who in turn pays to have the data sent back to them. They make sure that quality along the way is consistent with what is advertised by using speed tests. The service is binary: nodes pay each other an agreed-upon rate for connectivity, or they don't get service.\n\nI'm now working on a new scheme that simplifies and tweaks some stuff:\n\n- I'm not addressing routing at all. The ideal routing configuration for any given network depends on a lot of factors, and mandating a certain routing protocol will limit the usefulness in different scenarios. Anything from manually entered routes, to ad-hoc protocols, to centrally administered SDN could work.\n\n- I no longer am making any distinction between normal nodes and exit servers. This distinction will still exist, of course, but Althea won't be involved with it.\n\n- Nodes will pay for both upstream and downstream service, instead of the pay-for-forward model I was using before.\n\nWhat's left is a piece of software that looks like this: \n\n- Nodes set up authenticated tunnels with all their neighbors. This is so that they can tell for sure that a specific packet was routed by a specific neighbor. These are TAP tunnels like the ones used for VPNs. Two promising options are [fastd](https://fastd.readthedocs.io/en/v18/) and [wireguard](https://www.wireguard.io)\n\n- Nodes then prioritize traffic to and from their neighbors, depending on how much each neighbor is paying. Linux's `tc` tool should be able to do this. This way, purchasing service is a smooth continuum, instead of a binary state.\n\nThis is very simple, and will need to work together with a few other components to make a useful system.\n\n- Routing is still necessary, and it still needs to be secure. Babel, and most other routing protocols will allow nodes to cheat and direct more traffic towards themselves than they should have. There are some ideas in the direction of securing distance vector protocols such as [SEAD](http://www.netsec.ethz.ch/publications/papers/sead-journal.pdf). Another option is using centrally determined routes or SDN. It might be easier to monitor and prevent cheating with a centralized system.\n\n- Just because nodes can choose their desired level of prioritization and compete for service with the nodes around them, doesn't mean they know what prices to pay. The simplest option is to have the pricing manually controlled, but this will be too much of an annoyance for most people. An automatic pricing system is probably a necessity for wide adoption, but I am leaving it for later.\n\n[Discuss this post on Reddit](https://www.reddit.com/r/altheamesh/comments/5mh5ur/development_update/)\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-12-20 00:00:00","created_by":"1","updated_at":"2016-12-20 00:00:00","updated_by":"1","published_at":"2016-12-20 00:00:00","published_by":"1","custom_excerpt":"Development update","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc757","uuid":"338d18a9-b74d-448d-b9db-6eb8def8cf97","title":"Full Althea presentation","slug":"full-althea-presentation","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"I gave a full presentation on Althea at SF Bitcoin Devs. This talk goes into a lot of detail.\"]]],[1,\"p\",[[0,[],0,\"<iframe width=\\\"560\\\" height=\\\"315\\\" src=\\\"https://www.youtube.com/embed/XhIA03Kti9s?rel=0\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>\"]]]]}","html":"<p>I gave a full presentation on Althea at SF Bitcoin Devs. This talk goes into a lot of detail.</p>\n\n<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/XhIA03Kti9s?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</p>","comment_id":null,"plaintext":"I gave a full presentation on Althea at SF Bitcoin Devs. This talk goes into a lot of detail.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/XhIA03Kti9s?rel=0\" frameborder=\"0\" allowfullscreen></iframe>\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-03-07 00:00:00","created_by":"1","updated_at":"2016-03-07 00:00:00","updated_by":"1","published_at":"2016-03-07 00:00:00","published_by":"1","custom_excerpt":"I gave a full presentation on Althea at SF Bitcoin Devs. This talk goes into a lot of detail.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc758","uuid":"4b0db1cf-3379-439a-b6a8-1e3c6645d031","title":"Response to A tale of two cryptocurrencies","slug":"tale-of-two-cryptocurrencies-response","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://tonyarcieri.com/a-tale-of-two-cryptocurrencies\"]],[\"em\"],[\"a\",[\"href\",\"http://langsec.org/papers/the-bugs-we-have-to-kill.pdf\"]],[\"a\",[\"href\",\"https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"I just read Tony Ascieri's \"],[0,[0],1,\"A tale of two cryptocurrencies\"],[0,[],0,\" and while it's generally a pleasant overview of what's going on in cryptocurrency today, it has a few big misconceptions, and is missing a lot of detail on some other fronts.\"]]],[1,\"p\",[[0,[],0,\"The essay adopts a tone that has been common in the week since the DAO hack, a conviction that Turing-complete languages are doomed to fail, and that anyone who would use them for anything is stupid. I don't think this is the case. There's a huge amount of critical code in the world which is Turing-complete, and things are OK. Do software vulnerabilities exist? Yes. But they do not stop us writing complex and sensitive systems. \"]]],[1,\"p\",[[0,[],0,\"Tony's piece makes the distinction that the really dangerous thing is to have Turing-complete \"],[0,[1],1,\"input\"],[0,[],0,\" languages. In my reading of some of the \"],[0,[2],1,\"langsec material\"],[0,[],0,\" that he cites, this distinction is made because so many programs are written with the mentality that their input is simple and is not worth treating as a language. A lot of bugs have arisen because of a program acting more like a parser, and its input acting more like a language than the programmer suspected. I don't feel that Ethereum's EVM bytecode qualifies as an \"],[0,[1],1,\"input\"],[0,[],0,\" language under this criteria. It's intended to be a language, and it's intended to be Turing complete. It has come, and continues to come under the scrutiny appropriate to such a role.\"]]],[1,\"p\",[[0,[],0,\"The idea is that Turing complete languages are undecidable, and thus, that it is impossible to prove that they are secure. Indeed, one cannot prove that a Turing complete program will ever stop running (the halting problem). This doesn't stop us from using Turing complete code in critical applications. It's impossible to formally verify that your airplane isn't going to crash into the ocean, but that doesn't stop you getting on a plane. Because of the dangers of unexpected behavior, we make sure to test carefully, and use programming patterns that prevent bugs.\"]]],[1,\"p\",[[0,[],0,\"Turing complete EVM bytecode has all the same vulnerabilities of the software surrounding us, flying airplanes, running bank servers, and even driving cars. In the case of self-driving cars, neural networks perform a lot of their logic. Neural networks are far beyond any kind of static analysis or formal proof. The only way to verify that they are correct (and indeed the only way to program them) is to test them many times with many different inputs and make sure that they behave as expected. This doesn't stop us from making use of them.\"]]],[1,\"p\",[[0,[],0,\"The vulnerability that killed the DAO was very simple in nature. When you send money to an Ethereum contract, it has the option to run some code upon receiving the money. The mistake made by the authors of the DAO was to debit the account of the sender \"],[0,[1],1,\"after\"],[0,[],0,\" sending the money. The attacker's contract called the DAO's sending function again, triggering another send before debiting the attackers account for the first send. This vulnberability was actually quite similar to the vulnerabilities that can exist in databases that do not implement transactions (like MonogDB). These are bad vulnerabilities, but they are well understood and it is easy to mitigate them with mechanisms such as 2 phase commits, mutexes, etc. \"]]],[1,\"p\",[[0,[],0,\"While the vulnerability would have been caught in a formal proof, it also would have been caught by a code review. In fact, it was caught by a code review. Least Authority caught this vulnerability 2 years ago when they audited Ethereum, and there were several papers and blog posts written about it in the weeks before the hack. I think that mitigation strategies will take the form of \"],[0,[3],1,\"defense in depth\"],[0,[],0,\", with contract developers learning best practices and using frameworks to automate sensitive procedures, much like most databases come with the ability to do transactions, and avoid SQL injection.\"]]],[1,\"p\",[[0,[],0,\"Maybe there is a non Turing complete language out there that strikes the best balance between decidability and expressiveness. When it emerges, it will be possible to implement it on top of Turing-complete languages such as Solidity or EVM bytecode. It is not possible to go the other way. Like getting a haircut, it's a lot easier to take expressiveness away than to add it back. If language research progresses to such a point that it becomes easy to formally verify any program, while retaining the productivity of today's languages, it will greatly benefit all of computing. Until then, in smart contracts as in other areas, people will use code that \"],[0,[1],1,\"runs\"],[0,[],0,\" and does what it needs to do with some reasonable assurance of safety.\"]]],[1,\"h2\",[[0,[],0,\"Lightning\"]]],[1,\"p\",[[0,[],0,\"Another topic that Tony touches on is the Bitcoin Lightning network. The Lightning network is a network of payment channels using hashlock reveals to trustlessly move payments across intermediary nodes without posting any transactions to the blockchain. Tony feels that the Lightning network is overly complex and possibly insecure. I agree with this assessment, but not in the way Tony thinks. I actually think that the Lightning network is complicated because of the non Turing complete language that it is programmed in- Bitcoin script. Allow me to explain.\"]]],[1,\"p\",[[0,[],0,\"Once you get past the complications introduced by Bitcoin script, the concept of channels and hashlocks is simple. A channel is an escrow arrangement that allows two participants to exchange payments directly between each other without having to contact a bank or blockchain to process and clear the payment. Let's say that Alice and Bob want to open a channel. They go to the bank and open a special escrow account and each put in $100. They tell the bank \"]]],[1,\"p\",[[0,[],0,\"\\\"Give this money back to us when you receive a note signed by both of us, with updated balances\\\"\"]]],[1,\"p\",[[0,[],0,\"If Alice now wants to pay Bob $5, she writes a note that says \"]]],[1,\"p\",[[0,[],0,\"\\\"Alice: $95, Bob: $105\\\"\"]]],[1,\"p\",[[0,[],0,\"She signs this and sends it to Bob. Now Bob can consider himself paid. If he wants to get his money out of the channel, he signs the note as well, and gives it to the bank. The bank pays him $105 and Alice $95, and Bob is $5 ahead.\"]]],[1,\"p\",[[0,[],0,\"There's a problem: Someone can cheat. Let's say that Alice and Bob have been exchanging these notes back and forth for a while, and the last note read \"]]],[1,\"p\",[[0,[],0,\"\\\"Alice: $195, Bob: $5\\\".\"]]],[1,\"p\",[[0,[],0,\"If Bob wants to cheat, he could just take the first note to the bank and receive $105. To combat this, we use a sequence number and a \\\"challenge period\\\". When Alice or Bob take a note to the bank, the challenge period starts. If during this challenge period, a signed note with a higher sequence number is submitted, the bank honors this note instead. This way, as long as Alice and Bob check in with the bank at least once every hold period, they can stop each other from cheating.\"]]],[1,\"p\",[[0,[],0,\"This mechanism lets Alice and Bob exchange as many payments as they want, as fast as they can send notes back and forth, within the amount that they have placed in escrow, without having to trust each other. But what if Alice wants to send a payment to someone she doesn't have a channel open with? Let's say that she wants to send a payment to Charlie, and Charlie has a channel open with Bob. She could send Bob a payment, and trust him to send Charlie a payment of the same amount. What if Alice wants to send Charlie a payment without having to trust Bob? This is possible with something called a hashlock.\"]]],[1,\"p\",[[0,[],0,\"Alice sends Bob a note with balances updated to give Bob a payment which says\"]]],[1,\"p\",[[0,[],0,\"\\\"Only honor this note if Bob presents the preimage to this hash: 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b\\\"\"]]],[1,\"p\",[[0,[],0,\"She sends the preimage to Charlie. Now Bob can only get his money if he can find the preimage. To get Charlie to give him the preimage, he prepares a note like the one that Alice sent him, locked with the same hash. For Charlie to unlock this payment, he must reveal the preimage to either the bank (if he's going to close the channel at this step) or to Bob. Once Bob's got the preimage, he can do the same to get his payment from Alice. Payment setup goes forward, payment authorization goes backward. At each step, incentives are aligned so that participants do not need to trust each other. This kind of payment can go over an arbitrary number of intermediary nodes, and if there is a large enough network, one can theoretically get a payment to anyone on the network.\"]]],[1,\"p\",[[0,[],0,\"This is how the Lightning network is supposed to operate. Of course, in the case of Lightning, the actual procedures are much more complex. This is not because the creators of Lightning were being intentionally obtuse. It is because Lightning needs to work with Bitcoin script, a non Turing complete language. This same type of network is far simpler to implement on Ethereum. Turing complete languages allow humans to express a series of steps in a way that makes sense to us. Non Turing complete languages force the programmer to jump through a lot of hoops, and work around the language. Tony's complaints about the complexity of Lightning actually disprove his take on Turing complete languages from the previous section!\"]]],[1,\"p\",[[0,[],0,\"Tony asks \\\"what if one of the hubs on the Lightning network gets popped?\\\" Absolutely nothing happens to anyone using the hub for payments, although the operator of the hub could lose a lot of money. The entire system is premised upon the being able to move payments across nodes that one does not trust. \"]]]]}","html":"<p>I just read Tony Ascieri&#39;s <a href=\"https://tonyarcieri.com/a-tale-of-two-cryptocurrencies\">A tale of two cryptocurrencies</a> and while it&#39;s generally a pleasant overview of what&#39;s going on in cryptocurrency today, it has a few big misconceptions, and is missing a lot of detail on some other fronts.</p>\n\n<p>The essay adopts a tone that has been common in the week since the DAO hack, a conviction that Turing-complete languages are doomed to fail, and that anyone who would use them for anything is stupid. I don&#39;t think this is the case. There&#39;s a huge amount of critical code in the world which is Turing-complete, and things are OK. Do software vulnerabilities exist? Yes. But they do not stop us writing complex and sensitive systems. </p>\n\n<p>Tony&#39;s piece makes the distinction that the really dangerous thing is to have Turing-complete <em>input</em> languages. In my reading of some of the <a href=\"http://langsec.org/papers/the-bugs-we-have-to-kill.pdf\">langsec material</a> that he cites, this distinction is made because so many programs are written with the mentality that their input is simple and is not worth treating as a language. A lot of bugs have arisen because of a program acting more like a parser, and its input acting more like a language than the programmer suspected. I don&#39;t feel that Ethereum&#39;s EVM bytecode qualifies as an <em>input</em> language under this criteria. It&#39;s intended to be a language, and it&#39;s intended to be Turing complete. It has come, and continues to come under the scrutiny appropriate to such a role.</p>\n\n<p>The idea is that Turing complete languages are undecidable, and thus, that it is impossible to prove that they are secure. Indeed, one cannot prove that a Turing complete program will ever stop running (the halting problem). This doesn&#39;t stop us from using Turing complete code in critical applications. It&#39;s impossible to formally verify that your airplane isn&#39;t going to crash into the ocean, but that doesn&#39;t stop you getting on a plane. Because of the dangers of unexpected behavior, we make sure to test carefully, and use programming patterns that prevent bugs.</p>\n\n<p>Turing complete EVM bytecode has all the same vulnerabilities of the software surrounding us, flying airplanes, running bank servers, and even driving cars. In the case of self-driving cars, neural networks perform a lot of their logic. Neural networks are far beyond any kind of static analysis or formal proof. The only way to verify that they are correct (and indeed the only way to program them) is to test them many times with many different inputs and make sure that they behave as expected. This doesn&#39;t stop us from making use of them.</p>\n\n<p>The vulnerability that killed the DAO was very simple in nature. When you send money to an Ethereum contract, it has the option to run some code upon receiving the money. The mistake made by the authors of the DAO was to debit the account of the sender <em>after</em> sending the money. The attacker&#39;s contract called the DAO&#39;s sending function again, triggering another send before debiting the attackers account for the first send. This vulnberability was actually quite similar to the vulnerabilities that can exist in databases that do not implement transactions (like MonogDB). These are bad vulnerabilities, but they are well understood and it is easy to mitigate them with mechanisms such as 2 phase commits, mutexes, etc. </p>\n\n<p>While the vulnerability would have been caught in a formal proof, it also would have been caught by a code review. In fact, it was caught by a code review. Least Authority caught this vulnerability 2 years ago when they audited Ethereum, and there were several papers and blog posts written about it in the weeks before the hack. I think that mitigation strategies will take the form of <a href=\"https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/\">defense in depth</a>, with contract developers learning best practices and using frameworks to automate sensitive procedures, much like most databases come with the ability to do transactions, and avoid SQL injection.</p>\n\n<p>Maybe there is a non Turing complete language out there that strikes the best balance between decidability and expressiveness. When it emerges, it will be possible to implement it on top of Turing-complete languages such as Solidity or EVM bytecode. It is not possible to go the other way. Like getting a haircut, it&#39;s a lot easier to take expressiveness away than to add it back. If language research progresses to such a point that it becomes easy to formally verify any program, while retaining the productivity of today&#39;s languages, it will greatly benefit all of computing. Until then, in smart contracts as in other areas, people will use code that <em>runs</em> and does what it needs to do with some reasonable assurance of safety.</p>\n\n<h2>Lightning</h2>\n\n<p>Another topic that Tony touches on is the Bitcoin Lightning network. The Lightning network is a network of payment channels using hashlock reveals to trustlessly move payments across intermediary nodes without posting any transactions to the blockchain. Tony feels that the Lightning network is overly complex and possibly insecure. I agree with this assessment, but not in the way Tony thinks. I actually think that the Lightning network is complicated because of the non Turing complete language that it is programmed in- Bitcoin script. Allow me to explain.</p>\n\n<p>Once you get past the complications introduced by Bitcoin script, the concept of channels and hashlocks is simple. A channel is an escrow arrangement that allows two participants to exchange payments directly between each other without having to contact a bank or blockchain to process and clear the payment. Let&#39;s say that Alice and Bob want to open a channel. They go to the bank and open a special escrow account and each put in $100. They tell the bank </p>\n\n<blockquote><p>&quot;Give this money back to us when you receive a note signed by both of us, with updated balances&quot;</p></blockquote>\n\n<p>If Alice now wants to pay Bob $5, she writes a note that says </p>\n\n<blockquote><p>&quot;Alice: $95, Bob: $105&quot;</p></blockquote>\n\n<p>She signs this and sends it to Bob. Now Bob can consider himself paid. If he wants to get his money out of the channel, he signs the note as well, and gives it to the bank. The bank pays him $105 and Alice $95, and Bob is $5 ahead.</p>\n\n<p>There&#39;s a problem: Someone can cheat. Let&#39;s say that Alice and Bob have been exchanging these notes back and forth for a while, and the last note read </p>\n\n<blockquote><p>&quot;Alice: $195, Bob: $5&quot;.</p></blockquote>\n\n<p>If Bob wants to cheat, he could just take the first note to the bank and receive $105. To combat this, we use a sequence number and a &quot;challenge period&quot;. When Alice or Bob take a note to the bank, the challenge period starts. If during this challenge period, a signed note with a higher sequence number is submitted, the bank honors this note instead. This way, as long as Alice and Bob check in with the bank at least once every hold period, they can stop each other from cheating.</p>\n\n<p>This mechanism lets Alice and Bob exchange as many payments as they want, as fast as they can send notes back and forth, within the amount that they have placed in escrow, without having to trust each other. But what if Alice wants to send a payment to someone she doesn&#39;t have a channel open with? Let&#39;s say that she wants to send a payment to Charlie, and Charlie has a channel open with Bob. She could send Bob a payment, and trust him to send Charlie a payment of the same amount. What if Alice wants to send Charlie a payment without having to trust Bob? This is possible with something called a hashlock.</p>\n\n<p>Alice sends Bob a note with balances updated to give Bob a payment which says</p>\n\n<blockquote><p>&quot;Only honor this note if Bob presents the preimage to this hash: 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b&quot;</p></blockquote>\n\n<p>She sends the preimage to Charlie. Now Bob can only get his money if he can find the preimage. To get Charlie to give him the preimage, he prepares a note like the one that Alice sent him, locked with the same hash. For Charlie to unlock this payment, he must reveal the preimage to either the bank (if he&#39;s going to close the channel at this step) or to Bob. Once Bob&#39;s got the preimage, he can do the same to get his payment from Alice. Payment setup goes forward, payment authorization goes backward. At each step, incentives are aligned so that participants do not need to trust each other. This kind of payment can go over an arbitrary number of intermediary nodes, and if there is a large enough network, one can theoretically get a payment to anyone on the network.</p>\n\n<p>This is how the Lightning network is supposed to operate. Of course, in the case of Lightning, the actual procedures are much more complex. This is not because the creators of Lightning were being intentionally obtuse. It is because Lightning needs to work with Bitcoin script, a non Turing complete language. This same type of network is far simpler to implement on Ethereum. Turing complete languages allow humans to express a series of steps in a way that makes sense to us. Non Turing complete languages force the programmer to jump through a lot of hoops, and work around the language. Tony&#39;s complaints about the complexity of Lightning actually disprove his take on Turing complete languages from the previous section!</p>\n\n<p>Tony asks &quot;what if one of the hubs on the Lightning network gets popped?&quot; Absolutely nothing happens to anyone using the hub for payments, although the operator of the hub could lose a lot of money. The entire system is premised upon the being able to move payments across nodes that one does not trust. </p>","comment_id":null,"plaintext":"I just read Tony Ascieri's [A tale of two cryptocurrencies](https://tonyarcieri.com/a-tale-of-two-cryptocurrencies) and while it's generally a pleasant overview of what's going on in cryptocurrency today, it has a few big misconceptions, and is missing a lot of detail on some other fronts.\n\nThe essay adopts a tone that has been common in the week since the DAO hack, a conviction that Turing-complete languages are doomed to fail, and that anyone who would use them for anything is stupid. I don't think this is the case. There's a huge amount of critical code in the world which is Turing-complete, and things are OK. Do software vulnerabilities exist? Yes. But they do not stop us writing complex and sensitive systems. \n\nTony's piece makes the distinction that the really dangerous thing is to have Turing-complete _input_ languages. In my reading of some of the [langsec material](http://langsec.org/papers/the-bugs-we-have-to-kill.pdf) that he cites, this distinction is made because so many programs are written with the mentality that their input is simple and is not worth treating as a language. A lot of bugs have arisen because of a program acting more like a parser, and its input acting more like a language than the programmer suspected. I don't feel that Ethereum's EVM bytecode qualifies as an _input_ language under this criteria. It's intended to be a language, and it's intended to be Turing complete. It has come, and continues to come under the scrutiny appropriate to such a role.\n\nThe idea is that Turing complete languages are undecidable, and thus, that it is impossible to prove that they are secure. Indeed, one cannot prove that a Turing complete program will ever stop running (the halting problem). This doesn't stop us from using Turing complete code in critical applications. It's impossible to formally verify that your airplane isn't going to crash into the ocean, but that doesn't stop you getting on a plane. Because of the dangers of unexpected behavior, we make sure to test carefully, and use programming patterns that prevent bugs.\n\nTuring complete EVM bytecode has all the same vulnerabilities of the software surrounding us, flying airplanes, running bank servers, and even driving cars. In the case of self-driving cars, neural networks perform a lot of their logic. Neural networks are far beyond any kind of static analysis or formal proof. The only way to verify that they are correct (and indeed the only way to program them) is to test them many times with many different inputs and make sure that they behave as expected. This doesn't stop us from making use of them.\n\nThe vulnerability that killed the DAO was very simple in nature. When you send money to an Ethereum contract, it has the option to run some code upon receiving the money. The mistake made by the authors of the DAO was to debit the account of the sender _after_ sending the money. The attacker's contract called the DAO's sending function again, triggering another send before debiting the attackers account for the first send. This vulnberability was actually quite similar to the vulnerabilities that can exist in databases that do not implement transactions (like MonogDB). These are bad vulnerabilities, but they are well understood and it is easy to mitigate them with mechanisms such as 2 phase commits, mutexes, etc. \n\nWhile the vulnerability would have been caught in a formal proof, it also would have been caught by a code review. In fact, it was caught by a code review. Least Authority caught this vulnerability 2 years ago when they audited Ethereum, and there were several papers and blog posts written about it in the weeks before the hack. I think that mitigation strategies will take the form of [defense in depth](https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/), with contract developers learning best practices and using frameworks to automate sensitive procedures, much like most databases come with the ability to do transactions, and avoid SQL injection.\n\nMaybe there is a non Turing complete language out there that strikes the best balance between decidability and expressiveness. When it emerges, it will be possible to implement it on top of Turing-complete languages such as Solidity or EVM bytecode. It is not possible to go the other way. Like getting a haircut, it's a lot easier to take expressiveness away than to add it back. If language research progresses to such a point that it becomes easy to formally verify any program, while retaining the productivity of today's languages, it will greatly benefit all of computing. Until then, in smart contracts as in other areas, people will use code that *runs* and does what it needs to do with some reasonable assurance of safety.\n\n## Lightning\n\nAnother topic that Tony touches on is the Bitcoin Lightning network. The Lightning network is a network of payment channels using hashlock reveals to trustlessly move payments across intermediary nodes without posting any transactions to the blockchain. Tony feels that the Lightning network is overly complex and possibly insecure. I agree with this assessment, but not in the way Tony thinks. I actually think that the Lightning network is complicated because of the non Turing complete language that it is programmed in- Bitcoin script. Allow me to explain.\n\nOnce you get past the complications introduced by Bitcoin script, the concept of channels and hashlocks is simple. A channel is an escrow arrangement that allows two participants to exchange payments directly between each other without having to contact a bank or blockchain to process and clear the payment. Let's say that Alice and Bob want to open a channel. They go to the bank and open a special escrow account and each put in $100. They tell the bank \n\n> \"Give this money back to us when you receive a note signed by both of us, with updated balances\"\n\nIf Alice now wants to pay Bob $5, she writes a note that says \n\n> \"Alice: $95, Bob: $105\"\n\nShe signs this and sends it to Bob. Now Bob can consider himself paid. If he wants to get his money out of the channel, he signs the note as well, and gives it to the bank. The bank pays him $105 and Alice $95, and Bob is $5 ahead.\n\nThere's a problem: Someone can cheat. Let's say that Alice and Bob have been exchanging these notes back and forth for a while, and the last note read \n\n> \"Alice: $195, Bob: $5\".\n\nIf Bob wants to cheat, he could just take the first note to the bank and receive $105. To combat this, we use a sequence number and a \"challenge period\". When Alice or Bob take a note to the bank, the challenge period starts. If during this challenge period, a signed note with a higher sequence number is submitted, the bank honors this note instead. This way, as long as Alice and Bob check in with the bank at least once every hold period, they can stop each other from cheating.\n\nThis mechanism lets Alice and Bob exchange as many payments as they want, as fast as they can send notes back and forth, within the amount that they have placed in escrow, without having to trust each other. But what if Alice wants to send a payment to someone she doesn't have a channel open with? Let's say that she wants to send a payment to Charlie, and Charlie has a channel open with Bob. She could send Bob a payment, and trust him to send Charlie a payment of the same amount. What if Alice wants to send Charlie a payment without having to trust Bob? This is possible with something called a hashlock.\n\nAlice sends Bob a note with balances updated to give Bob a payment which says\n\n> \"Only honor this note if Bob presents the preimage to this hash: 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b\"\n\nShe sends the preimage to Charlie. Now Bob can only get his money if he can find the preimage. To get Charlie to give him the preimage, he prepares a note like the one that Alice sent him, locked with the same hash. For Charlie to unlock this payment, he must reveal the preimage to either the bank (if he's going to close the channel at this step) or to Bob. Once Bob's got the preimage, he can do the same to get his payment from Alice. Payment setup goes forward, payment authorization goes backward. At each step, incentives are aligned so that participants do not need to trust each other. This kind of payment can go over an arbitrary number of intermediary nodes, and if there is a large enough network, one can theoretically get a payment to anyone on the network.\n\nThis is how the Lightning network is supposed to operate. Of course, in the case of Lightning, the actual procedures are much more complex. This is not because the creators of Lightning were being intentionally obtuse. It is because Lightning needs to work with Bitcoin script, a non Turing complete language. This same type of network is far simpler to implement on Ethereum. Turing complete languages allow humans to express a series of steps in a way that makes sense to us. Non Turing complete languages force the programmer to jump through a lot of hoops, and work around the language. Tony's complaints about the complexity of Lightning actually disprove his take on Turing complete languages from the previous section!\n\nTony asks \"what if one of the hubs on the Lightning network gets popped?\" Absolutely nothing happens to anyone using the hub for payments, although the operator of the hub could lose a lot of money. The entire system is premised upon the being able to move payments across nodes that one does not trust. ","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-06-23 00:00:00","created_by":"1","updated_at":"2016-06-23 00:00:00","updated_by":"1","published_at":"2016-06-23 00:00:00","published_by":"1","custom_excerpt":"","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc759","uuid":"76850e0a-0561-4ffb-8635-c6378a2fcba0","title":"Althea white paper","slug":"althea-paper","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"image\",{\"src\":\"/images/pir1.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/pir2.png\",\"alt\":\"\",\"title\":\"\"}],[\"code\",{\"code\":\"p'=p+l\"}],[\"code\",{\"code\":\"m'=m+(p*n)\"}],[\"image\",{\"src\":\"/images/payment-flow.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/honest-metric.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/dishonest-metric.png\",\"alt\":\"\",\"title\":\"\"}]],\"markups\":[[\"strong\"],[\"a\",[\"href\",\"/blog/development-update/\"]],[\"code\"],[\"a\",[\"href\",\"/blog/althea-paper/#payments\"]]],\"sections\":[[1,\"p\",[[0,[0],1,\"Note:\"],[0,[],0,\" I've significantly changed my strategy since this was written, and you should read the \"],[0,[1],1,\"development update\"],[0,[],0,\".\"]]],[1,\"p\",[[0,[],0,\"Althea is a set of protocols for a decentralized point-to-point radio network providing connectivity to an area, where participants in the network are able to pay for connectivity, and receive payment for their contributions to the network, without a centralized ISP collecting subscriptions and owning equipment. It combines the commercial viability of a wireless ISP with the decentralized nature of a community mesh network. There are two main components- payments and routing.\"]]],[1,\"h2\",[[0,[],0,\"[0] Overview\"]]],[1,\"p\",[[0,[],0,\"Althea is meant to operate on the last mile, i.e. from an uplink (or transit provider) to the end user, and creates something like a \\\"distributed ISP\\\". The last mile is an inefficient market- many areas only have one ISP. The reason for this is that there is a very high barrier to entry. Currently, if you want to compete with your local ISP, you first get a subscription to an uplink, which will sell you a lot of bandwidth \\\"in bulk\\\". You then have to build out a local network which is large enough to service enough end users to pay for the operation of your ISP business. You have to hire a staff to administer the network along with businesspeople and lawyers to run the business, and its billing and contractual infrastructure.\"]]],[1,\"p\",[[0,[],0,\"You then have to go out and find those end users and convince them to sign up to your service, usually as a monthly subscription. This marketing and advertising can be very expensive, and you will probably want to hire someone to administer the effort, along with marketing and advertising consultants to execute the campaign. This heavily favors firms that are able to make large investments, have name recognition, or have existing subscribers for a related service (like cable television or telephone services).\"]]],[1,\"p\",[[0,[],0,\"Once the ISP is self-sustaining, it's time to take profit. End users are unlikely to switch providers, as the barriers to entry discussed above make it difficult for competitors to gain a foothold. Additionally, many end users have been locked into contracts with a provider, and will almost certainly not switch. As the ISP is in pure profit-taking mode, service and maintenance are considered cost centers to be eliminated. This results in much of the dissatisfaction felt by many end users towards their ISP.\"]]],[1,\"p\",[[0,[],0,\"Althea is an attempt to create a much more fluid and competitive model, by removing the distinction between end user, ISP, and uplink. The goal is for any person to be able to set up an intermediary node that can route traffic for others, and receive payment for the service. Switching costs within the system are completely eliminated, as nodes switch between neighbors automatically according to a routing protocol which finds a route with the best combination of reliability, bandwidth, and low cost.\"]]],[1,\"p\",[[0,[],0,\"Advertising and marketing costs for the new entrant are eliminated, as the only advertisements in this system are the automatic advertisements of price and route quality between nodes. Contract and billing costs are eliminated by payment channels. Payment channels are a technology from the blockchain world, which allow one to make micropayments with very low overhead. In a payment channel, each payment is a message under a few hundred bytes, sent directly between the sender and the receiver, with no contact of a third party bank or payment processor, and no need to wait for payments to clear. The use of a public blockchain (i.e. Bitcoin or Ethereum), means that participants are able to send and receive these payments without having to pay fees to a payment processor or procuring expensive money transmitter licenses.\"]]],[1,\"p\",[[0,[],0,\"Our goal is to eliminate the costs associated with providing paid internet access by moving most of the functions of an ISP business into the underlying protocol. Our thesis is that this will result in a market with a much higher degree of competitiveness and efficiency. This will translate into lower prices to the end user for better access to the internet. Another benefit is that of a more equitable marketplace, where money paid for internet access goes directly to members of a local community instead of being captured by multinational corporations. This could play a small part in stimulating local economies and distributing wealth more fairly in the world.  \"]]],[1,\"h2\",[[0,[],0,\"[1] Routing\"]]],[1,\"p\",[[0,[],0,\"Nodes route packets using an ad-hoc “mesh” routing protocol. This protocol must take price as well as link quality into account. We define several extensions to Babel, a popular and performant ad-hoc routing protocol.\"]]],[1,\"p\",[[0,[],0,\"Here’s an excerpt to give you an idea of how Babel works:\"]]],[1,\"p\",[[0,[],0,\"2.1. Costs, Metrics, and Neighbourship\"]]],[1,\"p\",[[0,[],0,\"As many routing algorithms, Babel computes costs of links between any two neighbouring nodes, abstract values attached to the edges between two nodes. We write C(A, B) for the cost of the edge from node A to node B.\"]]],[1,\"p\",[[0,[],0,\"Given a route between any two nodes, the metric of the route is the sum of the costs of all the edges along the route.  The goal of the  routing algorithm is to compute, for every source S, the tree of the routes of lowest metric to S.\"]]],[1,\"p\",[[0,[],0,\"Costs and metrics need not be integers.  In general, they can be values in any algebra that satisfies two fairly general conditions (Section 3.5.2).\"]]],[1,\"p\",[[0,[],0,\"A Babel node periodically broadcasts Hello messages to all of its neighbours; it also periodically sends an IHU (\\\"I Heard You\\\") message to every neighbour from which it has recently heard a Hello.  From the information derived from Hello and IHU messages received from its neighbour B, a node A computes the cost C(A, B) of the link from A to B.\"]]],[1,\"p\",[[0,[],0,\"Babel provides a mechanism for extensibility, which is the basis for the modifications defined in this paper.\"]]],[1,\"h3\",[[0,[],0,\"[1.2] Babel extension: Price-aware routing\"]]],[1,\"p\",[[0,[],0,\"Babel is a good fit for routing based on payments because of its method of operation, known as \\\"distance vector\\\". \"]]],[10,0],[1,\"p\",[[0,[],0,\"Distance vector routing works by assigning a quality metric to the links between nodes, where higher is worse. Nodes then gossip information about which nodes they can reach at which quality. From this information, each node is able to build up a routing table containing the all destinations in the network, along with their composite quality metric, and the neighbor to forward packets for a destination.\"]]],[10,1],[1,\"p\",[[0,[],0,\"This extension allows a Babel router to attach information about monetary price to the routes that it maintains. The router also propagates this information to its neighbors, who use it to determine their own prices. The price is taken into account for metric computation and route selection. It is also used by a payment protocol external to Babel (defined below in “Payments”) to pay neighbors to forward data.\"]]],[1,\"h4\",[[0,[],0,\"[1.2.1] Changes to data structures\"]]],[1,\"p\",[[0,[],0,\"A router implementing price-aware routing has one additional field in each route table entry:\"]]],[3,\"ul\",[[[0,[],0,\"A price field, denoting how much the router charges to forward packets along this route. \"]]]],[1,\"h4\",[[0,[],0,\"[1.2.3] Receiving updates\"]]],[1,\"p\",[[0,[],0,\"When a node receives an Update TLV, it creates or updates a routing table entry according to Babel, section 3.5.4.  A node that performs price-aware routing extends that procedure by setting the routing table entry price field to \"],[0,[2],1,\"p'\"],[0,[],0,\", where: \"]]],[10,2],[1,\"p\",[[0,[],0,\"Let \"],[0,[2],1,\"p\"],[0,[],0,\" be the price attached to the received Update TLV. Let \"],[0,[2],1,\"l\"],[0,[],0,\" be the price per kilobyte charged by the Babel router to forward packets along the update’s route. Determination of \"],[0,[2],1,\"l\"],[0,[],0,\" is implementation-dependent, but for a simple implementation, a single \"],[0,[2],1,\"l\"],[0,[],0,\" can be used for all routes.\"]]],[1,\"h4\",[[0,[],0,\"[1.2.4] Route selection\"]]],[1,\"p\",[[0,[],0,\"Route selection is discussed in Babel, section 3.6. The exact procedure is left as an implementation detail but a simple example is:\"]]],[1,\"p\",[[0,[],0,\"routes with a small metric should be preferred over routes with a   large metric;\"]]],[1,\"p\",[[0,[],0,\"Similarly, in price-aware routing, routes with a low price should be preferred over routes with a high price. These two criteria both need to factor into the selection. For example, a combined metric m` could be defined as:\"]]],[10,3],[1,\"p\",[[0,[],0,\"where \"],[0,[2],1,\"m\"],[0,[],0,\" is the metric, \"],[0,[2],1,\"p\"],[0,[],0,\" is the price, and \"],[0,[2],1,\"n\"],[0,[],0,\" is a constant multiplier.\"]]],[1,\"p\",[[0,[],0,\"Aside: It was hard to choose whether to make this a route selection procedure, extending section 3.6, or a metric computation, extending section 3.5.2. We chose to make it a route selection procedure, as metrics computed by section 3.5.2 are propagated to a node’s neighbors. Since the price is already propagated by this extension, it seems like a bad idea to propagate it again as a factor in the route metric. There is a possibility that this decision will need to be revisited.\"]]],[1,\"h3\",[[0,[],0,\"[1.3] Gateway discovery\"]]],[1,\"p\",[[0,[],0,\"With the routing and payments described above, nodes can pay to have packets forwarded to destinations on the network. Other services can be built on top of this network. It's like the postal service. You attach an address and payment to a package and it gets delivered to its destination. If you order something that will be shipped to you, you have to pay for the item, plus the cot of sending it to you.\"]]],[1,\"p\",[[0,[],0,\"One very important service is providing a gateway to the internet. Nodes acting as gateways advertise a price and a quality metric for a connection to the internet. This information needs to be advertised to the rest of the network so that other nodes can choose which gateway to use. When a node has chosen a gateway, it pays for the service with a payment channel in the same way it pays its neighbors.\"]]],[1,\"p\",[[0,[],0,\"It's important to note that this involves the gateway paying to forward the response packets back to the end user. Like the mail-order example above, this means that an end user must send the gateway enough money to cover the price of the internet service, plus the price of sending the response packets back.\"]]],[1,\"p\",[[0,[],0,\"We haven't written the protocol around this yet. There are several other systems in development, so we may use one of them. In any case, the concept can be tested with the protocols in 1.1 and 1.2.\"]]],[1,\"h2\",[[0,[],0,\"[2] Payments\"]]],[1,\"p\",[[0,[],0,\"Each node on the network establishes payment channels with each of its neighbors. A payment channel is a method for two parties to exchange payments trustlessly by signing transactions that alter the balance of an escrow account held by a bank or blockchain (we may use the Ethereum blockchain for Althea).\"]]],[1,\"p\",[[0,[],0,\"The important thing about a payment channel is that after the channel has been opened, and funds have been placed in escrow, individual payments can be made directly between the two parties without submitting anything to the bank or blockchain. This means that the entire payment can be completed in one packet. Most payment systems need to send another transmission to a bank or blockchain, and wait for it to be confirmed. This would be too much overhead for use with Althea, which is why payment channels are used instead.\"]]],[1,\"p\",[[0,[],0,\"When Alice wishes to send a packet to a destination (Charlie) on the network, she consults her routing table to find the best neighbor to forward it to. This routing table was built up by Babel, taking link quality and price (as computed in \"],[0,[3],1,\"section 1.2\"],[0,[],0,\" above) into account, so the neighbor will be the one judged to have the best and cheapest route to the destination. Alice then appends a state update for her payment channel with Bob to the packet which pays him the rate that he is advertising for that destination. When Bob receives the packet and the payment, he forwards the packet on to his best neighbor, paying them the fee they charge to get a packet to that destination. Since Bob has set his fee to slightly higher that what his neighbor is charging to get to that destination, he will make a profit. This process continues until the packet reaches its destination.\"]]],[10,4],[1,\"p\",[[0,[],0,\"In this way, Alice can send packets to any packet in the network, while transmitters along the way are compensated.\"]]],[1,\"h2\",[[0,[],0,\"[3] Vulnerabilities\"]]],[1,\"p\",[[0,[],0,\"As you may have noticed, this system is vulnerable. Babel makes no provision for hostile nodes. Under this protocol, any node can advertise a cost of 0 to every destination on the network, and have all traffic from its neighbors routed through it, and receive payment (while dropping the packets, or offering worse than advertised performance and reliability). There are also other, more subtle exploits.\"]]],[1,\"p\",[[0,[],0,\"There is some work on securing Babel and other distance vector routing protocols. However, this work tends to focus on the vulnerabilities that could occur in a network without monetary incentives. There are mitigations for DOS, impersonation of other nodes, and blackhole attacks. For now, we will consider these attacks to be outside of the scope of Althea. Satisfactory solutions need to be found, but this research is specific to Babel. \"]]],[1,\"p\",[[0,[],0,\"Many of these mitigations assume a threat model where an adversary is attempting to disrupt or censor a network. We are more concerned about the treat model of many unscrupulous adversaries who are simply trying to defraud the network to get some incrementally higher total payment than they would otherwise.\"]]],[1,\"p\",[[0,[],0,\"Let's say that Alice and Bob are neighbors. Bob learns that he can reach Doris with a quality of 4. However, he tells Alice that he can reach Doris with a quality of 3. Alice routes her packets to Doris through Bob and pays him, although Bob is not the best route. This type of \\\"false advertisement\\\" attack is specific to Althea, because the adversary's motivation is monetary.\"]]],[1,\"h4\",[[0,[],0,\"[3.1] Cost metric validation\"]]],[1,\"p\",[[0,[],0,\"For Alice to catch Bob attempting a false advertisement attack, she must be able to check that the quality metric that Bob is reporting for a destination is truthful. Distance vector functions by summing the quality metric that nodes report about their neighbors.\"]]],[10,5],[1,\"p\",[[0,[],0,\"The distance vector cost to D seen by A is the summation of the link costs of all the links along the best route. Depending on the link quality metric used, it should be possible for this summation to be roughly equal to the overall link cost computed by A between it and D.\"]]],[1,\"p\",[[0,[],0,\"This overall link cost can be computed in the same way that the individual link quality costs are computed, by analyzing percentage of successfully acknowledged transmissions over a given time period.\"]]],[10,6],[1,\"p\",[[0,[],0,\"If someone on the route is advertising a lower (better) quality metric than they are actually able to provide, the distance vector cost seen by A will differ from the overall link cost.\"]]],[1,\"p\",[[0,[],0,\"Once A knows that B is giving it bad information, A can complain to B, or take steps to cut the connection. If B is honest, B will want to do the same kind of check on the neighbor that gave it the bad route. This chain of verification will be repeated until it reaches the node that is the source of the inaccurate quality metric. If this node does not correct the issue, its neighbor may cut it off.\"]]],[1,\"p\",[[0,[],0,\"From these primitives, it should be possible to build an anti-cheating protocol. The simplest implementation would be to compute an honesty score for each neighbor, and let a human operator choose to disconnect from a neighbor with an especially bad score.\"]]]]}","html":"<p><strong>Note:</strong> I&#39;ve significantly changed my strategy since this was written, and you should read the <a href=\"/blog/development-update/\">development update</a>.</p>\n\n<p>Althea is a set of protocols for a decentralized point-to-point radio network providing connectivity to an area, where participants in the network are able to pay for connectivity, and receive payment for their contributions to the network, without a centralized ISP collecting subscriptions and owning equipment. It combines the commercial viability of a wireless ISP with the decentralized nature of a community mesh network. There are two main components- payments and routing.</p>\n\n<h2>[0] Overview</h2>\n\n<p>Althea is meant to operate on the last mile, i.e. from an uplink (or transit provider) to the end user, and creates something like a &quot;distributed ISP&quot;. The last mile is an inefficient market- many areas only have one ISP. The reason for this is that there is a very high barrier to entry. Currently, if you want to compete with your local ISP, you first get a subscription to an uplink, which will sell you a lot of bandwidth &quot;in bulk&quot;. You then have to build out a local network which is large enough to service enough end users to pay for the operation of your ISP business. You have to hire a staff to administer the network along with businesspeople and lawyers to run the business, and its billing and contractual infrastructure.</p>\n\n<p>You then have to go out and find those end users and convince them to sign up to your service, usually as a monthly subscription. This marketing and advertising can be very expensive, and you will probably want to hire someone to administer the effort, along with marketing and advertising consultants to execute the campaign. This heavily favors firms that are able to make large investments, have name recognition, or have existing subscribers for a related service (like cable television or telephone services).</p>\n\n<p>Once the ISP is self-sustaining, it&#39;s time to take profit. End users are unlikely to switch providers, as the barriers to entry discussed above make it difficult for competitors to gain a foothold. Additionally, many end users have been locked into contracts with a provider, and will almost certainly not switch. As the ISP is in pure profit-taking mode, service and maintenance are considered cost centers to be eliminated. This results in much of the dissatisfaction felt by many end users towards their ISP.</p>\n\n<p>Althea is an attempt to create a much more fluid and competitive model, by removing the distinction between end user, ISP, and uplink. The goal is for any person to be able to set up an intermediary node that can route traffic for others, and receive payment for the service. Switching costs within the system are completely eliminated, as nodes switch between neighbors automatically according to a routing protocol which finds a route with the best combination of reliability, bandwidth, and low cost.</p>\n\n<p>Advertising and marketing costs for the new entrant are eliminated, as the only advertisements in this system are the automatic advertisements of price and route quality between nodes. Contract and billing costs are eliminated by payment channels. Payment channels are a technology from the blockchain world, which allow one to make micropayments with very low overhead. In a payment channel, each payment is a message under a few hundred bytes, sent directly between the sender and the receiver, with no contact of a third party bank or payment processor, and no need to wait for payments to clear. The use of a public blockchain (i.e. Bitcoin or Ethereum), means that participants are able to send and receive these payments without having to pay fees to a payment processor or procuring expensive money transmitter licenses.</p>\n\n<p>Our goal is to eliminate the costs associated with providing paid internet access by moving most of the functions of an ISP business into the underlying protocol. Our thesis is that this will result in a market with a much higher degree of competitiveness and efficiency. This will translate into lower prices to the end user for better access to the internet. Another benefit is that of a more equitable marketplace, where money paid for internet access goes directly to members of a local community instead of being captured by multinational corporations. This could play a small part in stimulating local economies and distributing wealth more fairly in the world.  </p>\n\n<h2>[1] Routing</h2>\n\n<p>Nodes route packets using an ad-hoc “mesh” routing protocol. This protocol must take price as well as link quality into account. We define several extensions to Babel, a popular and performant ad-hoc routing protocol.</p>\n\n<p>Here’s an excerpt to give you an idea of how Babel works:</p>\n\n<blockquote><p>2.1. Costs, Metrics, and Neighbourship</p><p>As many routing algorithms, Babel computes costs of links between any two neighbouring nodes, abstract values attached to the edges between two nodes. We write C(A, B) for the cost of the edge from node A to node B.</p><p>Given a route between any two nodes, the metric of the route is the sum of the costs of all the edges along the route.  The goal of the  routing algorithm is to compute, for every source S, the tree of the routes of lowest metric to S.</p><p>Costs and metrics need not be integers.  In general, they can be values in any algebra that satisfies two fairly general conditions (Section 3.5.2).</p><p>A Babel node periodically broadcasts Hello messages to all of its neighbours; it also periodically sends an IHU (&quot;I Heard You&quot;) message to every neighbour from which it has recently heard a Hello.  From the information derived from Hello and IHU messages received from its neighbour B, a node A computes the cost C(A, B) of the link from A to B.</p></blockquote>\n\n<p>Babel provides a mechanism for extensibility, which is the basis for the modifications defined in this paper.</p>\n\n<h3>[1.2] Babel extension: Price-aware routing</h3>\n\n<p>Babel is a good fit for routing based on payments because of its method of operation, known as &quot;distance vector&quot;. </p>\n\n<p><img alt=\"\" src=\"/images/pir1.png\"/></p>\n\n<p>Distance vector routing works by assigning a quality metric to the links between nodes, where higher is worse. Nodes then gossip information about which nodes they can reach at which quality. From this information, each node is able to build up a routing table containing the all destinations in the network, along with their composite quality metric, and the neighbor to forward packets for a destination.</p>\n\n<p><img alt=\"\" src=\"/images/pir2.png\"/></p>\n\n<p>This extension allows a Babel router to attach information about monetary price to the routes that it maintains. The router also propagates this information to its neighbors, who use it to determine their own prices. The price is taken into account for metric computation and route selection. It is also used by a payment protocol external to Babel (defined below in “Payments”) to pay neighbors to forward data.</p>\n\n<h4>[1.2.1] Changes to data structures</h4>\n\n<p>A router implementing price-aware routing has one additional field in each route table entry:</p>\n\n<ul><li>A price field, denoting how much the router charges to forward packets along this route. </li></ul>\n\n<h4>[1.2.3] Receiving updates</h4>\n\n<p>When a node receives an Update TLV, it creates or updates a routing table entry according to Babel, section 3.5.4.  A node that performs price-aware routing extends that procedure by setting the routing table entry price field to <code>p&#39;</code>, where: </p>\n\n<pre><code>p&#39;=p+l</code></pre>\n\n<p>Let <code>p</code> be the price attached to the received Update TLV. Let <code>l</code> be the price per kilobyte charged by the Babel router to forward packets along the update’s route. Determination of <code>l</code> is implementation-dependent, but for a simple implementation, a single <code>l</code> can be used for all routes.</p>\n\n<h4>[1.2.4] Route selection</h4>\n\n<p>Route selection is discussed in Babel, section 3.6. The exact procedure is left as an implementation detail but a simple example is:</p>\n\n<blockquote><p>routes with a small metric should be preferred over routes with a   large metric;</p></blockquote>\n\n<p>Similarly, in price-aware routing, routes with a low price should be preferred over routes with a high price. These two criteria both need to factor into the selection. For example, a combined metric m` could be defined as:</p>\n\n<pre><code>m&#39;=m+(p*n)</code></pre>\n\n<p>where <code>m</code> is the metric, <code>p</code> is the price, and <code>n</code> is a constant multiplier.</p>\n\n<p>Aside: It was hard to choose whether to make this a route selection procedure, extending section 3.6, or a metric computation, extending section 3.5.2. We chose to make it a route selection procedure, as metrics computed by section 3.5.2 are propagated to a node’s neighbors. Since the price is already propagated by this extension, it seems like a bad idea to propagate it again as a factor in the route metric. There is a possibility that this decision will need to be revisited.</p>\n\n<h3>[1.3] Gateway discovery</h3>\n\n<p>With the routing and payments described above, nodes can pay to have packets forwarded to destinations on the network. Other services can be built on top of this network. It&#39;s like the postal service. You attach an address and payment to a package and it gets delivered to its destination. If you order something that will be shipped to you, you have to pay for the item, plus the cot of sending it to you.</p>\n\n<p>One very important service is providing a gateway to the internet. Nodes acting as gateways advertise a price and a quality metric for a connection to the internet. This information needs to be advertised to the rest of the network so that other nodes can choose which gateway to use. When a node has chosen a gateway, it pays for the service with a payment channel in the same way it pays its neighbors.</p>\n\n<p>It&#39;s important to note that this involves the gateway paying to forward the response packets back to the end user. Like the mail-order example above, this means that an end user must send the gateway enough money to cover the price of the internet service, plus the price of sending the response packets back.</p>\n\n<p>We haven&#39;t written the protocol around this yet. There are several other systems in development, so we may use one of them. In any case, the concept can be tested with the protocols in 1.1 and 1.2.</p>\n\n<h2>[2] Payments</h2>\n\n<p>Each node on the network establishes payment channels with each of its neighbors. A payment channel is a method for two parties to exchange payments trustlessly by signing transactions that alter the balance of an escrow account held by a bank or blockchain (we may use the Ethereum blockchain for Althea).</p>\n\n<p>The important thing about a payment channel is that after the channel has been opened, and funds have been placed in escrow, individual payments can be made directly between the two parties without submitting anything to the bank or blockchain. This means that the entire payment can be completed in one packet. Most payment systems need to send another transmission to a bank or blockchain, and wait for it to be confirmed. This would be too much overhead for use with Althea, which is why payment channels are used instead.</p>\n\n<p>When Alice wishes to send a packet to a destination (Charlie) on the network, she consults her routing table to find the best neighbor to forward it to. This routing table was built up by Babel, taking link quality and price (as computed in <a href=\"/blog/althea-paper/#payments\">section 1.2</a> above) into account, so the neighbor will be the one judged to have the best and cheapest route to the destination. Alice then appends a state update for her payment channel with Bob to the packet which pays him the rate that he is advertising for that destination. When Bob receives the packet and the payment, he forwards the packet on to his best neighbor, paying them the fee they charge to get a packet to that destination. Since Bob has set his fee to slightly higher that what his neighbor is charging to get to that destination, he will make a profit. This process continues until the packet reaches its destination.</p>\n\n<p><img alt=\"\" src=\"/images/payment-flow.png\"/></p>\n\n<p>In this way, Alice can send packets to any packet in the network, while transmitters along the way are compensated.</p>\n\n<h2>[3] Vulnerabilities</h2>\n\n<p>As you may have noticed, this system is vulnerable. Babel makes no provision for hostile nodes. Under this protocol, any node can advertise a cost of 0 to every destination on the network, and have all traffic from its neighbors routed through it, and receive payment (while dropping the packets, or offering worse than advertised performance and reliability). There are also other, more subtle exploits.</p>\n\n<p>There is some work on securing Babel and other distance vector routing protocols. However, this work tends to focus on the vulnerabilities that could occur in a network without monetary incentives. There are mitigations for DOS, impersonation of other nodes, and blackhole attacks. For now, we will consider these attacks to be outside of the scope of Althea. Satisfactory solutions need to be found, but this research is specific to Babel. </p>\n\n<p>Many of these mitigations assume a threat model where an adversary is attempting to disrupt or censor a network. We are more concerned about the treat model of many unscrupulous adversaries who are simply trying to defraud the network to get some incrementally higher total payment than they would otherwise.</p>\n\n<p>Let&#39;s say that Alice and Bob are neighbors. Bob learns that he can reach Doris with a quality of 4. However, he tells Alice that he can reach Doris with a quality of 3. Alice routes her packets to Doris through Bob and pays him, although Bob is not the best route. This type of &quot;false advertisement&quot; attack is specific to Althea, because the adversary&#39;s motivation is monetary.</p>\n\n<h4>[3.1] Cost metric validation</h4>\n\n<p>For Alice to catch Bob attempting a false advertisement attack, she must be able to check that the quality metric that Bob is reporting for a destination is truthful. Distance vector functions by summing the quality metric that nodes report about their neighbors.</p>\n\n<p><img alt=\"\" src=\"/images/honest-metric.png\"/>\nThe distance vector cost to D seen by A is the summation of the link costs of all the links along the best route. Depending on the link quality metric used, it should be possible for this summation to be roughly equal to the overall link cost computed by A between it and D.</p>\n\n<p>This overall link cost can be computed in the same way that the individual link quality costs are computed, by analyzing percentage of successfully acknowledged transmissions over a given time period.</p>\n\n<p><img alt=\"\" src=\"/images/dishonest-metric.png\"/>\nIf someone on the route is advertising a lower (better) quality metric than they are actually able to provide, the distance vector cost seen by A will differ from the overall link cost.</p>\n\n<p>Once A knows that B is giving it bad information, A can complain to B, or take steps to cut the connection. If B is honest, B will want to do the same kind of check on the neighbor that gave it the bad route. This chain of verification will be repeated until it reaches the node that is the source of the inaccurate quality metric. If this node does not correct the issue, its neighbor may cut it off.</p>\n\n<p>From these primitives, it should be possible to build an anti-cheating protocol. The simplest implementation would be to compute an honesty score for each neighbor, and let a human operator choose to disconnect from a neighbor with an especially bad score.</p>","comment_id":null,"plaintext":"**Note:** I've significantly changed my strategy since this was written, and you should read the [development update](/blog/development-update/).\n\nAlthea is a set of protocols for a decentralized point-to-point radio network providing connectivity to an area, where participants in the network are able to pay for connectivity, and receive payment for their contributions to the network, without a centralized ISP collecting subscriptions and owning equipment. It combines the commercial viability of a wireless ISP with the decentralized nature of a community mesh network. There are two main components- payments and routing.\n\n## [0] Overview\nAlthea is meant to operate on the last mile, i.e. from an uplink (or transit provider) to the end user, and creates something like a \"distributed ISP\". The last mile is an inefficient market- many areas only have one ISP. The reason for this is that there is a very high barrier to entry. Currently, if you want to compete with your local ISP, you first get a subscription to an uplink, which will sell you a lot of bandwidth \"in bulk\". You then have to build out a local network which is large enough to service enough end users to pay for the operation of your ISP business. You have to hire a staff to administer the network along with businesspeople and lawyers to run the business, and its billing and contractual infrastructure.\n\nYou then have to go out and find those end users and convince them to sign up to your service, usually as a monthly subscription. This marketing and advertising can be very expensive, and you will probably want to hire someone to administer the effort, along with marketing and advertising consultants to execute the campaign. This heavily favors firms that are able to make large investments, have name recognition, or have existing subscribers for a related service (like cable television or telephone services).\n\nOnce the ISP is self-sustaining, it's time to take profit. End users are unlikely to switch providers, as the barriers to entry discussed above make it difficult for competitors to gain a foothold. Additionally, many end users have been locked into contracts with a provider, and will almost certainly not switch. As the ISP is in pure profit-taking mode, service and maintenance are considered cost centers to be eliminated. This results in much of the dissatisfaction felt by many end users towards their ISP.\n\nAlthea is an attempt to create a much more fluid and competitive model, by removing the distinction between end user, ISP, and uplink. The goal is for any person to be able to set up an intermediary node that can route traffic for others, and receive payment for the service. Switching costs within the system are completely eliminated, as nodes switch between neighbors automatically according to a routing protocol which finds a route with the best combination of reliability, bandwidth, and low cost.\n\nAdvertising and marketing costs for the new entrant are eliminated, as the only advertisements in this system are the automatic advertisements of price and route quality between nodes. Contract and billing costs are eliminated by payment channels. Payment channels are a technology from the blockchain world, which allow one to make micropayments with very low overhead. In a payment channel, each payment is a message under a few hundred bytes, sent directly between the sender and the receiver, with no contact of a third party bank or payment processor, and no need to wait for payments to clear. The use of a public blockchain (i.e. Bitcoin or Ethereum), means that participants are able to send and receive these payments without having to pay fees to a payment processor or procuring expensive money transmitter licenses.\n\nOur goal is to eliminate the costs associated with providing paid internet access by moving most of the functions of an ISP business into the underlying protocol. Our thesis is that this will result in a market with a much higher degree of competitiveness and efficiency. This will translate into lower prices to the end user for better access to the internet. Another benefit is that of a more equitable marketplace, where money paid for internet access goes directly to members of a local community instead of being captured by multinational corporations. This could play a small part in stimulating local economies and distributing wealth more fairly in the world.  \n\n## [1] Routing\nNodes route packets using an ad-hoc “mesh” routing protocol. This protocol must take price as well as link quality into account. We define several extensions to Babel, a popular and performant ad-hoc routing protocol.\n\nHere’s an excerpt to give you an idea of how Babel works:\n\n>2.1. Costs, Metrics, and Neighbourship\n>\n>As many routing algorithms, Babel computes costs of links between any two neighbouring nodes, abstract values attached to the edges between two nodes. We write C(A, B) for the cost of the edge from node A to node B.\n>\n>Given a route between any two nodes, the metric of the route is the sum of the costs of all the edges along the route.  The goal of the  routing algorithm is to compute, for every source S, the tree of the routes of lowest metric to S.\n>\n>Costs and metrics need not be integers.  In general, they can be values in any algebra that satisfies two fairly general conditions (Section 3.5.2).\n>\n>A Babel node periodically broadcasts Hello messages to all of its neighbours; it also periodically sends an IHU (\"I Heard You\") message to every neighbour from which it has recently heard a Hello.  From the information derived from Hello and IHU messages received from its neighbour B, a node A computes the cost C(A, B) of the link from A to B.\n\nBabel provides a mechanism for extensibility, which is the basis for the modifications defined in this paper.\n\n### [1.2] Babel extension: Price-aware routing\n\nBabel is a good fit for routing based on payments because of its method of operation, known as \"distance vector\". \n\n![](/images/pir1.png)\n\nDistance vector routing works by assigning a quality metric to the links between nodes, where higher is worse. Nodes then gossip information about which nodes they can reach at which quality. From this information, each node is able to build up a routing table containing the all destinations in the network, along with their composite quality metric, and the neighbor to forward packets for a destination.\n\n![](/images/pir2.png)\n\nThis extension allows a Babel router to attach information about monetary price to the routes that it maintains. The router also propagates this information to its neighbors, who use it to determine their own prices. The price is taken into account for metric computation and route selection. It is also used by a payment protocol external to Babel (defined below in “Payments”) to pay neighbors to forward data.\n\n#### [1.2.1] Changes to data structures\n\nA router implementing price-aware routing has one additional field in each route table entry:\n\n- A price field, denoting how much the router charges to forward packets along this route. \n\n#### [1.2.3] Receiving updates\n\nWhen a node receives an Update TLV, it creates or updates a routing table entry according to Babel, section 3.5.4.  A node that performs price-aware routing extends that procedure by setting the routing table entry price field to `p'`, where: \n\n    p'=p+l\n\nLet `p` be the price attached to the received Update TLV. Let `l` be the price per kilobyte charged by the Babel router to forward packets along the update’s route. Determination of `l` is implementation-dependent, but for a simple implementation, a single `l` can be used for all routes.\n\n#### [1.2.4] Route selection\n\nRoute selection is discussed in Babel, section 3.6. The exact procedure is left as an implementation detail but a simple example is:\n\n>routes with a small metric should be preferred over routes with a   large metric;\n\nSimilarly, in price-aware routing, routes with a low price should be preferred over routes with a high price. These two criteria both need to factor into the selection. For example, a combined metric m` could be defined as:\n\n    m'=m+(p*n)\n\nwhere `m` is the metric, `p` is the price, and `n` is a constant multiplier.\n\nAside: It was hard to choose whether to make this a route selection procedure, extending section 3.6, or a metric computation, extending section 3.5.2. We chose to make it a route selection procedure, as metrics computed by section 3.5.2 are propagated to a node’s neighbors. Since the price is already propagated by this extension, it seems like a bad idea to propagate it again as a factor in the route metric. There is a possibility that this decision will need to be revisited.\n\n### [1.3] Gateway discovery\nWith the routing and payments described above, nodes can pay to have packets forwarded to destinations on the network. Other services can be built on top of this network. It's like the postal service. You attach an address and payment to a package and it gets delivered to its destination. If you order something that will be shipped to you, you have to pay for the item, plus the cot of sending it to you.\n\nOne very important service is providing a gateway to the internet. Nodes acting as gateways advertise a price and a quality metric for a connection to the internet. This information needs to be advertised to the rest of the network so that other nodes can choose which gateway to use. When a node has chosen a gateway, it pays for the service with a payment channel in the same way it pays its neighbors.\n\nIt's important to note that this involves the gateway paying to forward the response packets back to the end user. Like the mail-order example above, this means that an end user must send the gateway enough money to cover the price of the internet service, plus the price of sending the response packets back.\n\nWe haven't written the protocol around this yet. There are several other systems in development, so we may use one of them. In any case, the concept can be tested with the protocols in 1.1 and 1.2.\n\n## [2] Payments\nEach node on the network establishes payment channels with each of its neighbors. A payment channel is a method for two parties to exchange payments trustlessly by signing transactions that alter the balance of an escrow account held by a bank or blockchain (we may use the Ethereum blockchain for Althea).\n\nThe important thing about a payment channel is that after the channel has been opened, and funds have been placed in escrow, individual payments can be made directly between the two parties without submitting anything to the bank or blockchain. This means that the entire payment can be completed in one packet. Most payment systems need to send another transmission to a bank or blockchain, and wait for it to be confirmed. This would be too much overhead for use with Althea, which is why payment channels are used instead.\n\nWhen Alice wishes to send a packet to a destination (Charlie) on the network, she consults her routing table to find the best neighbor to forward it to. This routing table was built up by Babel, taking link quality and price (as computed in [section 1.2](/blog/althea-paper/#payments) above) into account, so the neighbor will be the one judged to have the best and cheapest route to the destination. Alice then appends a state update for her payment channel with Bob to the packet which pays him the rate that he is advertising for that destination. When Bob receives the packet and the payment, he forwards the packet on to his best neighbor, paying them the fee they charge to get a packet to that destination. Since Bob has set his fee to slightly higher that what his neighbor is charging to get to that destination, he will make a profit. This process continues until the packet reaches its destination.\n\n![](/images/payment-flow.png)\n\nIn this way, Alice can send packets to any packet in the network, while transmitters along the way are compensated.\n\n\n## [3] Vulnerabilities\nAs you may have noticed, this system is vulnerable. Babel makes no provision for hostile nodes. Under this protocol, any node can advertise a cost of 0 to every destination on the network, and have all traffic from its neighbors routed through it, and receive payment (while dropping the packets, or offering worse than advertised performance and reliability). There are also other, more subtle exploits.\n\nThere is some work on securing Babel and other distance vector routing protocols. However, this work tends to focus on the vulnerabilities that could occur in a network without monetary incentives. There are mitigations for DOS, impersonation of other nodes, and blackhole attacks. For now, we will consider these attacks to be outside of the scope of Althea. Satisfactory solutions need to be found, but this research is specific to Babel. \n\nMany of these mitigations assume a threat model where an adversary is attempting to disrupt or censor a network. We are more concerned about the treat model of many unscrupulous adversaries who are simply trying to defraud the network to get some incrementally higher total payment than they would otherwise.\n\nLet's say that Alice and Bob are neighbors. Bob learns that he can reach Doris with a quality of 4. However, he tells Alice that he can reach Doris with a quality of 3. Alice routes her packets to Doris through Bob and pays him, although Bob is not the best route. This type of \"false advertisement\" attack is specific to Althea, because the adversary's motivation is monetary.\n\n#### [3.1] Cost metric validation\nFor Alice to catch Bob attempting a false advertisement attack, she must be able to check that the quality metric that Bob is reporting for a destination is truthful. Distance vector functions by summing the quality metric that nodes report about their neighbors.\n\n![](/images/honest-metric.png)\nThe distance vector cost to D seen by A is the summation of the link costs of all the links along the best route. Depending on the link quality metric used, it should be possible for this summation to be roughly equal to the overall link cost computed by A between it and D.\n\nThis overall link cost can be computed in the same way that the individual link quality costs are computed, by analyzing percentage of successfully acknowledged transmissions over a given time period.\n\n![](/images/dishonest-metric.png)\nIf someone on the route is advertising a lower (better) quality metric than they are actually able to provide, the distance vector cost seen by A will differ from the overall link cost.\n\nOnce A knows that B is giving it bad information, A can complain to B, or take steps to cut the connection. If B is honest, B will want to do the same kind of check on the neighbor that gave it the bad route. This chain of verification will be repeated until it reaches the node that is the source of the inaccurate quality metric. If this node does not correct the issue, its neighbor may cut it off.\n\nFrom these primitives, it should be possible to build an anti-cheating protocol. The simplest implementation would be to compute an honesty score for each neighbor, and let a human operator choose to disconnect from a neighbor with an especially bad score.\n\n\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-06-03 00:00:00","created_by":"1","updated_at":"2016-06-03 00:00:00","updated_by":"1","published_at":"2016-06-03 00:00:00","published_by":"1","custom_excerpt":"I'm working on the white paper for the full Althea system. This post is subject to frequent changes.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75a","uuid":"3211ff3d-f304-4868-95ba-a674d8b27559","title":"State channel pong","slug":"state-channel-pong","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"This is a quick writeup of some ideas that were discussed by myself, Ameen Soleimani, and Zaki Manian.\"]]],[1,\"p\",[[0,[],0,\"Ameen is actively researching state channels and was looking for project ideas. I suggested pong, as it is a very fast paced game that really emphasizes the scalability and speed of state channels. Playing pong on a state channel is somehow much more impressive than tic tac toe or chess. Thinking about state channels in terms of pong also loosened up my thinking around channels in general. We talked with Zaki for about an hour to find a good way to do it.\"]]],[1,\"p\",[[0,[],0,\"Alice and Bob send frames back and forth, both signing each valid frame. For example:\"]]],[1,\"p\",[[0,[],0,\"` Alice -> Bob Frame:     Sequence: 88     Ball: 11,23     Alice's paddle: 15     Bob's paddle: 3\"]]],[1,\"p\",[[0,[],0,\"Bob -> Alice Frame:     Sequence: 89 // Bump the sequence number     Ball: 12,24 // The ball has moved according to pong \\\"physics\\\"     Alice's paddle: 15     Bob's paddle: 4 // Bob has moved his paddle \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"Alice will sign the frame that Bob has given her if it is valid, i.e. if the sequence number is correctly incremented and if the ball has obeyed the laws of pong physics. The frame also contains an update of Bob's paddle position.\"]]],[1,\"p\",[[0,[],0,\"They set up a contract on the blockchain that also understands the state transition from one frame to another. If given a frame signed by both Alice and Bob, the contract can of course establish that it is valid. The contract can also establish that a frame signed by only one of the participants is valid, given the frame before it signed by both. Also, as is the norm in state channels, frames with a higher sequence number override those with a lower sequence number. There is a challenge period of some length as well. After a frame is submitted, the contract waits for this amount of time before taking action on it (i.e. paying out some money to the winner).\"]]],[1,\"p\",[[0,[],0,\"In addition to frames, the contract accepts a notice of forfeit, signed by only one of the participants. For instance, Alice can claim \\\"Bob forfeited\\\". This can be overriden by a frame of any sequence number. If Bob does not post any valid frames during the challenge period, he forfeits the game.\"]]],[1,\"p\",[[0,[],0,\"Let's say that Bob sees that Alice is about to win, and he would like to end the game without forfeiting the money that he has locked up in the contract as a bet or whatever. I will prove that it is not possible for Bob to do this.\"]]],[1,\"p\",[[0,[],0,\"If Bob simply disconnects and stops signing frames, Alice can send a notice of forfeiture to the contract. If Bob doesn't send a valid frame before the hold period is up, Alice gets the money.\"]]],[1,\"p\",[[0,[],0,\"If Bob does send a valid frame, it's now up to Alice to send the next frame before the challenge period is over, otherwise she has forfeited. Alice and Bob could go back and forth like this until the end of the game, but this would be a very slow game, and very expensive because they would have to pay gas each time they submitted a frame.\"]]],[1,\"p\",[[0,[],0,\"If Alice sends a notice of forfeiture and then refuses to sign any more frames, Bob can submit a frame signed only by him, which is a valid transition from the frame signed by both him and Alice. Now it's up to Alice to send the next valid frame.\"]]],[1,\"p\",[[0,[],0,\"It's in both of their interests to play honestly and keep all frames except for the last one off the chain, but the slow and inefficient frame-by-frame process is always there as a fallback to keep the players honest.\"]]]]}","html":"<p>This is a quick writeup of some ideas that were discussed by myself, Ameen Soleimani, and Zaki Manian.</p>\n\n<p>Ameen is actively researching state channels and was looking for project ideas. I suggested pong, as it is a very fast paced game that really emphasizes the scalability and speed of state channels. Playing pong on a state channel is somehow much more impressive than tic tac toe or chess. Thinking about state channels in terms of pong also loosened up my thinking around channels in general. We talked with Zaki for about an hour to find a good way to do it.</p>\n\n<p>Alice and Bob send frames back and forth, both signing each valid frame. For example:</p>\n\n<p><code></code>`\nAlice -&gt; Bob\nFrame:\n    Sequence: 88\n    Ball: 11,23\n    Alice&#39;s paddle: 15\n    Bob&#39;s paddle: 3</p>\n\n<p>Bob -&gt; Alice\nFrame:\n    Sequence: 89 // Bump the sequence number\n    Ball: 12,24 // The ball has moved according to pong &quot;physics&quot;\n    Alice&#39;s paddle: 15\n    Bob&#39;s paddle: 4 // Bob has moved his paddle\n<code></code>`</p>\n\n<p>Alice will sign the frame that Bob has given her if it is valid, i.e. if the sequence number is correctly incremented and if the ball has obeyed the laws of pong physics. The frame also contains an update of Bob&#39;s paddle position.</p>\n\n<p>They set up a contract on the blockchain that also understands the state transition from one frame to another. If given a frame signed by both Alice and Bob, the contract can of course establish that it is valid. The contract can also establish that a frame signed by only one of the participants is valid, given the frame before it signed by both. Also, as is the norm in state channels, frames with a higher sequence number override those with a lower sequence number. There is a challenge period of some length as well. After a frame is submitted, the contract waits for this amount of time before taking action on it (i.e. paying out some money to the winner).</p>\n\n<p>In addition to frames, the contract accepts a notice of forfeit, signed by only one of the participants. For instance, Alice can claim &quot;Bob forfeited&quot;. This can be overriden by a frame of any sequence number. If Bob does not post any valid frames during the challenge period, he forfeits the game.</p>\n\n<p>Let&#39;s say that Bob sees that Alice is about to win, and he would like to end the game without forfeiting the money that he has locked up in the contract as a bet or whatever. I will prove that it is not possible for Bob to do this.</p>\n\n<p>If Bob simply disconnects and stops signing frames, Alice can send a notice of forfeiture to the contract. If Bob doesn&#39;t send a valid frame before the hold period is up, Alice gets the money.</p>\n\n<p>If Bob does send a valid frame, it&#39;s now up to Alice to send the next frame before the challenge period is over, otherwise she has forfeited. Alice and Bob could go back and forth like this until the end of the game, but this would be a very slow game, and very expensive because they would have to pay gas each time they submitted a frame.</p>\n\n<p>If Alice sends a notice of forfeiture and then refuses to sign any more frames, Bob can submit a frame signed only by him, which is a valid transition from the frame signed by both him and Alice. Now it&#39;s up to Alice to send the next valid frame.</p>\n\n<p>It&#39;s in both of their interests to play honestly and keep all frames except for the last one off the chain, but the slow and inefficient frame-by-frame process is always there as a fallback to keep the players honest.</p>","comment_id":null,"plaintext":"This is a quick writeup of some ideas that were discussed by myself, Ameen Soleimani, and Zaki Manian.\n\nAmeen is actively researching state channels and was looking for project ideas. I suggested pong, as it is a very fast paced game that really emphasizes the scalability and speed of state channels. Playing pong on a state channel is somehow much more impressive than tic tac toe or chess. Thinking about state channels in terms of pong also loosened up my thinking around channels in general. We talked with Zaki for about an hour to find a good way to do it.\n\nAlice and Bob send frames back and forth, both signing each valid frame. For example:\n\n```\nAlice -> Bob\nFrame:\n    Sequence: 88\n    Ball: 11,23\n    Alice's paddle: 15\n    Bob's paddle: 3\n\nBob -> Alice\nFrame:\n    Sequence: 89 // Bump the sequence number\n    Ball: 12,24 // The ball has moved according to pong \"physics\"\n    Alice's paddle: 15\n    Bob's paddle: 4 // Bob has moved his paddle\n```\n\nAlice will sign the frame that Bob has given her if it is valid, i.e. if the sequence number is correctly incremented and if the ball has obeyed the laws of pong physics. The frame also contains an update of Bob's paddle position.\n\nThey set up a contract on the blockchain that also understands the state transition from one frame to another. If given a frame signed by both Alice and Bob, the contract can of course establish that it is valid. The contract can also establish that a frame signed by only one of the participants is valid, given the frame before it signed by both. Also, as is the norm in state channels, frames with a higher sequence number override those with a lower sequence number. There is a challenge period of some length as well. After a frame is submitted, the contract waits for this amount of time before taking action on it (i.e. paying out some money to the winner).\n\nIn addition to frames, the contract accepts a notice of forfeit, signed by only one of the participants. For instance, Alice can claim \"Bob forfeited\". This can be overriden by a frame of any sequence number. If Bob does not post any valid frames during the challenge period, he forfeits the game.\n\nLet's say that Bob sees that Alice is about to win, and he would like to end the game without forfeiting the money that he has locked up in the contract as a bet or whatever. I will prove that it is not possible for Bob to do this.\n\nIf Bob simply disconnects and stops signing frames, Alice can send a notice of forfeiture to the contract. If Bob doesn't send a valid frame before the hold period is up, Alice gets the money.\n\nIf Bob does send a valid frame, it's now up to Alice to send the next frame before the challenge period is over, otherwise she has forfeited. Alice and Bob could go back and forth like this until the end of the game, but this would be a very slow game, and very expensive because they would have to pay gas each time they submitted a frame.\n\nIf Alice sends a notice of forfeiture and then refuses to sign any more frames, Bob can submit a frame signed only by him, which is a valid transition from the frame signed by both him and Alice. Now it's up to Alice to send the next valid frame.\n\nIt's in both of their interests to play honestly and keep all frames except for the last one off the chain, but the slow and inefficient frame-by-frame process is always there as a fallback to keep the players honest.","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-07-27 00:00:00","created_by":"1","updated_at":"2016-07-27 00:00:00","updated_by":"1","published_at":"2016-07-27 00:00:00","published_by":"1","custom_excerpt":"How can a blockchain enforce honest behavior during a game of pong?","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75b","uuid":"279dcd23-57ae-4169-8330-586f2f392ad5","title":"Using C.O.R.E. to work on mesh network routing protocols","slug":"using-core-for-network-simulation","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"image\",{\"src\":\"/images/hello_boeing.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/wlan_setup.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/pinging.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/hello_emane.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/running_babel.png\",\"alt\":\"\",\"title\":\"\"}],[\"code\",{\"code\":\"''' Babel service\\n'''\\n\\nimport os\\n\\nfrom core.service import CoreService, addservice\\nfrom core.misc.ipaddr import IPv4Prefix, IPv6Prefix\\n\\nclass BabelMod(CoreService):\\n    ''' This is for babel\\n    '''\\n    # a unique name is required, without spaces\\n    _name = \\\"BabelMod\\\"\\n    # you can create your own group here\\n    _group = \\\"Routing\\\"\\n    # this controls the starting order vs other enabled services\\n    _startindex = 50\\n    # list of startup commands, also may be generated during startup\\n    _startup = ('sh /home/core/myservices/babel.sh',)\\n    # list of shutdown commands\\n    _shutdown = ('rm log')\\n\\n# this line is required to add the above class to the list of available services\\naddservice(BabelMod)\"}],[\"code\",{\"code\":\"#!/bin/sh\\n\\ntouch log\\n/home/core/babeld/babeld eth0 -d 1 > log\"}],[\"image\",{\"src\":\"/images/new_node_type.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/default_services.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/babel_running.png\",\"alt\":\"\",\"title\":\"\"}],[\"image\",{\"src\":\"/images/babel_routing.png\",\"alt\":\"\",\"title\":\"\"}]],\"markups\":[[\"code\"],[\"a\",[\"href\",\"https://github.com/axn/mlc\"]],[\"a\",[\"href\",\"http://www.nrl.navy.mil/itd/ncs/products/emane\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"C.O.R.E. may sound like the name of a 1980's superhero team, but it is actually a tool that simulates wired and wifi networks, right down to the radio waves. For this reason I am trying to use it to test my modifications to Babel, an ad-hoc \\\"mesh\\\" routing protocol.\"]]],[1,\"p\",[[0,[],0,\"First, let's look at the alternatives that I evaluated before settling on CORE.\"]]],[1,\"h4\",[[0,[],0,\"Simple container network\"]]],[1,\"p\",[[0,[],0,\"The first thing I tried was just using some containers in a network, and then using the Linux tools \"],[0,[0],1,\"iptables\"],[0,[],0,\" and/or \"],[0,[0],1,\"tc\"],[0,[],0,\" to selectively drop and delay packets between pairs of nodes to simulate a lossy radio network. This would obviously not uncover complex real-world network dynamics, but no simulation will do this perfectly.\"]]],[1,\"p\",[[0,[],0,\"The advantage of this approach could be simplicity (maybe). It's also a good way to improve my chops with the Linux network utilities.\"]]],[1,\"p\",[[0,[],0,\"One example of this is \"],[0,[1],1,\"mlc\"],[0,[],0,\", written by Axel Neuman, the creator of the BMX6 routing protocol. Unfortunately, this package requires a lot of manual setup, and hasn't been updated in a few years. It's still something I will get familiar with, but I may evaluate some other more polished tools first. This technique starts to lose its simplicity the further you try to take it.\"]]],[1,\"h4\",[[0,[],0,\"Mininet\"]]],[1,\"p\",[[0,[],0,\"Mininet is a more polished tool that sees a lot of use in the software defined networking (SDN) community. It can create networks of virtual computers connected to SDN-controlled OpenFlow switches.\"]]],[1,\"p\",[[0,[],0,\"Mininet looks nice, because it is relatively lightweight, with all functionality programmable through a REPL or a nice Python API. The API is pretty well documented and there are many examples.\"]]],[1,\"p\",[[0,[],0,\"I'm intending to revisit Mininet, but to use it effectively I think that I would need to get pretty familiar with OpenFlow and the concepts of SDN, and then use it to simulate a mesh network. No doubt that these are interesting and valuable skills, but maybe it would be better to spend time learning something actually targeted at the wireless mesh use-case.\"]]],[1,\"h5\",[[0,[],0,\"Mininet-wifi\"]]],[1,\"p\",[[0,[],0,\"Mininet wifi adds WLAN simulation capability to mininet, with what looks like some pretty slick packet loss simulation stuff. However, it appears to be geared towards simulation of access points in a centrally-configured SDN network, not use in an ad-hoc mesh network.\"]]],[1,\"h4\",[[0,[],0,\"CORE\"]]],[1,\"p\",[[0,[],0,\"CORE intimidated me with complexity at first, in addition it is not as well documented as Mininet. However, after getting it started (with the help of a very convenient VM), I found that it seems to be a capable toolkit. You get a window where you can drop nodes and link them together to form connections. Or, you can create a WLAN network and allow it to calculate connectivity based on the node's positions on the screen. CORE also integrates EMANE, which is a much more full-featured wifi simulation suite. Finally, CORE can also import mobility scripts, which allow you to automate the movement of nodes on the canvas to see how well routing protocols do with mobility.\"]]],[1,\"h4\",[[0,[],0,\"IMUNES\"]]],[1,\"p\",[[0,[],0,\"CORE is built on top of IMUNES, which is another network simulator with a visual interface. It looks good, and is under more active development, but CORE seems simpler to get going for a mesh simulation.\"]]],[1,\"h3\",[[0,[],0,\"Using CORE\"]]],[1,\"p\",[[0,[],0,\"CORE has a pre-built VM image available to make it easy to get going. I installed VirtualBox to run the image, and started it up. \"]]],[10,0],[1,\"p\",[[0,[],0,\"Clicking on the icon, you're greeted with a blank canvas with some toolbars to the side. Click on the toolbar button with the router symbol (network-layer virtual nodes), select the \\\"MDR\\\" type, and place a few of them on the canvas. Then click on the button below it (link-layer nodes) and place a WLAN node, which looks like a little cloud. Right clicking the WLAN node brings up a menu that has the option \\\"Link to all routers\\\". Clicking this links all nodes to the WLAN network and gives them IP addresses.\"]]],[10,1],[1,\"p\",[[0,[],0,\"Clicking the play button starts the simulation. If the nodes are close enough together, green lines will form, representing the connections between them. If you double click on one of the nodes, it opens up a terminal. From here, you can try to ping other nodes. To get a quick overview of connection health, I like to use the command \"],[0,[0],1,\"ping -f <ip address>\"],[0,[],0,\". The \"],[0,[0],1,\"-f\"],[0,[],0,\" flag formats the output in a special way. Each time it sends a ping, it prints a dot. Each time it receives a response, it prints a backspace, deleting the prior dot. This effectively means that dots correspond to timed-out pings. If the line of dots grows rapidly, a lot of packets are being dropped. If it grows slowly or not at all, most packets are arriving at their destination.\"]]],[10,2],[1,\"p\",[[0,[],0,\"You can move nodes around while the ping command is running. If you move two nodes far enough away from each other that the green line between them disappears, all packets will suddenly start being dropped. If the green line is there, all packets are received. This is obviously not a very sophisticated simulation. This will not work for testing routing protocols, which must be able to find the best route among links of varying reliability.\"]]],[10,3],[1,\"p\",[[0,[],0,\"Luckily the CORE emulator includes \"],[0,[2],1,\"EMANE\"],[0,[],0,\", which simulates the lower-level networking stack (tcp, wifi, and below), and the physical layer (radio waves). With EMANE, moving nodes further away from each other increases the drop rate and the latency. I didn't necessarily need the level of physical accuracy that it provides, but hey, it's pretty cool. Right click on the WLAN node, and select one of the EMANE models.\"]]],[10,4],[1,\"p\",[[0,[],0,\"Ok, let's run Babel on our nodes. Clone the Babel repo, and make and install it etc. Now double click on one of the router nodes to bring up the terminal. You should be able to type something like \"],[0,[0],1,\"/home/core/babeld/babeld eth0 -d 1\"],[0,[],0,\" to start babel. The \"],[0,[0],1,\"-d 1\"],[0,[],0,\" flag puts it into debug mode so that it prints logs to the terminal, and we can verify that it is running. \"]]],[1,\"p\",[[0,[],0,\"Next, we need to set up a custom service to make Babel start automatically on new nodes. Go to \"],[0,[0],1,\"~/.core/myservices\"],[0,[],0,\" and read README.txt. I'm not going to duplicate what it says there, but my Babel service looks like this:\"]]],[1,\"p\",[[0,[],0,\"babel.py\"]]],[10,5],[1,\"p\",[[0,[],0,\"babel.sh\"]]],[10,6],[1,\"p\",[[0,[],0,\"Restart CORE to install the new service.\"]]],[10,7],[1,\"p\",[[0,[],0,\"Let's make a new node type which will only route using your new Babel service. First, click on the network-layer nodes button and select \\\"edit node types\\\". In this window, there's an \\\"add new node type\\\" button under the list of existing node types. I called mine \\\"babel\\\", and gave it a purple icon. Click on the \\\"Services\\\" button and make sure that only the \\\"IPForward\\\", and the new \\\"BabelMod\\\" services are selected.\"]]],[10,8],[1,\"p\",[[0,[],0,\"Now you should be able to place nodes on the canvas, and have their babel instances start talking to each other. Since we piped the output of Babel to the \"],[0,[0],1,\"log\"],[0,[],0,\" file, we can get some insight into its operation. Double click on a node to open its terminal and type \"],[0,[0],1,\"tail -f log\"],[0,[],0,\" to see what Babel is logging.\"]]],[10,9],[1,\"p\",[[0,[],0,\"Now that we have Babel running, we can try to see if we can get it to do some routing. Place 4 babel nodes on the canvas, 2 far apart from each other and 2 in the middle. Make one of the middle nodes a much better route than the other (closer to the 2 end nodes). Wait a few seconds, and you will see that the end nodes have routes to each other going through the better-placed middle node (you can check with Widgets->Observer Widgets->IPv4 Routes). You can also ping from one end node to the other to monitor packet loss.\"]]],[10,10],[1,\"p\",[[0,[],0,\"Now switch the positions of the middle nodes. You will see the packet loss jump, as the end nodes attempt to route packets through the middle node which is now in a bad position. After around 30 seconds, you will see throughput improve again as the new route is learned. If you check the routing tables of the end nodes, you will see that they contain the new and better route.\"]]]]}","html":"<p>C.O.R.E. may sound like the name of a 1980&#39;s superhero team, but it is actually a tool that simulates wired and wifi networks, right down to the radio waves. For this reason I am trying to use it to test my modifications to Babel, an ad-hoc &quot;mesh&quot; routing protocol.</p>\n\n<p>First, let&#39;s look at the alternatives that I evaluated before settling on CORE.</p>\n\n<h4>Simple container network</h4>\n\n<p>The first thing I tried was just using some containers in a network, and then using the Linux tools <code>iptables</code> and/or <code>tc</code> to selectively drop and delay packets between pairs of nodes to simulate a lossy radio network. This would obviously not uncover complex real-world network dynamics, but no simulation will do this perfectly.</p>\n\n<p>The advantage of this approach could be simplicity (maybe). It&#39;s also a good way to improve my chops with the Linux network utilities.</p>\n\n<p>One example of this is <a href=\"https://github.com/axn/mlc\">mlc</a>, written by Axel Neuman, the creator of the BMX6 routing protocol. Unfortunately, this package requires a lot of manual setup, and hasn&#39;t been updated in a few years. It&#39;s still something I will get familiar with, but I may evaluate some other more polished tools first. This technique starts to lose its simplicity the further you try to take it.</p>\n\n<h4>Mininet</h4>\n\n<p>Mininet is a more polished tool that sees a lot of use in the software defined networking (SDN) community. It can create networks of virtual computers connected to SDN-controlled OpenFlow switches.</p>\n\n<p>Mininet looks nice, because it is relatively lightweight, with all functionality programmable through a REPL or a nice Python API. The API is pretty well documented and there are many examples.</p>\n\n<p>I&#39;m intending to revisit Mininet, but to use it effectively I think that I would need to get pretty familiar with OpenFlow and the concepts of SDN, and then use it to simulate a mesh network. No doubt that these are interesting and valuable skills, but maybe it would be better to spend time learning something actually targeted at the wireless mesh use-case.</p>\n\n<h5>Mininet-wifi</h5>\n\n<p>Mininet wifi adds WLAN simulation capability to mininet, with what looks like some pretty slick packet loss simulation stuff. However, it appears to be geared towards simulation of access points in a centrally-configured SDN network, not use in an ad-hoc mesh network.</p>\n\n<h4>CORE</h4>\n\n<p>CORE intimidated me with complexity at first, in addition it is not as well documented as Mininet. However, after getting it started (with the help of a very convenient VM), I found that it seems to be a capable toolkit. You get a window where you can drop nodes and link them together to form connections. Or, you can create a WLAN network and allow it to calculate connectivity based on the node&#39;s positions on the screen. CORE also integrates EMANE, which is a much more full-featured wifi simulation suite. Finally, CORE can also import mobility scripts, which allow you to automate the movement of nodes on the canvas to see how well routing protocols do with mobility.</p>\n\n<h4>IMUNES</h4>\n\n<p>CORE is built on top of IMUNES, which is another network simulator with a visual interface. It looks good, and is under more active development, but CORE seems simpler to get going for a mesh simulation.</p>\n\n<h3>Using CORE</h3>\n\n<p>CORE has a pre-built VM image available to make it easy to get going. I installed VirtualBox to run the image, and started it up. </p>\n\n<p><img alt=\"\" src=\"/images/hello_boeing.png\"/></p>\n\n<p>Clicking on the icon, you&#39;re greeted with a blank canvas with some toolbars to the side. Click on the toolbar button with the router symbol (network-layer virtual nodes), select the &quot;MDR&quot; type, and place a few of them on the canvas. Then click on the button below it (link-layer nodes) and place a WLAN node, which looks like a little cloud. Right clicking the WLAN node brings up a menu that has the option &quot;Link to all routers&quot;. Clicking this links all nodes to the WLAN network and gives them IP addresses.</p>\n\n<p><img alt=\"\" src=\"/images/wlan_setup.png\"/></p>\n\n<p>Clicking the play button starts the simulation. If the nodes are close enough together, green lines will form, representing the connections between them. If you double click on one of the nodes, it opens up a terminal. From here, you can try to ping other nodes. To get a quick overview of connection health, I like to use the command <code>ping -f &lt;ip address&gt;</code>. The <code>-f</code> flag formats the output in a special way. Each time it sends a ping, it prints a dot. Each time it receives a response, it prints a backspace, deleting the prior dot. This effectively means that dots correspond to timed-out pings. If the line of dots grows rapidly, a lot of packets are being dropped. If it grows slowly or not at all, most packets are arriving at their destination.</p>\n\n<p><img alt=\"\" src=\"/images/pinging.png\"/></p>\n\n<p>You can move nodes around while the ping command is running. If you move two nodes far enough away from each other that the green line between them disappears, all packets will suddenly start being dropped. If the green line is there, all packets are received. This is obviously not a very sophisticated simulation. This will not work for testing routing protocols, which must be able to find the best route among links of varying reliability.</p>\n\n<p><img alt=\"\" src=\"/images/hello_emane.png\"/></p>\n\n<p>Luckily the CORE emulator includes <a href=\"http://www.nrl.navy.mil/itd/ncs/products/emane\">EMANE</a>, which simulates the lower-level networking stack (tcp, wifi, and below), and the physical layer (radio waves). With EMANE, moving nodes further away from each other increases the drop rate and the latency. I didn&#39;t necessarily need the level of physical accuracy that it provides, but hey, it&#39;s pretty cool. Right click on the WLAN node, and select one of the EMANE models.</p>\n\n<p><img alt=\"\" src=\"/images/running_babel.png\"/></p>\n\n<p>Ok, let&#39;s run Babel on our nodes. Clone the Babel repo, and make and install it etc. Now double click on one of the router nodes to bring up the terminal. You should be able to type something like <code>/home/core/babeld/babeld eth0 -d 1</code> to start babel. The <code>-d 1</code> flag puts it into debug mode so that it prints logs to the terminal, and we can verify that it is running. </p>\n\n<p>Next, we need to set up a custom service to make Babel start automatically on new nodes. Go to <code>~/.core/myservices</code> and read README.txt. I&#39;m not going to duplicate what it says there, but my Babel service looks like this:</p>\n\n<p>babel.py</p>\n\n<pre><code>&#39;&#39;&#39; Babel service\n&#39;&#39;&#39;\n\nimport os\n\nfrom core.service import CoreService, addservice\nfrom core.misc.ipaddr import IPv4Prefix, IPv6Prefix\n\nclass BabelMod(CoreService):\n    &#39;&#39;&#39; This is for babel\n    &#39;&#39;&#39;\n    # a unique name is required, without spaces\n    _name = &quot;BabelMod&quot;\n    # you can create your own group here\n    _group = &quot;Routing&quot;\n    # this controls the starting order vs other enabled services\n    _startindex = 50\n    # list of startup commands, also may be generated during startup\n    _startup = (&#39;sh /home/core/myservices/babel.sh&#39;,)\n    # list of shutdown commands\n    _shutdown = (&#39;rm log&#39;)\n\n# this line is required to add the above class to the list of available services\naddservice(BabelMod)</code></pre>\n\n<p>babel.sh</p>\n\n<pre><code>#!/bin/sh\n\ntouch log\n/home/core/babeld/babeld eth0 -d 1 &gt; log</code></pre>\n\n<p>Restart CORE to install the new service.</p>\n\n<p><img alt=\"\" src=\"/images/new_node_type.png\"/></p>\n\n<p>Let&#39;s make a new node type which will only route using your new Babel service. First, click on the network-layer nodes button and select &quot;edit node types&quot;. In this window, there&#39;s an &quot;add new node type&quot; button under the list of existing node types. I called mine &quot;babel&quot;, and gave it a purple icon. Click on the &quot;Services&quot; button and make sure that only the &quot;IPForward&quot;, and the new &quot;BabelMod&quot; services are selected.</p>\n\n<p><img alt=\"\" src=\"/images/default_services.png\"/></p>\n\n<p>Now you should be able to place nodes on the canvas, and have their babel instances start talking to each other. Since we piped the output of Babel to the <code>log</code> file, we can get some insight into its operation. Double click on a node to open its terminal and type <code>tail -f log</code> to see what Babel is logging.</p>\n\n<p><img alt=\"\" src=\"/images/babel_running.png\"/></p>\n\n<p>Now that we have Babel running, we can try to see if we can get it to do some routing. Place 4 babel nodes on the canvas, 2 far apart from each other and 2 in the middle. Make one of the middle nodes a much better route than the other (closer to the 2 end nodes). Wait a few seconds, and you will see that the end nodes have routes to each other going through the better-placed middle node (you can check with Widgets-&gt;Observer Widgets-&gt;IPv4 Routes). You can also ping from one end node to the other to monitor packet loss.</p>\n\n<p><img alt=\"\" src=\"/images/babel_routing.png\"/></p>\n\n<p>Now switch the positions of the middle nodes. You will see the packet loss jump, as the end nodes attempt to route packets through the middle node which is now in a bad position. After around 30 seconds, you will see throughput improve again as the new route is learned. If you check the routing tables of the end nodes, you will see that they contain the new and better route.</p>","comment_id":null,"plaintext":"C.O.R.E. may sound like the name of a 1980's superhero team, but it is actually a tool that simulates wired and wifi networks, right down to the radio waves. For this reason I am trying to use it to test my modifications to Babel, an ad-hoc \"mesh\" routing protocol.\n\nFirst, let's look at the alternatives that I evaluated before settling on CORE.\n\n#### Simple container network\nThe first thing I tried was just using some containers in a network, and then using the Linux tools `iptables` and/or `tc` to selectively drop and delay packets between pairs of nodes to simulate a lossy radio network. This would obviously not uncover complex real-world network dynamics, but no simulation will do this perfectly.\n\nThe advantage of this approach could be simplicity (maybe). It's also a good way to improve my chops with the Linux network utilities.\n\nOne example of this is [mlc](https://github.com/axn/mlc), written by Axel Neuman, the creator of the BMX6 routing protocol. Unfortunately, this package requires a lot of manual setup, and hasn't been updated in a few years. It's still something I will get familiar with, but I may evaluate some other more polished tools first. This technique starts to lose its simplicity the further you try to take it.\n\n#### Mininet\nMininet is a more polished tool that sees a lot of use in the software defined networking (SDN) community. It can create networks of virtual computers connected to SDN-controlled OpenFlow switches.\n\nMininet looks nice, because it is relatively lightweight, with all functionality programmable through a REPL or a nice Python API. The API is pretty well documented and there are many examples.\n\nI'm intending to revisit Mininet, but to use it effectively I think that I would need to get pretty familiar with OpenFlow and the concepts of SDN, and then use it to simulate a mesh network. No doubt that these are interesting and valuable skills, but maybe it would be better to spend time learning something actually targeted at the wireless mesh use-case.\n\n##### Mininet-wifi\nMininet wifi adds WLAN simulation capability to mininet, with what looks like some pretty slick packet loss simulation stuff. However, it appears to be geared towards simulation of access points in a centrally-configured SDN network, not use in an ad-hoc mesh network.\n\n#### CORE\nCORE intimidated me with complexity at first, in addition it is not as well documented as Mininet. However, after getting it started (with the help of a very convenient VM), I found that it seems to be a capable toolkit. You get a window where you can drop nodes and link them together to form connections. Or, you can create a WLAN network and allow it to calculate connectivity based on the node's positions on the screen. CORE also integrates EMANE, which is a much more full-featured wifi simulation suite. Finally, CORE can also import mobility scripts, which allow you to automate the movement of nodes on the canvas to see how well routing protocols do with mobility.\n\n#### IMUNES\nCORE is built on top of IMUNES, which is another network simulator with a visual interface. It looks good, and is under more active development, but CORE seems simpler to get going for a mesh simulation.\n\n### Using CORE\nCORE has a pre-built VM image available to make it easy to get going. I installed VirtualBox to run the image, and started it up. \n\n![](/images/hello_boeing.png)\n\nClicking on the icon, you're greeted with a blank canvas with some toolbars to the side. Click on the toolbar button with the router symbol (network-layer virtual nodes), select the \"MDR\" type, and place a few of them on the canvas. Then click on the button below it (link-layer nodes) and place a WLAN node, which looks like a little cloud. Right clicking the WLAN node brings up a menu that has the option \"Link to all routers\". Clicking this links all nodes to the WLAN network and gives them IP addresses.\n\n![](/images/wlan_setup.png)\n\nClicking the play button starts the simulation. If the nodes are close enough together, green lines will form, representing the connections between them. If you double click on one of the nodes, it opens up a terminal. From here, you can try to ping other nodes. To get a quick overview of connection health, I like to use the command `ping -f <ip address>`. The `-f` flag formats the output in a special way. Each time it sends a ping, it prints a dot. Each time it receives a response, it prints a backspace, deleting the prior dot. This effectively means that dots correspond to timed-out pings. If the line of dots grows rapidly, a lot of packets are being dropped. If it grows slowly or not at all, most packets are arriving at their destination.\n\n![](/images/pinging.png)\n\nYou can move nodes around while the ping command is running. If you move two nodes far enough away from each other that the green line between them disappears, all packets will suddenly start being dropped. If the green line is there, all packets are received. This is obviously not a very sophisticated simulation. This will not work for testing routing protocols, which must be able to find the best route among links of varying reliability.\n\n![](/images/hello_emane.png)\n\nLuckily the CORE emulator includes [EMANE](http://www.nrl.navy.mil/itd/ncs/products/emane), which simulates the lower-level networking stack (tcp, wifi, and below), and the physical layer (radio waves). With EMANE, moving nodes further away from each other increases the drop rate and the latency. I didn't necessarily need the level of physical accuracy that it provides, but hey, it's pretty cool. Right click on the WLAN node, and select one of the EMANE models.\n\n![](/images/running_babel.png)\n\nOk, let's run Babel on our nodes. Clone the Babel repo, and make and install it etc. Now double click on one of the router nodes to bring up the terminal. You should be able to type something like `/home/core/babeld/babeld eth0 -d 1` to start babel. The `-d 1` flag puts it into debug mode so that it prints logs to the terminal, and we can verify that it is running. \n\nNext, we need to set up a custom service to make Babel start automatically on new nodes. Go to `~/.core/myservices` and read README.txt. I'm not going to duplicate what it says there, but my Babel service looks like this:\n\nbabel.py\n\n    ''' Babel service\n    '''\n\n    import os\n\n    from core.service import CoreService, addservice\n    from core.misc.ipaddr import IPv4Prefix, IPv6Prefix\n\n    class BabelMod(CoreService):\n        ''' This is for babel\n        '''\n        # a unique name is required, without spaces\n        _name = \"BabelMod\"\n        # you can create your own group here\n        _group = \"Routing\"\n        # this controls the starting order vs other enabled services\n        _startindex = 50\n        # list of startup commands, also may be generated during startup\n        _startup = ('sh /home/core/myservices/babel.sh',)\n        # list of shutdown commands\n        _shutdown = ('rm log')\n\n    # this line is required to add the above class to the list of available services\n    addservice(BabelMod)\n\n\nbabel.sh\n\n    #!/bin/sh\n\n    touch log\n    /home/core/babeld/babeld eth0 -d 1 > log\n\n\nRestart CORE to install the new service.\n\n![](/images/new_node_type.png)\n\nLet's make a new node type which will only route using your new Babel service. First, click on the network-layer nodes button and select \"edit node types\". In this window, there's an \"add new node type\" button under the list of existing node types. I called mine \"babel\", and gave it a purple icon. Click on the \"Services\" button and make sure that only the \"IPForward\", and the new \"BabelMod\" services are selected.\n\n![](/images/default_services.png)\n\nNow you should be able to place nodes on the canvas, and have their babel instances start talking to each other. Since we piped the output of Babel to the `log` file, we can get some insight into its operation. Double click on a node to open its terminal and type `tail -f log` to see what Babel is logging.\n\n![](/images/babel_running.png)\n\nNow that we have Babel running, we can try to see if we can get it to do some routing. Place 4 babel nodes on the canvas, 2 far apart from each other and 2 in the middle. Make one of the middle nodes a much better route than the other (closer to the 2 end nodes). Wait a few seconds, and you will see that the end nodes have routes to each other going through the better-placed middle node (you can check with Widgets->Observer Widgets->IPv4 Routes). You can also ping from one end node to the other to monitor packet loss.\n\n![](/images/babel_routing.png)\n\nNow switch the positions of the middle nodes. You will see the packet loss jump, as the end nodes attempt to route packets through the middle node which is now in a bad position. After around 30 seconds, you will see throughput improve again as the new route is learned. If you check the routing tables of the end nodes, you will see that they contain the new and better route.","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-08-01 00:00:00","created_by":"1","updated_at":"2016-08-01 00:00:00","updated_by":"1","published_at":"2016-08-01 00:00:00","published_by":"1","custom_excerpt":"C.O.R.E. may sound like the name of a 1980's superhero team, but it is actually a tool that simulates wired and wifi networks, right down to the radio waves. For this reason I am using it to test my modifications to Babel, an ad-hoc 'mesh' routing protocol.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75c","uuid":"d06d3893-4d14-489d-9a03-8fba4a616663","title":"The free option problem","slug":"the-free-option-problem","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://crypto.stackexchange.com/questions/35828/is-it-possible-for-alice-and-bob-to-both-sign-a-message-simultaneously\"]],[\"a\",[\"href\",\"http://altheamesh.com/blog/state-channel-pong/\"]],[\"a\",[\"href\",\"https://gnosis.pm/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"The free option problem is an apparently inescapable problem in state channels. However, it can be mitigated. I'll cover 3 possible mitigations in this blog post. It's a variant of the fair exchange problem, which is a known concept in the field of cryptography as a whole. Let's review the fair exchange problem: \"]]],[1,\"p\",[[0,[],0,\"Alice and Bob wish to exchange signatures. If Bob sends his first, Alice could simply refuse to send hers and walk away. If Alice sends first, the situation is reversed.\"]]],[1,\"p\",[[0,[],0,\"Here's a \"],[0,[0],1,\"good overview\"],[0,[],0,\" from a question I asked on a Q&A site.\"]]],[1,\"p\",[[0,[],0,\"This applies very directly to state channels. Let's review how a state channel works:\"]]],[1,\"p\",[[0,[],0,\"Alice and Bob agree on some state, give it an incrementing sequence number, and sign it. Either Alice or Bob can now prove that the other agreed to that state, and that it is the most recent state that they have agreed to. If either one tries to falsely claim that an older state is the most recent state, the other can show a signed state with a higher sequence number and disprove the claim.\"]]],[1,\"p\",[[0,[],0,\"Most current state channel implementations also include the concept of a challenge period. This is a period of time after which it is not possible to disprove an older update by submitting a newer one. This gives a distinct cutoff point after which actions can be taken on the state.\"]]],[1,\"p\",[[0,[],0,\"This mechanism has found use in payment channels, which allow Alice and Bob to keep a running tally of how much they owe each other, updating it to make payments with extremely low overhead. This tally is backed up by money escrowed by one or both of them on a blockchain or with a trusted third party. When either one wants to pull the money out, they submit the most recent state. After the challenge period ends, the money is released.\"]]],[1,\"p\",[[0,[],0,\"In theory it can also be used for a wide range of other interactions \"],[0,[1],1,\"including pong\"],[0,[],0,\".\"]]],[1,\"h2\",[[0,[],0,\"Example\"]]],[1,\"p\",[[0,[],0,\"The free option problem is just the fair exchange problem in the context of state channels. It's called the free option problem because it first presented itself in the use of state channels for trading assets against each other. Let's say a state channel is being used by Alice and Bob to trade silver against gold. The state records Alice's balance of silver and gold, and Bob's balance of silver and gold. This is backed up by bars of metal stored with an escrow service. When Alice wishes to trade some silver from some gold, she creates a new state with her balance of silver decreased and her balance of gold increased, and Bob's balances vice-versa. She increments the sequence number, signs it, and sends it to Bob.\"]]],[1,\"p\",[[0,[],0,\"If Bob refuses to send his signature back, he now has a free option. If he wants to, he can submit the state that Alice just sent him and receive more silver, or submit the previous state and receive more gold. He might choose differently based on how the market moves. Alice has given him a free option.\"]]],[1,\"p\",[[0,[],0,\"The free option problem also has another effect. Let's call it an \\\"unjust punishment\\\". Some state channel implementations have a mechanism where someone attempting to close a channel must submit a deposit along with their closing state. If a later state overrides it, the deposit is taken as punishment. This is meant to dissuade people from dishonestly submitting old states. In the example above, if Alice wants to close the channel, she must submit the latest state that she has. However, Bob has a later state with a higher sequence number. If Alice submits her latest state, Bob can submit his later state and take her deposit.\"]]],[1,\"h2\",[[0,[],0,\"Mitigations\"]]],[1,\"p\",[[0,[],0,\"There are at least 3 mitigations of the free option problem. They all basically consist of eliminating a single point in time where one party has a fully valid state and the other does not.\"]]],[1,\"h3\",[[0,[],0,\"Incremental transfer amount\"]]],[1,\"p\",[[0,[],0,\"This applies mostly to channels recording balances of assets. More broadly, it works for channels where a state update can be broken into many smaller updates to achieve an equivalent effect. For instance, a trade of 100 grams of silver for 10 grams of gold can be broken into 100 trades of 1 gram of silver for 0.1 gram of gold. In the example above, if Alice did this she would only ever be giving Bob a much smaller free option. However, this only really works for divisible numerical transfers, and it does nothing to protect against an unjust punishment.\"]]],[1,\"h3\",[[0,[],0,\"Incremental transfer validity time\"]]],[1,\"p\",[[0,[],0,\"A solution used by \"],[0,[2],1,\"Gnosis\"],[0,[],0,\" is to make state updates that expire after some time. Alice sends Bob an update transferring the full amount that expires very soon. When Bob has sent her a signature on that update, she sends an update that is valid for longer. This way, Alice and Bob are giving each other free options that are not useful for very long. This is especially well suited for exchanges, where the value of a free option is determined by how much the market has moved. It is also a partial solution to the unjust punishment problem discussed above. If Alice wants to close the channel, but Bob has a later update, she can just wait until Bob's update is no longer valid.\"]]],[1,\"h3\",[[0,[],0,\"Incremental transfer probability\"]]],[1,\"p\",[[0,[],0,\"This is an interesting solution that I came up with, which to my knowledge is not implemented anywhere. Alice and Bob each have a number of separate keypairs that they sign updates with (let's say 100 for now). Alice sends Bob an update that is signed by 1 of the keypairs. When Bob has responded with the signature from 1 of his keypairs, Alice sends a signature from her next keypair. This continues until the update has 100 signatures from each Alice and Bob. When one of them wants to close the channel, the blockchain or escrow service chooses a random number. This is used to derive the number of signatures required to consider the update valid. For instance, if the escrow chooses 0.34 as the random number, 34 signatures from Alice and Bob are required. Of course, if the process has been followed correctly and completed, the chance of validity is always 100%. \"]]],[1,\"p\",[[0,[],0,\"If one of them breaks the process off early, they will only have a 1% higher chance of having a valid state update. This obviously is not great if one party has a much more at stake or a much lower tolerance for risk than the other. I think this mechanism could also be used to mitigate the unjust punishment problem, if there is also a punishment for updates that fail validation for not having enough signatures.\"]]]]}","html":"<p>The free option problem is an apparently inescapable problem in state channels. However, it can be mitigated. I&#39;ll cover 3 possible mitigations in this blog post. It&#39;s a variant of the fair exchange problem, which is a known concept in the field of cryptography as a whole. Let&#39;s review the fair exchange problem: </p>\n\n<blockquote><p>Alice and Bob wish to exchange signatures. If Bob sends his first, Alice could simply refuse to send hers and walk away. If Alice sends first, the situation is reversed.</p></blockquote>\n\n<p>Here&#39;s a <a href=\"https://crypto.stackexchange.com/questions/35828/is-it-possible-for-alice-and-bob-to-both-sign-a-message-simultaneously\">good overview</a> from a question I asked on a Q&amp;A site.</p>\n\n<p>This applies very directly to state channels. Let&#39;s review how a state channel works:</p>\n\n<blockquote><p>Alice and Bob agree on some state, give it an incrementing sequence number, and sign it. Either Alice or Bob can now prove that the other agreed to that state, and that it is the most recent state that they have agreed to. If either one tries to falsely claim that an older state is the most recent state, the other can show a signed state with a higher sequence number and disprove the claim.</p></blockquote>\n\n<p>Most current state channel implementations also include the concept of a challenge period. This is a period of time after which it is not possible to disprove an older update by submitting a newer one. This gives a distinct cutoff point after which actions can be taken on the state.</p>\n\n<p>This mechanism has found use in payment channels, which allow Alice and Bob to keep a running tally of how much they owe each other, updating it to make payments with extremely low overhead. This tally is backed up by money escrowed by one or both of them on a blockchain or with a trusted third party. When either one wants to pull the money out, they submit the most recent state. After the challenge period ends, the money is released.</p>\n\n<p>In theory it can also be used for a wide range of other interactions <a href=\"http://altheamesh.com/blog/state-channel-pong/\">including pong</a>.</p>\n\n<h2>Example</h2>\n\n<p>The free option problem is just the fair exchange problem in the context of state channels. It&#39;s called the free option problem because it first presented itself in the use of state channels for trading assets against each other. Let&#39;s say a state channel is being used by Alice and Bob to trade silver against gold. The state records Alice&#39;s balance of silver and gold, and Bob&#39;s balance of silver and gold. This is backed up by bars of metal stored with an escrow service. When Alice wishes to trade some silver from some gold, she creates a new state with her balance of silver decreased and her balance of gold increased, and Bob&#39;s balances vice-versa. She increments the sequence number, signs it, and sends it to Bob.</p>\n\n<p>If Bob refuses to send his signature back, he now has a free option. If he wants to, he can submit the state that Alice just sent him and receive more silver, or submit the previous state and receive more gold. He might choose differently based on how the market moves. Alice has given him a free option.</p>\n\n<p>The free option problem also has another effect. Let&#39;s call it an &quot;unjust punishment&quot;. Some state channel implementations have a mechanism where someone attempting to close a channel must submit a deposit along with their closing state. If a later state overrides it, the deposit is taken as punishment. This is meant to dissuade people from dishonestly submitting old states. In the example above, if Alice wants to close the channel, she must submit the latest state that she has. However, Bob has a later state with a higher sequence number. If Alice submits her latest state, Bob can submit his later state and take her deposit.</p>\n\n<h2>Mitigations</h2>\n\n<p>There are at least 3 mitigations of the free option problem. They all basically consist of eliminating a single point in time where one party has a fully valid state and the other does not.</p>\n\n<h3>Incremental transfer amount</h3>\n\n<p>This applies mostly to channels recording balances of assets. More broadly, it works for channels where a state update can be broken into many smaller updates to achieve an equivalent effect. For instance, a trade of 100 grams of silver for 10 grams of gold can be broken into 100 trades of 1 gram of silver for 0.1 gram of gold. In the example above, if Alice did this she would only ever be giving Bob a much smaller free option. However, this only really works for divisible numerical transfers, and it does nothing to protect against an unjust punishment.</p>\n\n<h3>Incremental transfer validity time</h3>\n\n<p>A solution used by <a href=\"https://gnosis.pm/\">Gnosis</a> is to make state updates that expire after some time. Alice sends Bob an update transferring the full amount that expires very soon. When Bob has sent her a signature on that update, she sends an update that is valid for longer. This way, Alice and Bob are giving each other free options that are not useful for very long. This is especially well suited for exchanges, where the value of a free option is determined by how much the market has moved. It is also a partial solution to the unjust punishment problem discussed above. If Alice wants to close the channel, but Bob has a later update, she can just wait until Bob&#39;s update is no longer valid.</p>\n\n<h3>Incremental transfer probability</h3>\n\n<p>This is an interesting solution that I came up with, which to my knowledge is not implemented anywhere. Alice and Bob each have a number of separate keypairs that they sign updates with (let&#39;s say 100 for now). Alice sends Bob an update that is signed by 1 of the keypairs. When Bob has responded with the signature from 1 of his keypairs, Alice sends a signature from her next keypair. This continues until the update has 100 signatures from each Alice and Bob. When one of them wants to close the channel, the blockchain or escrow service chooses a random number. This is used to derive the number of signatures required to consider the update valid. For instance, if the escrow chooses 0.34 as the random number, 34 signatures from Alice and Bob are required. Of course, if the process has been followed correctly and completed, the chance of validity is always 100%. </p>\n\n<p>If one of them breaks the process off early, they will only have a 1% higher chance of having a valid state update. This obviously is not great if one party has a much more at stake or a much lower tolerance for risk than the other. I think this mechanism could also be used to mitigate the unjust punishment problem, if there is also a punishment for updates that fail validation for not having enough signatures.</p>","comment_id":null,"plaintext":"The free option problem is an apparently inescapable problem in state channels. However, it can be mitigated. I'll cover 3 possible mitigations in this blog post. It's a variant of the fair exchange problem, which is a known concept in the field of cryptography as a whole. Let's review the fair exchange problem: \n\n> Alice and Bob wish to exchange signatures. If Bob sends his first, Alice could simply refuse to send hers and walk away. If Alice sends first, the situation is reversed.\n\nHere's a [good overview](https://crypto.stackexchange.com/questions/35828/is-it-possible-for-alice-and-bob-to-both-sign-a-message-simultaneously) from a question I asked on a Q&A site.\n\nThis applies very directly to state channels. Let's review how a state channel works:\n\n> Alice and Bob agree on some state, give it an incrementing sequence number, and sign it. Either Alice or Bob can now prove that the other agreed to that state, and that it is the most recent state that they have agreed to. If either one tries to falsely claim that an older state is the most recent state, the other can show a signed state with a higher sequence number and disprove the claim.\n\nMost current state channel implementations also include the concept of a challenge period. This is a period of time after which it is not possible to disprove an older update by submitting a newer one. This gives a distinct cutoff point after which actions can be taken on the state.\n\nThis mechanism has found use in payment channels, which allow Alice and Bob to keep a running tally of how much they owe each other, updating it to make payments with extremely low overhead. This tally is backed up by money escrowed by one or both of them on a blockchain or with a trusted third party. When either one wants to pull the money out, they submit the most recent state. After the challenge period ends, the money is released.\n\nIn theory it can also be used for a wide range of other interactions [including pong](http://altheamesh.com/blog/state-channel-pong/).\n\n## Example\n\nThe free option problem is just the fair exchange problem in the context of state channels. It's called the free option problem because it first presented itself in the use of state channels for trading assets against each other. Let's say a state channel is being used by Alice and Bob to trade silver against gold. The state records Alice's balance of silver and gold, and Bob's balance of silver and gold. This is backed up by bars of metal stored with an escrow service. When Alice wishes to trade some silver from some gold, she creates a new state with her balance of silver decreased and her balance of gold increased, and Bob's balances vice-versa. She increments the sequence number, signs it, and sends it to Bob.\n\nIf Bob refuses to send his signature back, he now has a free option. If he wants to, he can submit the state that Alice just sent him and receive more silver, or submit the previous state and receive more gold. He might choose differently based on how the market moves. Alice has given him a free option.\n\nThe free option problem also has another effect. Let's call it an \"unjust punishment\". Some state channel implementations have a mechanism where someone attempting to close a channel must submit a deposit along with their closing state. If a later state overrides it, the deposit is taken as punishment. This is meant to dissuade people from dishonestly submitting old states. In the example above, if Alice wants to close the channel, she must submit the latest state that she has. However, Bob has a later state with a higher sequence number. If Alice submits her latest state, Bob can submit his later state and take her deposit.\n\n## Mitigations\n\nThere are at least 3 mitigations of the free option problem. They all basically consist of eliminating a single point in time where one party has a fully valid state and the other does not.\n\n### Incremental transfer amount\n\nThis applies mostly to channels recording balances of assets. More broadly, it works for channels where a state update can be broken into many smaller updates to achieve an equivalent effect. For instance, a trade of 100 grams of silver for 10 grams of gold can be broken into 100 trades of 1 gram of silver for 0.1 gram of gold. In the example above, if Alice did this she would only ever be giving Bob a much smaller free option. However, this only really works for divisible numerical transfers, and it does nothing to protect against an unjust punishment.\n\n### Incremental transfer validity time\n\nA solution used by [Gnosis](https://gnosis.pm/) is to make state updates that expire after some time. Alice sends Bob an update transferring the full amount that expires very soon. When Bob has sent her a signature on that update, she sends an update that is valid for longer. This way, Alice and Bob are giving each other free options that are not useful for very long. This is especially well suited for exchanges, where the value of a free option is determined by how much the market has moved. It is also a partial solution to the unjust punishment problem discussed above. If Alice wants to close the channel, but Bob has a later update, she can just wait until Bob's update is no longer valid.\n\n### Incremental transfer probability \n\nThis is an interesting solution that I came up with, which to my knowledge is not implemented anywhere. Alice and Bob each have a number of separate keypairs that they sign updates with (let's say 100 for now). Alice sends Bob an update that is signed by 1 of the keypairs. When Bob has responded with the signature from 1 of his keypairs, Alice sends a signature from her next keypair. This continues until the update has 100 signatures from each Alice and Bob. When one of them wants to close the channel, the blockchain or escrow service chooses a random number. This is used to derive the number of signatures required to consider the update valid. For instance, if the escrow chooses 0.34 as the random number, 34 signatures from Alice and Bob are required. Of course, if the process has been followed correctly and completed, the chance of validity is always 100%. \n\nIf one of them breaks the process off early, they will only have a 1% higher chance of having a valid state update. This obviously is not great if one party has a much more at stake or a much lower tolerance for risk than the other. I think this mechanism could also be used to mitigate the unjust punishment problem, if there is also a punishment for updates that fail validation for not having enough signatures.\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2016-08-21 00:00:00","created_by":"1","updated_at":"2016-08-21 00:00:00","updated_by":"1","published_at":"2016-08-21 00:00:00","published_by":"1","custom_excerpt":"The free option problem is an apparently inescapable problem in state channels. However, it can be mitigated. I'll cover 3 possible mitigations in this blog post. It's a variant of the fair exchange problem, which is a known concept in the field of cryptography as a whole.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75d","uuid":"1acfbe25-e83d-4c0d-8cd2-696053e2c2b4","title":"Battlemesh","slug":"battlemesh","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://www.youtube.com/watch?v=f21KCNw7EWw&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=4&ab_channel=AdjyLeak\"]],[\"a\",[\"href\",\"https://www.youtube.com/watch?v=uuSxoWcOEwA&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=8&ab_channel=AdjyLeak\"]],[\"a\",[\"href\",\"https://www.youtube.com/watch?v=NLP4MxQp8kk&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=6&ab_channel=AdjyLeak\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"Last week I went to Battlemesh in Vienna. Battlemesh is a conference and competition that is held in a different location in Europe about once a year. Its original purpose is to test all the routing protocols against each other, hence \\\"battle\\\". It's evolved into a great meeting of community network activists and enthusiasts from around Europe and around the world. In addition to the setup of the testbed, there are talks going on all week. I presented Althea there, you can see the video \"],[0,[0],1,\"here\"],[0,[],0,\". I was hoping for a lot of tough questions after the talk, but I got a lot of the questions later, in one on one conversations with participants. But more on that later. \"]]],[1,\"p\",[[0,[],0,\"There were some very interesting talks. \"],[0,[1],1,\"One particularly relevant talk\"],[0,[],0,\" was from Leonardo Macccari, who is part of a team doing some research into community networks for the eu. They've looked into a lot of different networks. what motivates the participants, and in particular, how networks that are supposed to be decentralized can become centralized by influential members owning a lot of the nodes, or dominating discussions.\"]]],[1,\"p\",[[0,[2],1,\"Another great talk\"],[0,[],0,\" was from Electra Wagenrad, who presented a diy solar charging system for mesh nodes. She estimated that a repeater with 2 directional antennas would require a 50 watt solar panel and a standard lead acid car battery. This could be a great way to set up nodes on hillsides etc with minimal support infrastructure.\"]]],[1,\"p\",[[0,[],0,\"I was also able to participate in the testbed setup. I wrote a startup script for Babel and a live updating map showing the strengths of connections between nodes. I learned a lot from the experience and will be able to set up a testbed to refine Althea.\"]]],[1,\"p\",[[0,[],0,\"It’s set up in an interesting way. Each router has 2.4 and 5 ghz radios. The 2.4 ghz radios are set up to mesh with 802.11s, to create a management network. Meanwhile, the 5 ghz radios are used to test the routing protocol under consideration. Since 2.4ghz often has a better range than 5ghz, this allows for the testing of topologies that may have poor connectivity in parts. Also, the transmit power of the 5ghz radios was turned down to allow a more realistic topology in a smaller area.\"]]],[1,\"p\",[[0,[],0,\"In one on one conversations about Althea, I found that many members of European mesh networks have a pragmatic attitude of “show me the code”. It’s a healthy attitude, and one we agree with. We’ll have a proof of concept soon, which will do most of the payment and tunneling, but without the route verification. This will prove out the concept, while taking a temporary shortcut on some of the more time consuming routing protocol development.\"]]],[1,\"p\",[[0,[],0,\"As for the basic idea of incentivized mesh, many of them have thought about it before, but there has never really been a strong attempt at automating payments and verification the way we are doing. Guifi.net in Catalonia has a system where for-profit ISPs are able to use their network and contribute back to it in proportion to how much they are using. However, this is all manually calculated and worked out by humans.\"]]],[1,\"p\",[[0,[],0,\"I also spoke with Axel, the creator of BMX7, and Linus, who works on Batman. We discussed the technical details of our verified routes. It didn’t seem like they had really considered the idea of verifying the quality metric of routes much before, but Axel has put several mechanisms into BMX7 to stop attacks aimed at simply disrupting the network. We will likely need to add similar mechanisms to Babel, although Babel is working on signed messages which may help prevent a lot of these attacks.\"]]],[1,\"p\",[[0,[],0,\"All in all, it was a good experience. They’ve perfected their testbed setup, and the knowledge of how it’s put together will be very helpful for us in the coming months. As for the likelihood of existing community networks being early adopters, I think that they may be a little more conservative because they already have networks up that work with their technical and social structure. They’d probably want to see something pretty well developed before risking their existing technical and social capital.\"]]],[1,\"p\",[[0,[],0,\"Also, some members of the community view the inclusion of a monetary incentive with suspicion for political and social reasons. Some of them might have to see Althea increasing competition, improving service, and lowering prices before giving the idea a chance.\"]]]]}","html":"<p>Last week I went to Battlemesh in Vienna. Battlemesh is a conference and competition that is held in a different location in Europe about once a year. Its original purpose is to test all the routing protocols against each other, hence &quot;battle&quot;. It&#39;s evolved into a great meeting of community network activists and enthusiasts from around Europe and around the world. In addition to the setup of the testbed, there are talks going on all week. I presented Althea there, you can see the video <a href=\"https://www.youtube.com/watch?v=f21KCNw7EWw&amp;list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&amp;index=4&amp;ab_channel=AdjyLeak\">here</a>. I was hoping for a lot of tough questions after the talk, but I got a lot of the questions later, in one on one conversations with participants. But more on that later. </p>\n\n<p>There were some very interesting talks. <a href=\"https://www.youtube.com/watch?v=uuSxoWcOEwA&amp;list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&amp;index=8&amp;ab_channel=AdjyLeak\">One particularly relevant talk</a> was from Leonardo Macccari, who is part of a team doing some research into community networks for the eu. They&#39;ve looked into a lot of different networks. what motivates the participants, and in particular, how networks that are supposed to be decentralized can become centralized by influential members owning a lot of the nodes, or dominating discussions.</p>\n\n<p><a href=\"https://www.youtube.com/watch?v=NLP4MxQp8kk&amp;list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&amp;index=6&amp;ab_channel=AdjyLeak\">Another great talk</a> was from Electra Wagenrad, who presented a diy solar charging system for mesh nodes. She estimated that a repeater with 2 directional antennas would require a 50 watt solar panel and a standard lead acid car battery. This could be a great way to set up nodes on hillsides etc with minimal support infrastructure.</p>\n\n<p>I was also able to participate in the testbed setup. I wrote a startup script for Babel and a live updating map showing the strengths of connections between nodes. I learned a lot from the experience and will be able to set up a testbed to refine Althea.</p>\n\n<p>It’s set up in an interesting way. Each router has 2.4 and 5 ghz radios. The 2.4 ghz radios are set up to mesh with 802.11s, to create a management network. Meanwhile, the 5 ghz radios are used to test the routing protocol under consideration. Since 2.4ghz often has a better range than 5ghz, this allows for the testing of topologies that may have poor connectivity in parts. Also, the transmit power of the 5ghz radios was turned down to allow a more realistic topology in a smaller area.</p>\n\n<p>In one on one conversations about Althea, I found that many members of European mesh networks have a pragmatic attitude of “show me the code”. It’s a healthy attitude, and one we agree with. We’ll have a proof of concept soon, which will do most of the payment and tunneling, but without the route verification. This will prove out the concept, while taking a temporary shortcut on some of the more time consuming routing protocol development.</p>\n\n<p>As for the basic idea of incentivized mesh, many of them have thought about it before, but there has never really been a strong attempt at automating payments and verification the way we are doing. Guifi.net in Catalonia has a system where for-profit ISPs are able to use their network and contribute back to it in proportion to how much they are using. However, this is all manually calculated and worked out by humans.</p>\n\n<p>I also spoke with Axel, the creator of BMX7, and Linus, who works on Batman. We discussed the technical details of our verified routes. It didn’t seem like they had really considered the idea of verifying the quality metric of routes much before, but Axel has put several mechanisms into BMX7 to stop attacks aimed at simply disrupting the network. We will likely need to add similar mechanisms to Babel, although Babel is working on signed messages which may help prevent a lot of these attacks.</p>\n\n<p>All in all, it was a good experience. They’ve perfected their testbed setup, and the knowledge of how it’s put together will be very helpful for us in the coming months. As for the likelihood of existing community networks being early adopters, I think that they may be a little more conservative because they already have networks up that work with their technical and social structure. They’d probably want to see something pretty well developed before risking their existing technical and social capital.</p>\n\n<p>Also, some members of the community view the inclusion of a monetary incentive with suspicion for political and social reasons. Some of them might have to see Althea increasing competition, improving service, and lowering prices before giving the idea a chance.</p>","comment_id":null,"plaintext":"Last week I went to Battlemesh in Vienna. Battlemesh is a conference and competition that is held in a different location in Europe about once a year. Its original purpose is to test all the routing protocols against each other, hence \"battle\". It's evolved into a great meeting of community network activists and enthusiasts from around Europe and around the world. In addition to the setup of the testbed, there are talks going on all week. I presented Althea there, you can see the video [here](https://www.youtube.com/watch?v=f21KCNw7EWw&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=4&ab_channel=AdjyLeak). I was hoping for a lot of tough questions after the talk, but I got a lot of the questions later, in one on one conversations with participants. But more on that later. \n\nThere were some very interesting talks. [One particularly relevant talk](https://www.youtube.com/watch?v=uuSxoWcOEwA&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=8&ab_channel=AdjyLeak) was from Leonardo Macccari, who is part of a team doing some research into community networks for the eu. They've looked into a lot of different networks. what motivates the participants, and in particular, how networks that are supposed to be decentralized can become centralized by influential members owning a lot of the nodes, or dominating discussions.\n\n[Another great talk](https://www.youtube.com/watch?v=NLP4MxQp8kk&list=PL3bvPCw5QCLJ-VJPamVeQx-UPNBVyaopj&index=6&ab_channel=AdjyLeak) was from Electra Wagenrad, who presented a diy solar charging system for mesh nodes. She estimated that a repeater with 2 directional antennas would require a 50 watt solar panel and a standard lead acid car battery. This could be a great way to set up nodes on hillsides etc with minimal support infrastructure.\n\nI was also able to participate in the testbed setup. I wrote a startup script for Babel and a live updating map showing the strengths of connections between nodes. I learned a lot from the experience and will be able to set up a testbed to refine Althea.\n\nIt’s set up in an interesting way. Each router has 2.4 and 5 ghz radios. The 2.4 ghz radios are set up to mesh with 802.11s, to create a management network. Meanwhile, the 5 ghz radios are used to test the routing protocol under consideration. Since 2.4ghz often has a better range than 5ghz, this allows for the testing of topologies that may have poor connectivity in parts. Also, the transmit power of the 5ghz radios was turned down to allow a more realistic topology in a smaller area.\n\nIn one on one conversations about Althea, I found that many members of European mesh networks have a pragmatic attitude of “show me the code”. It’s a healthy attitude, and one we agree with. We’ll have a proof of concept soon, which will do most of the payment and tunneling, but without the route verification. This will prove out the concept, while taking a temporary shortcut on some of the more time consuming routing protocol development.\n\nAs for the basic idea of incentivized mesh, many of them have thought about it before, but there has never really been a strong attempt at automating payments and verification the way we are doing. Guifi.net in Catalonia has a system where for-profit ISPs are able to use their network and contribute back to it in proportion to how much they are using. However, this is all manually calculated and worked out by humans.\n\nI also spoke with Axel, the creator of BMX7, and Linus, who works on Batman. We discussed the technical details of our verified routes. It didn’t seem like they had really considered the idea of verifying the quality metric of routes much before, but Axel has put several mechanisms into BMX7 to stop attacks aimed at simply disrupting the network. We will likely need to add similar mechanisms to Babel, although Babel is working on signed messages which may help prevent a lot of these attacks.\n\nAll in all, it was a good experience. They’ve perfected their testbed setup, and the knowledge of how it’s put together will be very helpful for us in the coming months. As for the likelihood of existing community networks being early adopters, I think that they may be a little more conservative because they already have networks up that work with their technical and social structure. They’d probably want to see something pretty well developed before risking their existing technical and social capital.\n\nAlso, some members of the community view the inclusion of a monetary incentive with suspicion for political and social reasons. Some of them might have to see Althea increasing competition, improving service, and lowering prices before giving the idea a chance.\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-06-19 00:00:00","created_by":"1","updated_at":"2017-06-19 00:00:00","updated_by":"1","published_at":"2017-06-19 00:00:00","published_by":"1","custom_excerpt":"Last week I went to Battlemesh in Vienna. Battlemesh is a conference and competition that is held in a different location in Europe about once a year. Its original purpose is to test all the routing protocols against each other, hence \\battle\\. It's evolved into a great meeting of community network ","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75e","uuid":"69cb92a0-b031-44d0-9a32-e5f3dee1cddd","title":"Dev Update 2: Shell Scripts","slug":"dev-update-2","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"/blog/using-core-for-network-simulation/\"]],[\"a\",[\"href\",\"https://fastd.readthedocs.io/en/v18/\"]],[\"em\"],[\"code\"],[\"a\",[\"href\",\"https://wiki.nftables.org/wiki-nftables/index.php/Main_Page\"]],[\"a\",[\"href\",\"http://www.lartc.org/manpages/tc.txt\"]],[\"a\",[\"href\",\"https://www.reddit.com/r/incentivizedmesh/comments/5oeo1v/tunnelfirewalltraffic_shaping_setup_to_securely/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"I'm now trying to build a piece of software that does a few things:\"]]],[3,\"ul\",[[[0,[],0,\"Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.\"]],[[0,[],0,\"Blocks packets that have not come over one of the authenticated tunnels from being forwarded.\"]],[[0,[],0,\"Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I'll just pass it in manually.\"]],[[0,[],0,\"Allows nodes to choose what proportion of their total bandwidth they will share/sell.\"]]]],[1,\"p\",[[0,[],0,\"I've been experimenting in \"],[0,[0],1,\"CORE\"],[0,[],0,\" with some shell scripts to make this stuff happen. I'm going to write the actual software in Go, but shell is great for prototyping. You can call other programs from within the language and shell's jankiness and disposable feel keeps you from getting too fixated on the minor details.\"]]],[1,\"h2\",[[0,[],0,\"Tunnels\"]]],[1,\"p\",[[0,[],0,\"I'm using \"],[0,[1],1,\"fastd\"],[0,[],0,\" for tunnels because it is easy to use and has a lot of options for customization. It's in userspace, which means that each packet will be copied out of kernel memory and back in several times. This greatly limits bandwidth, so I'll switch to something more efficient like Wireguard at some point.\"]]],[1,\"p\",[[0,[],0,\"Right now I'm using this shell script to set up each peer:\"]]],[1,\"p\",[[0,[],0,\"`shell\"]]],[1,\"h1\",[[0,[],0,\"usage: addpeer <peer\"],[0,[2],1,\"number> <peer\"],[0,[],0,\"ip> <peer_iface>\"]]],[1,\"p\",[[0,[],0,\"mkdir -p peers\"]]],[1,\"p\",[[0,[],0,\"peer\"],[0,[2],1,\"number=$1 peer\"],[0,[],0,\"ip=$2 peer_iface=$3\"]]],[1,\"p\",[[0,[],0,\"touch peers/peer$peer_number\"]]],[1,\"p\",[[0,[],0,\"echo '   key \\\"'$(cat /home/jehan2/host/fastd-test/publickey$peer\"],[0,[2],1,\"number)'\\\";   interface \\\"%n\\\";   remote \\\"'$peer\"],[0,[],0,\"ip'\\\" port 1234; ' > peers/peer$peer_number \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"ip route add $peer\"],[0,[2],1,\"ip dev $peer\"],[0,[],0,\"iface\"]]],[1,\"p\",[[0,[],0,\"Fastd uses a \"],[0,[3],1,\"peers/\"],[0,[],0,\" folder to keep track of its peers. Each peer has a file that contains its public key, address, and other information. Here I'm creating the file for a given peer. I'm copying the public key from a central folder.\"]]],[1,\"p\",[[0,[],0,\"To set up a network that looks like \"],[0,[3],1,\"1--2--3\"],[0,[],0,\", I run these commands:\"]]],[1,\"p\",[[0,[],0,\"On node 1:\"]]],[1,\"p\",[[0,[3],1,\"$ addpeer 2 10.0.0.2 eth0 \"]]],[1,\"p\",[[0,[],0,\"On node 2:\"]]],[1,\"p\",[[0,[3],1,\"$ addpeer 1 10.0.0.1 eth0 $ addpeer 3 10.0.0.3 eth0 \"]]],[1,\"p\",[[0,[],0,\"On node 3:\"]]],[1,\"p\",[[0,[3],1,\"$ addpeer 2 10.0.0.2 eth0 \"]]],[1,\"p\",[[0,[],0,\"Then I run this script on each node to get things started:\"]]],[1,\"p\",[[0,[],0,\"`shell\"]]],[1,\"h1\",[[0,[],0,\"usage: start <my\"],[0,[2],1,\"number> <my\"],[0,[],0,\"tunnel_ip>\"]]],[1,\"p\",[[0,[],0,\"touch fastd.conf echo \\\\ '   bind any:1234; # UDP Port 1234 auf allen Interfaces   mode multitap;   method \\\"xsalsa20-poly1305\\\"; # Verschlüsselungsalgorithmus festlegen   mtu 1426;   secret \\\"'$(cat /home/jehan2/host/fastd-test/privatekey$1)'\\\";\"]]],[1,\"p\",[[0,[],0,\"  include peers from \\\"peers\\\";\"]]],[1,\"p\",[[0,[],0,\"  on up \\\"     ip link set up $INTERFACE     ip addr add '$2' dev $INTERFACE     echo interface $INTERFACE | nc ::1 8481   \\\"; ' > fastd.conf\"]]],[1,\"p\",[[0,[],0,\"fastd -d -c fastd.conf \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"This sets up each node's private key and other fastd settings, including the \"],[0,[3],1,\"tunnel_ip\"],[0,[],0,\". The \"],[0,[3],1,\"tunnel_ip\"],[0,[],0,\" is different from the IP that the node has on the physical network. It is only accessible over the authenticated tunnels. I might actually be able to just use the node's normal IP for this, but having it be a different address is a good sanity check.\"]]],[1,\"p\",[[0,[],0,\"I also have to set up routes on each node manually. This will be done by the routing protocol, but for these tests I am doing it manually to eliminate any uncertainty.\"]]],[1,\"h2\",[[0,[],0,\"Firewall\"]]],[1,\"p\",[[0,[],0,\"Nodes do not want to forward any packet that has not come over one of the authenticated tunnels, because this packet has not been paid for. This is actually pretty easy to set up with \"],[0,[4],1,\"nftables\"],[0,[],0,\", once you understand the syntax and how it operates.\"]]],[1,\"p\",[[0,[],0,\"`shell\"]]],[1,\"h1\",[[0,[],0,\"usage: addrules <peer_number> ...\"]]],[1,\"p\",[[0,[],0,\"nft flush ruleset nft add table althea nft add chain althea fwd \\\"{ type filter hook forward priority 0; policy drop; }\\\"\"]]],[1,\"p\",[[0,[],0,\"for iif in \\\"$@\\\" do   for oif in \\\"$@\\\"   do     if [ $iif != $oif ]; then       nft add rule althea fwd meta iifname \\\"peer$iif\\\" oifname \\\"peer$oif\\\" mark set $iif$oif accept     fi   done done\"]]],[1,\"p\",[[0,[],0,\"nft list ruleset -a \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"This script sets up a table and a chain (these are both just containers for organizing the firewall rules). The chain is set up with a default policy of just blocking everything, and it is attached to the \"],[0,[3],1,\"forward\"],[0,[],0,\" hook which means that it applies to packets that are about to be forwarded by the system. By itself, this chain will prevent the system from forwarding any packets. In the loop the script makes a rule to accept packets for every pair of nodes, and adds a unique mark to them. This will allow us to identify which nodes packets are coming from and going to in the next step.\"]]],[1,\"p\",[[0,[],0,\"Running the script\"]]],[1,\"p\",[[0,[3],1,\"$ sh addrules.sh 2 3 4 \"]]],[1,\"p\",[[0,[],0,\"results in this ruleset:\"]]],[1,\"p\",[[0,[3],1,\"table ip althea { \\tchain fwd { \\t\\ttype filter hook forward priority 0; policy drop; \\t\\tiifname \\\"peer2\\\" oifname \\\"peer3\\\" mark set 0x00000017 accept  \\t\\tiifname \\\"peer2\\\" oifname \\\"peer4\\\" mark set 0x00000018 accept  \\t\\tiifname \\\"peer3\\\" oifname \\\"peer2\\\" mark set 0x00000020 accept  \\t\\tiifname \\\"peer3\\\" oifname \\\"peer4\\\" mark set 0x00000022 accept  \\t\\tiifname \\\"peer4\\\" oifname \\\"peer2\\\" mark set 0x0000002a accept  \\t\\tiifname \\\"peer4\\\" oifname \\\"peer3\\\" mark set 0x0000002b accept  \\t} } \"]]],[1,\"h2\",[[0,[],0,\"Traffic Shaping\"]]],[1,\"p\",[[0,[],0,\"Now it is time to prioritize traffic depending on how much nodes are paying. I'm using \"],[0,[5],1,\"tc\"],[0,[],0,\", which is a tool in linux for this purpose. Traffic shaping is a very subtle process and I don't fully understand all the ins and outs yet. Also, tc's syntax is frankly quite cumbersome. Tc lets you set up qdiscs- (short for queueing discipline). There are also filters which can put packets into different classes inside the qdisc depending on different criteria. The qdisc then enqueues packets into the different classes, and either dequeues them to the network or drops them to accomplish its traffic shaping goals.\"]]],[1,\"p\",[[0,[],0,\"I'll start with a diagram to explain the shaping setup that I have made, because the tc scripts are hard to follow.\"]]],[1,\"p\",[[0,[3],1,\"qdisc htb- limits all traffic to 10mbit/s  | qdisc drr- splits traffic into classes to be prioritized, based on the marks we added to packets with nftables  |                            | filter fw 23                 filter fw 24  |                            | class drr quantum 1400        class drr quantum 700       ...etc  |                            | qdisc fq_codel               qdisc fq_codel \"]]],[1,\"p\",[[0,[],0,\"First, the htb qdisc limits all traffic to 10mbit/s. This will allow nodes to choose how much of their bandwidth they wish to sell, and it is necessary for the drr qdisc to function (I'm not entirely sure why).\"]]],[1,\"p\",[[0,[],0,\"The drr qdisc has filters attached which put the traffic into its child classes based on the marks we attached to the packets in the firewall step above. Drr operates in a round robin fashion and basically allows each class to transmit \\\"quantum\\\" bytes each round. A class with quantum 1400 should be able to transmit twice as much data as one with quantum 700.\"]]],[1,\"p\",[[0,[],0,\"The fq_codel qdisc drops packets that hang around in each queue for too long. It also fairly queues traffic within each class so that, for instance, a large download won't slow down other traffic in the class too much. Without this packets will stay in the queues forever resulting in the system slowing to a crawl.\"]]],[1,\"p\",[[0,[],0,\"In the above setup, traffic going from peer 2 to peer 3 will have twice as much bandwidth as traffic going from peer 2 to peer 4.\"]]],[1,\"p\",[[0,[],0,\"Here are the scripts:\"]]],[1,\"p\",[[0,[],0,\"`shell\"]]],[1,\"h1\",[[0,[],0,\"usage: setup <network interface>\"]]],[1,\"p\",[[0,[],0,\"dev=$1\"]]],[1,\"h1\",[[0,[],0,\"Remove root qdisc (clean slate)\"]]],[1,\"p\",[[0,[],0,\"tc qdisc del dev $dev root\"]]],[1,\"h1\",[[0,[],0,\"Add root shaping qdisc and class\"]]],[1,\"p\",[[0,[],0,\"tc qdisc add dev $dev root handle 1: htb tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit ceil 10mbit\"]]],[1,\"h1\",[[0,[],0,\"Add root drr qdisc\"]]],[1,\"p\",[[0,[],0,\"tc qdisc add dev $dev handle 2: parent 1:1 drr\"]]],[1,\"h1\",[[0,[],0,\"Add default class\"]]],[1,\"p\",[[0,[],0,\"tc class add dev $dev parent 2: classid 2:1 drr\"]]],[1,\"h1\",[[0,[],0,\"Send traffic to default class\"]]],[1,\"p\",[[0,[],0,\"tc filter add dev $dev parent 1: protocol all prio 2 u32 match u32 0 0 classid 1:1 tc filter add dev $dev parent 2: protocol all prio 2 u32 match u32 0 0 classid 2:1\"]]],[1,\"p\",[[0,[],0,\"tc -s class show dev $dev tc -s filter show dev $dev \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"This sets things up and adds the htb qdisc and the root drr qdisc.\"]]],[1,\"p\",[[0,[],0,\"`shell\"]]],[1,\"h1\",[[0,[],0,\"usage: addqueue <network interface> <firewall mark> <quantum>\"]]],[1,\"p\",[[0,[],0,\"dev=$1 handle=$2 quantum=$3\"]]],[1,\"h1\",[[0,[],0,\"Get traffic with a certain fw mark and direct it to the corresponding DRR class\"]]],[1,\"p\",[[0,[],0,\"tc filter add dev $dev parent 2: protocol ip prio 1 handle $handle fw classid 2:$handle tc class add dev $dev parent 2: classid 2:$handle drr quantum $quantum\"]]],[1,\"h1\",[[0,[],0,\"This acts to actually drop traffic, making DRR take effect\"]]],[1,\"p\",[[0,[],0,\"tc qdisc add dev $dev parent 2:$handle fq_codel\"]]],[1,\"p\",[[0,[],0,\"tc -s class show dev $dev tc -s filter show dev $dev \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"I run this for every child class of the drr qdisc that I want to create. This will typically be once for every rule I set up in the firewall script above.\"]]],[1,\"p\",[[0,[],0,\"Using this setup, I am able to prioritize traffic coming from and going to a node's different peers. The next step, which I am working on now, is to automate this all. I'm writing that code in Go.\"]]],[1,\"p\",[[0,[6],1,\"Discuss this post on Reddit\"]]]]}","html":"<p>I&#39;m now trying to build a piece of software that does a few things:</p>\n\n<ul><li>Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.</li><li>Blocks packets that have not come over one of the authenticated tunnels from being forwarded.</li><li>Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I&#39;ll just pass it in manually.</li><li>Allows nodes to choose what proportion of their total bandwidth they will share/sell.</li></ul>\n\n<p>I&#39;ve been experimenting in <a href=\"/blog/using-core-for-network-simulation/\">CORE</a> with some shell scripts to make this stuff happen. I&#39;m going to write the actual software in Go, but shell is great for prototyping. You can call other programs from within the language and shell&#39;s jankiness and disposable feel keeps you from getting too fixated on the minor details.</p>\n\n<h2>Tunnels</h2>\n\n<p>I&#39;m using <a href=\"https://fastd.readthedocs.io/en/v18/\">fastd</a> for tunnels because it is easy to use and has a lot of options for customization. It&#39;s in userspace, which means that each packet will be copied out of kernel memory and back in several times. This greatly limits bandwidth, so I&#39;ll switch to something more efficient like Wireguard at some point.</p>\n\n<p>Right now I&#39;m using this shell script to set up each peer:</p>\n\n<p><code></code>`shell</p>\n\n<h1>usage: addpeer &lt;peer<em>number&gt; &lt;peer</em>ip&gt; &lt;peer_iface&gt;</h1>\n\n<p>mkdir -p peers</p>\n\n<p>peer<em>number=$1\npeer</em>ip=$2\npeer_iface=$3</p>\n\n<p>touch peers/peer$peer_number</p>\n\n<p>echo &#39;\n  key &quot;&#39;$(cat /home/jehan2/host/fastd-test/publickey$peer<em>number)&#39;&quot;;\n  interface &quot;%n&quot;;\n  remote &quot;&#39;$peer</em>ip&#39;&quot; port 1234;\n&#39; &gt; peers/peer$peer_number\n<code></code>`</p>\n\n<p>ip route add $peer<em>ip dev $peer</em>iface</p>\n\n<p>Fastd uses a <code>peers/</code> folder to keep track of its peers. Each peer has a file that contains its public key, address, and other information. Here I&#39;m creating the file for a given peer. I&#39;m copying the public key from a central folder.</p>\n\n<p>To set up a network that looks like <code>1--2--3</code>, I run these commands:</p>\n\n<p>On node 1:</p>\n\n<p><code>\n$ addpeer 2 10.0.0.2 eth0\n</code></p>\n\n<p>On node 2:</p>\n\n<p><code>\n$ addpeer 1 10.0.0.1 eth0\n$ addpeer 3 10.0.0.3 eth0\n</code></p>\n\n<p>On node 3:</p>\n\n<p><code>\n$ addpeer 2 10.0.0.2 eth0\n</code></p>\n\n<p>Then I run this script on each node to get things started:</p>\n\n<p><code></code>`shell</p>\n\n<h1>usage: start &lt;my<em>number&gt; &lt;my</em>tunnel_ip&gt;</h1>\n\n<p>touch fastd.conf\necho \\\n&#39;\n  bind any:1234; # UDP Port 1234 auf allen Interfaces\n  mode multitap;\n  method &quot;xsalsa20-poly1305&quot;; # Verschlüsselungsalgorithmus festlegen\n  mtu 1426;\n  secret &quot;&#39;$(cat /home/jehan2/host/fastd-test/privatekey$1)&#39;&quot;;</p>\n\n<p>  include peers from &quot;peers&quot;;</p>\n\n<p>  on up &quot;\n    ip link set up $INTERFACE\n    ip addr add &#39;$2&#39; dev $INTERFACE\n    echo interface $INTERFACE | nc ::1 8481\n  &quot;;\n&#39; &gt; fastd.conf</p>\n\n<p>fastd -d -c fastd.conf\n<code></code>`</p>\n\n<p>This sets up each node&#39;s private key and other fastd settings, including the <code>tunnel_ip</code>. The <code>tunnel_ip</code> is different from the IP that the node has on the physical network. It is only accessible over the authenticated tunnels. I might actually be able to just use the node&#39;s normal IP for this, but having it be a different address is a good sanity check.</p>\n\n<p>I also have to set up routes on each node manually. This will be done by the routing protocol, but for these tests I am doing it manually to eliminate any uncertainty.</p>\n\n<h2>Firewall</h2>\n\n<p>Nodes do not want to forward any packet that has not come over one of the authenticated tunnels, because this packet has not been paid for. This is actually pretty easy to set up with <a href=\"https://wiki.nftables.org/wiki-nftables/index.php/Main_Page\">nftables</a>, once you understand the syntax and how it operates.</p>\n\n<p><code></code>`shell</p>\n\n<h1>usage: addrules &lt;peer_number&gt; ...</h1>\n\n<p>nft flush ruleset\nnft add table althea\nnft add chain althea fwd &quot;{ type filter hook forward priority 0; policy drop; }&quot;</p>\n\n<p>for iif in &quot;$@&quot;\ndo\n  for oif in &quot;$@&quot;\n  do\n    if [ $iif != $oif ]; then\n      nft add rule althea fwd meta iifname &quot;peer$iif&quot; oifname &quot;peer$oif&quot; mark set $iif$oif accept\n    fi\n  done\ndone</p>\n\n<p>nft list ruleset -a\n<code></code>`</p>\n\n<p>This script sets up a table and a chain (these are both just containers for organizing the firewall rules). The chain is set up with a default policy of just blocking everything, and it is attached to the <code>forward</code> hook which means that it applies to packets that are about to be forwarded by the system. By itself, this chain will prevent the system from forwarding any packets. In the loop the script makes a rule to accept packets for every pair of nodes, and adds a unique mark to them. This will allow us to identify which nodes packets are coming from and going to in the next step.</p>\n\n<p>Running the script</p>\n\n<p><code>\n$ sh addrules.sh 2 3 4\n</code></p>\n\n<p>results in this ruleset:</p>\n\n<p><code>\ntable ip althea {\n\tchain fwd {\n\t\ttype filter hook forward priority 0; policy drop;\n\t\tiifname &quot;peer2&quot; oifname &quot;peer3&quot; mark set 0x00000017 accept \n\t\tiifname &quot;peer2&quot; oifname &quot;peer4&quot; mark set 0x00000018 accept \n\t\tiifname &quot;peer3&quot; oifname &quot;peer2&quot; mark set 0x00000020 accept \n\t\tiifname &quot;peer3&quot; oifname &quot;peer4&quot; mark set 0x00000022 accept \n\t\tiifname &quot;peer4&quot; oifname &quot;peer2&quot; mark set 0x0000002a accept \n\t\tiifname &quot;peer4&quot; oifname &quot;peer3&quot; mark set 0x0000002b accept \n\t}\n}\n</code></p>\n\n<h2>Traffic Shaping</h2>\n\n<p>Now it is time to prioritize traffic depending on how much nodes are paying. I&#39;m using <a href=\"http://www.lartc.org/manpages/tc.txt\">tc</a>, which is a tool in linux for this purpose. Traffic shaping is a very subtle process and I don&#39;t fully understand all the ins and outs yet. Also, tc&#39;s syntax is frankly quite cumbersome. Tc lets you set up qdiscs- (short for queueing discipline). There are also filters which can put packets into different classes inside the qdisc depending on different criteria. The qdisc then enqueues packets into the different classes, and either dequeues them to the network or drops them to accomplish its traffic shaping goals.</p>\n\n<p>I&#39;ll start with a diagram to explain the shaping setup that I have made, because the tc scripts are hard to follow.</p>\n\n<p><code>\nqdisc htb- limits all traffic to 10mbit/s\n |\nqdisc drr- splits traffic into classes to be prioritized,\nbased on the marks we added to packets with nftables\n |                            |\nfilter fw 23                 filter fw 24\n |                            |\nclass drr quantum 1400        class drr quantum 700       ...etc\n |                            |\nqdisc fq_codel               qdisc fq_codel\n</code></p>\n\n<p>First, the htb qdisc limits all traffic to 10mbit/s. This will allow nodes to choose how much of their bandwidth they wish to sell, and it is necessary for the drr qdisc to function (I&#39;m not entirely sure why).</p>\n\n<p>The drr qdisc has filters attached which put the traffic into its child classes based on the marks we attached to the packets in the firewall step above. Drr operates in a round robin fashion and basically allows each class to transmit &quot;quantum&quot; bytes each round. A class with quantum 1400 should be able to transmit twice as much data as one with quantum 700.</p>\n\n<p>The fq_codel qdisc drops packets that hang around in each queue for too long. It also fairly queues traffic within each class so that, for instance, a large download won&#39;t slow down other traffic in the class too much. Without this packets will stay in the queues forever resulting in the system slowing to a crawl.</p>\n\n<p>In the above setup, traffic going from peer 2 to peer 3 will have twice as much bandwidth as traffic going from peer 2 to peer 4.</p>\n\n<p>Here are the scripts:</p>\n\n<p><code></code>`shell</p>\n\n<h1>usage: setup &lt;network interface&gt;</h1>\n\n<p>dev=$1</p>\n\n<h1>Remove root qdisc (clean slate)</h1>\n\n<p>tc qdisc del dev $dev root</p>\n\n<h1>Add root shaping qdisc and class</h1>\n\n<p>tc qdisc add dev $dev root handle 1: htb\ntc class add dev $dev parent 1: classid 1:1 htb rate 10mbit ceil 10mbit</p>\n\n<h1>Add root drr qdisc</h1>\n\n<p>tc qdisc add dev $dev handle 2: parent 1:1 drr</p>\n\n<h1>Add default class</h1>\n\n<p>tc class add dev $dev parent 2: classid 2:1 drr</p>\n\n<h1>Send traffic to default class</h1>\n\n<p>tc filter add dev $dev parent 1: protocol all prio 2 u32 match u32 0 0 classid 1:1\ntc filter add dev $dev parent 2: protocol all prio 2 u32 match u32 0 0 classid 2:1</p>\n\n<p>tc -s class show dev $dev\ntc -s filter show dev $dev\n<code></code>`</p>\n\n<p>This sets things up and adds the htb qdisc and the root drr qdisc.</p>\n\n<p><code></code>`shell</p>\n\n<h1>usage: addqueue &lt;network interface&gt; &lt;firewall mark&gt; &lt;quantum&gt;</h1>\n\n<p>dev=$1\nhandle=$2\nquantum=$3</p>\n\n<h1>Get traffic with a certain fw mark and direct it to the corresponding DRR class</h1>\n\n<p>tc filter add dev $dev parent 2: protocol ip prio 1 handle $handle fw classid 2:$handle\ntc class add dev $dev parent 2: classid 2:$handle drr quantum $quantum</p>\n\n<h1>This acts to actually drop traffic, making DRR take effect</h1>\n\n<p>tc qdisc add dev $dev parent 2:$handle fq_codel</p>\n\n<p>tc -s class show dev $dev\ntc -s filter show dev $dev\n<code></code>`</p>\n\n<p>I run this for every child class of the drr qdisc that I want to create. This will typically be once for every rule I set up in the firewall script above.</p>\n\n<p>Using this setup, I am able to prioritize traffic coming from and going to a node&#39;s different peers. The next step, which I am working on now, is to automate this all. I&#39;m writing that code in Go.</p>\n\n<p><a href=\"https://www.reddit.com/r/incentivizedmesh/comments/5oeo1v/tunnelfirewalltraffic_shaping_setup_to_securely/\">Discuss this post on Reddit</a></p>","comment_id":null,"plaintext":"I'm now trying to build a piece of software that does a few things:\n\n- Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.\n- Blocks packets that have not come over one of the authenticated tunnels from being forwarded.\n- Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I'll just pass it in manually.\n- Allows nodes to choose what proportion of their total bandwidth they will share/sell.\n\nI've been experimenting in [CORE](/blog/using-core-for-network-simulation/) with some shell scripts to make this stuff happen. I'm going to write the actual software in Go, but shell is great for prototyping. You can call other programs from within the language and shell's jankiness and disposable feel keeps you from getting too fixated on the minor details.\n\n## Tunnels\nI'm using [fastd](https://fastd.readthedocs.io/en/v18/) for tunnels because it is easy to use and has a lot of options for customization. It's in userspace, which means that each packet will be copied out of kernel memory and back in several times. This greatly limits bandwidth, so I'll switch to something more efficient like Wireguard at some point.\n\nRight now I'm using this shell script to set up each peer:\n\n```shell\n# usage: addpeer <peer_number> <peer_ip> <peer_iface>\n\nmkdir -p peers\n\npeer_number=$1\npeer_ip=$2\npeer_iface=$3\n\ntouch peers/peer$peer_number\n\necho '\n  key \"'$(cat /home/jehan2/host/fastd-test/publickey$peer_number)'\";\n  interface \"%n\";\n  remote \"'$peer_ip'\" port 1234;\n' > peers/peer$peer_number\n```\n\nip route add $peer_ip dev $peer_iface\n\nFastd uses a `peers/` folder to keep track of its peers. Each peer has a file that contains its public key, address, and other information. Here I'm creating the file for a given peer. I'm copying the public key from a central folder.\n\nTo set up a network that looks like `1--2--3`, I run these commands:\n\nOn node 1:\n\n```\n$ addpeer 2 10.0.0.2 eth0\n```\n\nOn node 2:\n\n```\n$ addpeer 1 10.0.0.1 eth0\n$ addpeer 3 10.0.0.3 eth0\n```\n\nOn node 3:\n\n```\n$ addpeer 2 10.0.0.2 eth0\n```\n\nThen I run this script on each node to get things started:\n\n```shell\n# usage: start <my_number> <my_tunnel_ip>\n\ntouch fastd.conf\necho \\\n'\n  bind any:1234; # UDP Port 1234 auf allen Interfaces\n  mode multitap;\n  method \"xsalsa20-poly1305\"; # Verschlüsselungsalgorithmus festlegen\n  mtu 1426;\n  secret \"'$(cat /home/jehan2/host/fastd-test/privatekey$1)'\";\n\n  include peers from \"peers\";\n\n  on up \"\n    ip link set up $INTERFACE\n    ip addr add '$2' dev $INTERFACE\n    echo interface $INTERFACE | nc ::1 8481\n  \";\n' > fastd.conf\n\nfastd -d -c fastd.conf\n```\n\nThis sets up each node's private key and other fastd settings, including the `tunnel_ip`. The `tunnel_ip` is different from the IP that the node has on the physical network. It is only accessible over the authenticated tunnels. I might actually be able to just use the node's normal IP for this, but having it be a different address is a good sanity check.\n\nI also have to set up routes on each node manually. This will be done by the routing protocol, but for these tests I am doing it manually to eliminate any uncertainty.\n\n## Firewall\nNodes do not want to forward any packet that has not come over one of the authenticated tunnels, because this packet has not been paid for. This is actually pretty easy to set up with [nftables](https://wiki.nftables.org/wiki-nftables/index.php/Main_Page), once you understand the syntax and how it operates.\n\n```shell\n# usage: addrules <peer_number> ...\n\nnft flush ruleset\nnft add table althea\nnft add chain althea fwd \"{ type filter hook forward priority 0; policy drop; }\"\n\nfor iif in \"$@\"\ndo\n  for oif in \"$@\"\n  do\n    if [ $iif != $oif ]; then\n      nft add rule althea fwd meta iifname \"peer$iif\" oifname \"peer$oif\" mark set $iif$oif accept\n    fi\n  done\ndone\n\nnft list ruleset -a\n```\n\nThis script sets up a table and a chain (these are both just containers for organizing the firewall rules). The chain is set up with a default policy of just blocking everything, and it is attached to the `forward` hook which means that it applies to packets that are about to be forwarded by the system. By itself, this chain will prevent the system from forwarding any packets. In the loop the script makes a rule to accept packets for every pair of nodes, and adds a unique mark to them. This will allow us to identify which nodes packets are coming from and going to in the next step.\n\nRunning the script\n\n```\n$ sh addrules.sh 2 3 4\n```\n\nresults in this ruleset:\n\n```\ntable ip althea {\n\tchain fwd {\n\t\ttype filter hook forward priority 0; policy drop;\n\t\tiifname \"peer2\" oifname \"peer3\" mark set 0x00000017 accept \n\t\tiifname \"peer2\" oifname \"peer4\" mark set 0x00000018 accept \n\t\tiifname \"peer3\" oifname \"peer2\" mark set 0x00000020 accept \n\t\tiifname \"peer3\" oifname \"peer4\" mark set 0x00000022 accept \n\t\tiifname \"peer4\" oifname \"peer2\" mark set 0x0000002a accept \n\t\tiifname \"peer4\" oifname \"peer3\" mark set 0x0000002b accept \n\t}\n}\n```\n\n## Traffic Shaping\nNow it is time to prioritize traffic depending on how much nodes are paying. I'm using [tc](http://www.lartc.org/manpages/tc.txt), which is a tool in linux for this purpose. Traffic shaping is a very subtle process and I don't fully understand all the ins and outs yet. Also, tc's syntax is frankly quite cumbersome. Tc lets you set up qdiscs- (short for queueing discipline). There are also filters which can put packets into different classes inside the qdisc depending on different criteria. The qdisc then enqueues packets into the different classes, and either dequeues them to the network or drops them to accomplish its traffic shaping goals.\n\nI'll start with a diagram to explain the shaping setup that I have made, because the tc scripts are hard to follow.\n\n```\nqdisc htb- limits all traffic to 10mbit/s\n |\nqdisc drr- splits traffic into classes to be prioritized,\nbased on the marks we added to packets with nftables\n |                            |\nfilter fw 23                 filter fw 24\n |                            |\nclass drr quantum 1400        class drr quantum 700       ...etc\n |                            |\nqdisc fq_codel               qdisc fq_codel\n```\n\nFirst, the htb qdisc limits all traffic to 10mbit/s. This will allow nodes to choose how much of their bandwidth they wish to sell, and it is necessary for the drr qdisc to function (I'm not entirely sure why).\n\nThe drr qdisc has filters attached which put the traffic into its child classes based on the marks we attached to the packets in the firewall step above. Drr operates in a round robin fashion and basically allows each class to transmit \"quantum\" bytes each round. A class with quantum 1400 should be able to transmit twice as much data as one with quantum 700.\n\nThe fq_codel qdisc drops packets that hang around in each queue for too long. It also fairly queues traffic within each class so that, for instance, a large download won't slow down other traffic in the class too much. Without this packets will stay in the queues forever resulting in the system slowing to a crawl.\n\nIn the above setup, traffic going from peer 2 to peer 3 will have twice as much bandwidth as traffic going from peer 2 to peer 4.\n\nHere are the scripts:\n\n```shell\n# usage: setup <network interface>\ndev=$1\n\n# Remove root qdisc (clean slate)\ntc qdisc del dev $dev root\n\n# Add root shaping qdisc and class\ntc qdisc add dev $dev root handle 1: htb\ntc class add dev $dev parent 1: classid 1:1 htb rate 10mbit ceil 10mbit\n\n# Add root drr qdisc\ntc qdisc add dev $dev handle 2: parent 1:1 drr\n\n# Add default class\ntc class add dev $dev parent 2: classid 2:1 drr\n\n# Send traffic to default class\ntc filter add dev $dev parent 1: protocol all prio 2 u32 match u32 0 0 classid 1:1\ntc filter add dev $dev parent 2: protocol all prio 2 u32 match u32 0 0 classid 2:1\n\ntc -s class show dev $dev\ntc -s filter show dev $dev\n```\n\nThis sets things up and adds the htb qdisc and the root drr qdisc.\n\n```shell\n# usage: addqueue <network interface> <firewall mark> <quantum>\ndev=$1\nhandle=$2\nquantum=$3\n\n# Get traffic with a certain fw mark and direct it to the corresponding DRR class\ntc filter add dev $dev parent 2: protocol ip prio 1 handle $handle fw classid 2:$handle\ntc class add dev $dev parent 2: classid 2:$handle drr quantum $quantum\n\n# This acts to actually drop traffic, making DRR take effect\ntc qdisc add dev $dev parent 2:$handle fq_codel\n\ntc -s class show dev $dev\ntc -s filter show dev $dev\n```\n\nI run this for every child class of the drr qdisc that I want to create. This will typically be once for every rule I set up in the firewall script above.\n\nUsing this setup, I am able to prioritize traffic coming from and going to a node's different peers. The next step, which I am working on now, is to automate this all. I'm writing that code in Go.\n\n[Discuss this post on Reddit](https://www.reddit.com/r/incentivizedmesh/comments/5oeo1v/tunnelfirewalltraffic_shaping_setup_to_securely/)","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-01-11 00:00:00","created_by":"1","updated_at":"2017-01-11 00:00:00","updated_by":"1","published_at":"2017-01-11 00:00:00","published_by":"1","custom_excerpt":"I've been experimenting in CORE with some shell scripts to allow nodes to prioritize traffic to and from their peers.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc75f","uuid":"31051c02-885c-4384-91fb-26ea7cdcc147","title":"Route quality metric verification","slug":"route-quality-metric-verification","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"http://altheamesh.com/blog/althea-paper/\"]],[\"a\",[\"href\",\"https://www.reddit.com/r/hocnet/\"]],[\"strong\"]],\"sections\":[[1,\"p\",[[0,[],0,\"Any kind of incentivized mesh scheme needs a secure routing protocol. Without this, any node can claim anything it wants about the quality of routes that it has to a destination. Depending on how the payments work, there are a variety of different ways that this kind of routing protocol cheating can be financially lucrative. There needs to be a good way to verify that what nodes claim about the quality and quantity of their connections to other nodes is correct.\"]]],[1,\"p\",[[0,[],0,\"In the original design of Althea, in the \"],[0,[0],1,\"whitepaper\"],[0,[],0,\", I call for verification of routes. That is, once a node has made a connection to another node that it cares about, it checks whether the route quality information propagated with the routing protocol is correct. This consists of the node doing some kind of route quality or throughput test with the destination node and seeing if it matches up to what was propagated.\"]]],[1,\"p\",[[0,[],0,\"If the propagated information is incorrect, the node corrects its own routing information, and tells the node that gave it the bad route about the inaccuracy. Once the neighbor finds out about the inaccuracy, it could do its own quality test, and tell its neighbors about the results and so on. But having each node along a route doing a quality test to verify the route could be slow and result in a lot of overhead.\"]]],[1,\"p\",[[0,[],0,\"Justin Kilpatrick, who is working on a similar project called \"],[0,[1],1,\"Hocnet\"],[0,[],0,\", came up with an interesting idea: reuse the results of a quality test along a route.\"]]],[1,\"p\",[[0,[],0,\"As a simple example, let's say that the quality metric that is being used is percent packet loss. Alice is sending traffic to a Zack over the network. Zack keeps track of how many packets he receives over a certain time period, signs this, and sends it back. Now Alice can compare this information with her own statistics about how many packets she has sent out during the same time period to derive a percent packet loss metric.\"]]],[1,\"p\",[[0,[],0,\"Let's say that the numbers don't match up, and the route is losing more packets than advertised. \"]]],[1,\"p\",[[0,[],0,\"In Althea, Alice would just correct her own routes and notify Bob, the neighbor that gave her the route. Bob would then have to communicate with the destination himself to find out what the real quality is.\"]]],[1,\"p\",[[0,[],0,\"In Hocnet, Alice passes Zack's signed statement about how many packets he has received from her along to Bob. Now Bob compares Zack's statement just like Alice did to find out his own quality to Zack.\"]]],[1,\"p\",[[0,[],0,\"One additional requirement in this kind of scheme is that the quality test be done on normal traffic. Otherwise, nodes along the route could simply prioritize traffic that they recognize as part of a quality test, while dropping normal traffic.\"]]],[1,\"p\",[[0,[],0,\"Possible types of quality test:\"]]],[1,\"h3\",[[0,[],0,\"Packet loss percentage:\"]]],[1,\"p\",[[0,[2],1,\"Functionality:\"],[0,[],0,\" Nodes find out how many packets are lost over links to their neighbors. When they get a route update message for a given destination, they multiply the total route packet loss by the packet loss of the link they received it on and forward it onwards.\"]]],[1,\"p\",[[0,[2],1,\"Verification:\"],[0,[],0,\" The product of the packet loss of every link in a route should equal the packet loss of the whole route. The destination sends a signed message with the number of packets received from a source during a certain time period. Nodes along the route can compare this with how many packets from that source they have forwarded to the destination during this time period to find the route's total packet loss. Babel and Batman IV use this type of metric.\"]]],[1,\"h3\",[[0,[],0,\"Throughput:\"]]],[1,\"p\",[[0,[2],1,\"Functionality:\"],[0,[],0,\" Nodes find the maximum throughput of links to their neighbors. When they get a route update message for a given destination, they set the total route throughput to equal the throughput of the link they received the message on, if the throughput of the link is lower.\"]]],[1,\"p\",[[0,[2],1,\"Verification:\"],[0,[],0,\" The lowest throughput link along the route should equal the maximum throughput of the route as a whole. The destination sends a signed message with the number of bytes received from a source during a certain time period. Nodes along the route can compare this to the number of bytes that they forwarded from that source. An important caveat here is that the route must be saturated to the maximum throughput to get an accurate estimate. This could waste bandwidth and also tip off nodes along the route that a quality test is happening. Batman V uses this type of metric.\"]]],[1,\"h3\",[[0,[],0,\"Latency:\"]]],[1,\"p\",[[0,[2],1,\"Functionality:\"],[0,[],0,\" Nodes measure the average latency of links to their neighbors. When they get a route update message for a given destination, they add the latency of the link they received it on to the total route latency before forwarding it onwards.\"]]],[1,\"p\",[[0,[2],1,\"Verification:\"],[0,[],0,\" The sum of the latencies of all the links on a route should equal the latency of the route as a whole. The destination sends a signed message with the hashes of various packets and their time of receipt. Nodes on the route compare this time of receipt with the time that they received each packet.\"]]]]}","html":"<p>Any kind of incentivized mesh scheme needs a secure routing protocol. Without this, any node can claim anything it wants about the quality of routes that it has to a destination. Depending on how the payments work, there are a variety of different ways that this kind of routing protocol cheating can be financially lucrative. There needs to be a good way to verify that what nodes claim about the quality and quantity of their connections to other nodes is correct.</p>\n\n<p>In the original design of Althea, in the <a href=\"http://altheamesh.com/blog/althea-paper/\">whitepaper</a>, I call for verification of routes. That is, once a node has made a connection to another node that it cares about, it checks whether the route quality information propagated with the routing protocol is correct. This consists of the node doing some kind of route quality or throughput test with the destination node and seeing if it matches up to what was propagated.</p>\n\n<p>If the propagated information is incorrect, the node corrects its own routing information, and tells the node that gave it the bad route about the inaccuracy. Once the neighbor finds out about the inaccuracy, it could do its own quality test, and tell its neighbors about the results and so on. But having each node along a route doing a quality test to verify the route could be slow and result in a lot of overhead.</p>\n\n<p>Justin Kilpatrick, who is working on a similar project called <a href=\"https://www.reddit.com/r/hocnet/\">Hocnet</a>, came up with an interesting idea: reuse the results of a quality test along a route.</p>\n\n<p>As a simple example, let&#39;s say that the quality metric that is being used is percent packet loss. Alice is sending traffic to a Zack over the network. Zack keeps track of how many packets he receives over a certain time period, signs this, and sends it back. Now Alice can compare this information with her own statistics about how many packets she has sent out during the same time period to derive a percent packet loss metric.</p>\n\n<p>Let&#39;s say that the numbers don&#39;t match up, and the route is losing more packets than advertised. </p>\n\n<p>In Althea, Alice would just correct her own routes and notify Bob, the neighbor that gave her the route. Bob would then have to communicate with the destination himself to find out what the real quality is.</p>\n\n<p>In Hocnet, Alice passes Zack&#39;s signed statement about how many packets he has received from her along to Bob. Now Bob compares Zack&#39;s statement just like Alice did to find out his own quality to Zack.</p>\n\n<p>One additional requirement in this kind of scheme is that the quality test be done on normal traffic. Otherwise, nodes along the route could simply prioritize traffic that they recognize as part of a quality test, while dropping normal traffic.</p>\n\n<p>Possible types of quality test:</p>\n\n<h3>Packet loss percentage:</h3>\n\n<p><strong>Functionality:</strong> Nodes find out how many packets are lost over links to their neighbors. When they get a route update message for a given destination, they multiply the total route packet loss by the packet loss of the link they received it on and forward it onwards.</p>\n\n<p><strong>Verification:</strong> The product of the packet loss of every link in a route should equal the packet loss of the whole route. The destination sends a signed message with the number of packets received from a source during a certain time period. Nodes along the route can compare this with how many packets from that source they have forwarded to the destination during this time period to find the route&#39;s total packet loss. Babel and Batman IV use this type of metric.</p>\n\n<h3>Throughput:</h3>\n\n<p><strong>Functionality:</strong> Nodes find the maximum throughput of links to their neighbors. When they get a route update message for a given destination, they set the total route throughput to equal the throughput of the link they received the message on, if the throughput of the link is lower.</p>\n\n<p><strong>Verification:</strong> The lowest throughput link along the route should equal the maximum throughput of the route as a whole. The destination sends a signed message with the number of bytes received from a source during a certain time period. Nodes along the route can compare this to the number of bytes that they forwarded from that source. An important caveat here is that the route must be saturated to the maximum throughput to get an accurate estimate. This could waste bandwidth and also tip off nodes along the route that a quality test is happening. Batman V uses this type of metric.</p>\n\n<h3>Latency:</h3>\n\n<p><strong>Functionality:</strong> Nodes measure the average latency of links to their neighbors. When they get a route update message for a given destination, they add the latency of the link they received it on to the total route latency before forwarding it onwards.</p>\n\n<p><strong>Verification:</strong> The sum of the latencies of all the links on a route should equal the latency of the route as a whole. The destination sends a signed message with the hashes of various packets and their time of receipt. Nodes on the route compare this time of receipt with the time that they received each packet.</p>","comment_id":null,"plaintext":"Any kind of incentivized mesh scheme needs a secure routing protocol. Without this, any node can claim anything it wants about the quality of routes that it has to a destination. Depending on how the payments work, there are a variety of different ways that this kind of routing protocol cheating can be financially lucrative. There needs to be a good way to verify that what nodes claim about the quality and quantity of their connections to other nodes is correct.\n\nIn the original design of Althea, in the [whitepaper](http://altheamesh.com/blog/althea-paper/), I call for verification of routes. That is, once a node has made a connection to another node that it cares about, it checks whether the route quality information propagated with the routing protocol is correct. This consists of the node doing some kind of route quality or throughput test with the destination node and seeing if it matches up to what was propagated.\n\nIf the propagated information is incorrect, the node corrects its own routing information, and tells the node that gave it the bad route about the inaccuracy. Once the neighbor finds out about the inaccuracy, it could do its own quality test, and tell its neighbors about the results and so on. But having each node along a route doing a quality test to verify the route could be slow and result in a lot of overhead.\n\nJustin Kilpatrick, who is working on a similar project called [Hocnet](https://www.reddit.com/r/hocnet/), came up with an interesting idea: reuse the results of a quality test along a route.\n\nAs a simple example, let's say that the quality metric that is being used is percent packet loss. Alice is sending traffic to a Zack over the network. Zack keeps track of how many packets he receives over a certain time period, signs this, and sends it back. Now Alice can compare this information with her own statistics about how many packets she has sent out during the same time period to derive a percent packet loss metric.\n\nLet's say that the numbers don't match up, and the route is losing more packets than advertised. \n\nIn Althea, Alice would just correct her own routes and notify Bob, the neighbor that gave her the route. Bob would then have to communicate with the destination himself to find out what the real quality is.\n\nIn Hocnet, Alice passes Zack's signed statement about how many packets he has received from her along to Bob. Now Bob compares Zack's statement just like Alice did to find out his own quality to Zack.\n\nOne additional requirement in this kind of scheme is that the quality test be done on normal traffic. Otherwise, nodes along the route could simply prioritize traffic that they recognize as part of a quality test, while dropping normal traffic.\n\nPossible types of quality test:\n\n### Packet loss percentage:\n\n**Functionality:** Nodes find out how many packets are lost over links to their neighbors. When they get a route update message for a given destination, they multiply the total route packet loss by the packet loss of the link they received it on and forward it onwards.\n\n**Verification:** The product of the packet loss of every link in a route should equal the packet loss of the whole route. The destination sends a signed message with the number of packets received from a source during a certain time period. Nodes along the route can compare this with how many packets from that source they have forwarded to the destination during this time period to find the route's total packet loss. Babel and Batman IV use this type of metric.\n\n### Throughput:\n\n**Functionality:** Nodes find the maximum throughput of links to their neighbors. When they get a route update message for a given destination, they set the total route throughput to equal the throughput of the link they received the message on, if the throughput of the link is lower.\n\n**Verification:** The lowest throughput link along the route should equal the maximum throughput of the route as a whole. The destination sends a signed message with the number of bytes received from a source during a certain time period. Nodes along the route can compare this to the number of bytes that they forwarded from that source. An important caveat here is that the route must be saturated to the maximum throughput to get an accurate estimate. This could waste bandwidth and also tip off nodes along the route that a quality test is happening. Batman V uses this type of metric.\n\n### Latency:\n\n**Functionality:** Nodes measure the average latency of links to their neighbors. When they get a route update message for a given destination, they add the latency of the link they received it on to the total route latency before forwarding it onwards.\n\n**Verification:** The sum of the latencies of all the links on a route should equal the latency of the route as a whole. The destination sends a signed message with the hashes of various packets and their time of receipt. Nodes on the route compare this time of receipt with the time that they received each packet.\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-01-16 00:00:00","created_by":"1","updated_at":"2017-01-16 00:00:00","updated_by":"1","published_at":"2017-01-16 00:00:00","published_by":"1","custom_excerpt":"Any kind of incentivized mesh scheme needs a secure routing protocol. Without this, any node can claim anything it wants about the quality of routes that it has to a destination. Depending on how the payments work, there are a variety of different ways that this kind of routing protocol cheating can","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc760","uuid":"d76db5a9-8531-490c-9247-146b17c11d9a","title":"Comparison of Althea and RightMesh","slug":"comparison-of-althea-and-rightmesh","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"http://altheamesh.com/documents/whitepaper.pdf\"]],[\"a\",[\"href\",\"https://www.rightmesh.io/\"]],[\"a\",[\"href\",\"https://www.rightmesh.io/wp-content/uploads/2017/07/RightMesh-Technical-Whitepaper1.pdf\"]],[\"strong\"],[\"a\",[\"href\",\"https://github.com/rightmesh\"]],[\"a\",[\"href\",\"https://left.io/\"]],[\"a\",[\"href\",\"https://github.com/althea-mesh\"]],[\"a\",[\"href\",\"https://www.ubnt.com/products/#airfiber\"]],[\"a\",[\"href\",\"https://www.irif.fr/~jch/software/babel/\"]],[\"a\",[\"href\",\"https://tools.ietf.org/html/rfc7557\"]],[\"a\",[\"href\",\"https://github.com/althea-mesh/babeld\"]],[\"a\",[\"href\",\"http://altheamesh.com/blog/altheas-multihop-payment-channels/\"]],[\"a\",[\"href\",\"https://github.com/jtremback/avocado\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"We’ve been working on the architecture of Althea for nearly a year now, during that time we’ve made a lot of decisions that define how our network is structured with broad impacts on how it will perform in the real world. This post assumes you have already had a chance to read \"],[0,[0],1,\"our paper\"],[0,[],0,\" which contains our design for incentivizing mesh routing with cryptocurrency payments. It leverages existing technology, addresses major security concerns adequately and is expected to run on nearly any device, even off-the-shelf consumer routers.\"]]],[1,\"p\",[[0,[],0,\"A few weeks ago \"],[0,[1],1,\"Rightmesh\"],[0,[],0,\", a cell phone mesh product, published their \"],[0,[2],1,\"technical paper\"],[0,[],0,\" which provides an interesting alternative architecture with very different focus from our own.\"]]],[1,\"p\",[[0,[],0,\"In this post we’ll be comparing our products and contrasting different vulnerabilities, performance, and implementation challenges that come inherent to each product. We will also identify several potential problems in both Althea and the version of RightMesh described in their paper and suggest how they could be addressed.\"]]],[1,\"p\",[[0,[3],1,\"Principles\"]]],[1,\"p\",[[0,[],0,\"This commentary is somewhat limited by the fact that RightMesh publishes has yet to publish any cryptocurrency-related code on their  \"],[0,[4],1,\"Github\"],[0,[],0,\". Unlike Althea, large components of the RightMesh software stack will be closed source. They will publish the cryptocurrency-related components while using a proprietary mesh networking protocol from their parent company \"],[0,[5],1,\"Left\"],[0,[],0,\".\"]]],[1,\"p\",[[0,[],0,\"We publish our code as we write it. The \"],[0,[6],1,\"Althea Github\"],[0,[],0,\" contains all the code we’ve written and everything you need to build the systems we are using from scratch. We are committed to open source. \"]]],[1,\"p\",[[0,[],0,\"Regardless of our principles, without open source specifications we have to infer the capabilities of Left’s mesh protocol from off-hand claims made by RightMesh about its capabilities. We’ll try and be clear about the assumptions behind our descriptions below, pending feedback from RightMesh. \"]]],[1,\"p\",[[0,[3],1,\"Target devices\"]]],[1,\"p\",[[0,[],0,\"Althea’s primary goal is to lower the cost of bandwidth for everyone. To that end we’re very focused on home internet right now. While the mobile space is compelling, we’ve chosen to focus on bringing competition to the more stagnant home internet market first. Our software is designed to be run on Linux-based routers connected to \"],[0,[7],1,\"stationary high-bandwidth wifi transmitters\"],[0,[],0,\", or runs of cable and fiber.\"]]],[1,\"p\",[[0,[],0,\"On the other side of this decision is RightMesh. RightMesh has chosen to go all-in on smartphone software. Smartphones are not designed to route large amounts of traffic, so this focus naturally shapes the usage of their system. RightMesh is more about allowing dense swarms of cell phones to extend the range of a wifi hotspot or cell tower, while Althea is about changing the economic model of home and office internet service. A swarm of cell phones will be able to extend the range of a cell tower or wifi hotspot by a few hundred feet, while the high-bandwidth networking hardware Althea is designed for gets the internet connection from a data center to an entire town or city.\"]]],[1,\"p\",[[0,[],0,\"It’s this hardware decision that drives the design differences between RightMesh and Althea. A few examples: Phones do not offer much access to the underlying system, and most of the networking code must be rewritten as comparatively inefficient “userspace” code. Routers typically can be programmed from scratch and offer access to the lower levels of the very high performance networking code in the Linux kernel. Phones have omnidirectional antennas which cannot send signals as far in any particular direction, and in dense areas can interfere with each other. Much of RightMesh’s design deals with this fact, and they are forced to reimplement a lot of core networking code. Althea is designed to run on the kind of focused directional wifi beams, wires and fiber that provide internet service today, and will always be the best option for high bandwidth and low latency. Because of this, we’ve been able to leverage an enormous amount of existing, proven, and very fast networking code.\"]]],[1,\"p\",[[0,[],0,\"However, taking a phone-first approach is exciting, because it could bring access to very remote areas or disaster zones where nobody has had a chance or ability to install networking equipment.\"]]],[1,\"p\",[[0,[3],1,\"Routing security\"]]],[1,\"p\",[[0,[],0,\"RightMesh uses Left’s proprietary mesh protocol. However, there is not a lot of information about how it works. We do know that it is a hop-count based protocol:\"]]],[1,\"p\",[[0,[],0,\"Currently, RightMesh selects routes based on the least hop count path. At launch, it would be updated such that there is equal weight between the fewest hops and lowest cost.\"]]],[1,\"p\",[[0,[],0,\"They intend to one day add other metrics, such as latency, packet loss, etc. However, no details are given about how this will be accomplished.\"]]],[1,\"p\",[[0,[],0,\"In time, this algorithm would become increasingly complex so that performance of the mesh may be fine tuned for individual users where a best path uses a combination of speed, cost, performance, and even reputation of participating nodes.\"]]],[1,\"p\",[[0,[],0,\"To securely use a metric other than hop count, RightMesh will have to add some kind of verification to their routing protocol. We’ve found this to be one of the more important challenges of incentivized mesh networking, but RightMesh has not shown any techniques to do it. We’ll explain in more depth after a bit about Althea’s routing.\"]]],[1,\"p\",[[0,[],0,\"Althea uses a modified version of the Babel routing protocol. You can find a number of papers about Babel performance and design on \"],[0,[8],1,\"Juliusz Chroboczek’s website\"],[0,[],0,\". Babel already supports routing based on packet loss and latency. Babel is also \"],[0,[9],1,\"built to be extended\"],[0,[],0,\". We’re building a \"],[0,[10],1,\"Babel extension\"],[0,[],0,\" to route based on price as well, so at launch, Althea will route packets based on the best combination of price, packet loss, and latency.\"]]],[1,\"p\",[[0,[],0,\"Verification is very important in a decentralized context. Without a trusted entity running the entire network, routers cannot count on their neighbors honestly reporting routing metrics. Althea’s verification works quite simply. To learn the quality of all the routes they can service, routers first run a “link quality estimation” with their immediate neighbors. This tests packet loss and latency of the link. This information is gossiped to the network, and routing tables are built by summing the packet loss and latency of every link on a given route.\"]]],[1,\"p\",[[0,[],0,\"Althea opens encrypted tunnels with destinations that it is sending traffic to. Nodes forwarding this traffic cannot read it. Babel then runs a link quality estimation over this tunnel. If this turns out to be different than what the neighbor forwarding the traffic claims for the route quality, this neighbor is deemed to be somewhat less reliable. If this happens enough, the neighbor is not used to forward traffic any more. Additionally, new neighbors are not used to forward a lot of traffic until they have proven themselves to be reliable.\"]]],[1,\"p\",[[0,[],0,\"RightMesh routes based only on hop count. For hop count, they don’t really need verification, because of the way their payment system works. Their black-box routing protocol chooses routes based on the fewest number of hops, and a smart contract pays all the nodes that can prove they were along a path. The only way to spoof this system would be to generate fake hops in an effort to get a larger proportion of the payment, but then you’d be less likely to be chosen by the routing protocol.\"]]],[1,\"p\",[[0,[],0,\"However, hop count is not a very efficient way to route, because you could be choosing to send packets over routes that have few hops, but high latency or packet loss. If RightMesh chooses to use other metrics, they will need to have some way to verify them like Althea does, which their paper makes no mention of. The only other option would be to lean on the proprietary nature of their routing protocol for “security through obscurity”. Perhaps this is what they are counting on. But if there is money at stake, someone will figure out how to crack it, probably sooner rather than later.\"]]],[1,\"p\",[[0,[3],1,\"Userspace vs kernel implementation\"]]],[1,\"p\",[[0,[],0,\"A machine’s networking code must handle every single packet the machine forwards, which can easily exceed thousands every second. The closer the routing operations are to the bare hardware the faster they can go. The Linux kernel has been honed over decades to eke out every last bit of performance when forwarding packets. It’s this code that Althea leans on. Althea uses Babel to populate the Linux kernel’s routing table, and the in-kernel encryption module Wireguard to handle all encryption. Because of this, machines using Althea will usually be able to forward packets at “line rate”- as fast as the transmission medium can handle them.\"]]],[1,\"p\",[[0,[],0,\"RightMesh is designed to be run on un-rooted phones, and it uses non-standard proprietary routing and network protocols designed for the “smartphone swarm” scenario they envision. Because of this, all packets forwarded by a RightMesh device will have to be copied out of the kernel, and into “userspace”- an area of the OS where regular apps are allowed to run. All this copying means higher latency, and more memory consumption for lower bandwidth forwarding.\"]]],[1,\"p\",[[0,[],0,\"This isn’t necessarily a bad thing though. While a RightMesh device will be limited in speed by the userspace implementation, most phone’s radios can’t handle high speeds anyway. Getting away from the longstanding patterns of traditional networking code will also let them try new techniques possibly better suited to the smartphone networks they are trying to create.\"]]],[1,\"p\",[[0,[],0,\"A third factor in this choice is that while Althea will carry any kind of internet traffic from any app, the RightMesh SDK will need to be integrated into every app that wants to use their mesh networking. This could hamper adoption, but might also let them sell more SDK licenses. \"]]],[1,\"p\",[[0,[3],1,\"Payments\"]]],[1,\"p\",[[0,[],0,\"Both Althea and RightMesh depend on either “super nodes” or “exit nodes” running full Ethereum clients and some mesh specialized software to provide peering for transactions to the blockchain and traffic to the internet. What differs is the amount of operations these elevated nodes are tasked to perform and the amount of reporting to them that is required. \"]]],[1,\"p\",[[0,[],0,\"Althea’s design is based on the principle of \"],[0,[11],1,\"fast payment channels\"],[0,[],0,\" between each hop. Payment for bandwidth is settled before any significant debt can be incurred.. Since the channel payments are so fast and granular, if a node does not pay for service it has received, it can immediately be cut off. This greatly reduces the trust needed in the system.\"]]],[1,\"p\",[[0,[],0,\"New nodes, or previously malicious nodes returning under new identities must work their way up a local trust system starting with very small channel balances and frequent transaction costs. By keeping the maximum cut and run gain smaller than the transaction costs incurred by working up the trust system nodes can be either rationally malicious or irrationally malicious at no great harm to the network.\"]]],[1,\"p\",[[0,[],0,\"Nodes pay each other in a supply chain model, the same as almost anything else that is bought and sold in our society. Alice pays Bob to forward her packets, then Bob pays the next hop slightly less, keeping some of Alice’s payment as profit.\"]]],[1,\"p\",[[0,[],0,\"In RightMesh, all operations of the protocol are on-chain. On any blockchain that exists today, this would make their protocol extremely slow. They introduce the concept of sidechains, which might be able to run their smart contracts more quickly. These sidechains are not specified at all in their paper, but there are several solutions being developed, such as plasma.io and Cosmos. RightMesh will not work until they are finished and deployed.\"]]],[1,\"p\",[[0,[],0,\"Instead of Althea’s supply chain model, RightMesh has sort of an auction model. We’re not going to get into all the ins and outs of this process here, but the important part is that every payment interaction in the protocol is mediated by the blockchain or sidechain. This means that the fastest that any routing decisions can happen is many seconds, if not minutes.\"]]],[1,\"p\",[[0,[],0,\"Because of this, we’ve had to conclude that RightMesh works on kind of a circuit-switched model. Circuit switching is where a single path or set of paths is chosen for a long lived connection. This is the way the old analog telephone system worked. The revolution of the internet was packet switching. Internet routers are able to decide where to send traffic on a packet by packet basis. No central entity needs to know the path that any given packet takes, and any router can choose to send packets on a different route at any time. Also, the request and response packets making up any given connection do not need to take the same path. It’s this fine-grained flexibility that allows the internet to route around damage and congestion without disruption.\"]]],[1,\"p\",[[0,[],0,\"Still, this is probably not an issue for RightMesh’s use case. Supplying internet access from a wifi hotspot to a phone over a few hops does not involve the demands or uptime expectations of a city-level infrastructure network. Their slower, sidechain-mediated model may be sufficient. \"]]],[1,\"p\",[[0,[3],1,\"Conclusions\"]]],[1,\"p\",[[0,[],0,\"We expect to see RightMesh’s protocol change a lot as they try to implement it. They’ll need some kind of route quality verification if they want to route based on anything other than hop count, and they could probably speed up their payments by orders of magnitude with payment channel and state channel concepts. All of Althea’s code is fully open source and permissively licensed, and RightMesh is free to make use of our \"],[0,[10],1,\"Babel extensions\"],[0,[],0,\" and our \"],[0,[12],1,\"state channel\"],[0,[],0,\" and \"],[0,[11],1,\"payment channel\"],[0,[],0,\" libraries.\"]]],[1,\"p\",[[0,[],0,\"RightMesh’s marriage to a secret proprietary routing protocol is more concerning. In designing Althea, we found that the networking side of things is much more difficult than managing payments. There are a lot of exploits possible on routing protocols, because almost all routing protocols have been designed for use on friendly networks managed by one entity.\"]]],[1,\"p\",[[0,[],0,\"Proprietary network protocols historically not  been successful. The Internet is made up of billions of devices made by tens of thousands of manufacturers and it never could have been built without everyone working together on a standard and open protocol. Especially mesh software, based around cooperation, can not be chained to secrecy. Especially not if RightMesh needs viral growth to fuel the valuation of their token.\"]]],[1,\"p\",[[0,[],0,\"Once these issues are overcome, RightMesh will be complementary to Althea. Internet access can be supplied by Althea’s infrastructure-level networks, and distributed to groups of phones with RightMesh.\"]]]]}","html":"<p>We’ve been working on the architecture of Althea for nearly a year now, during that time we’ve made a lot of decisions that define how our network is structured with broad impacts on how it will perform in the real world. This post assumes you have already had a chance to read <a href=\"http://altheamesh.com/documents/whitepaper.pdf\">our paper</a> which contains our design for incentivizing mesh routing with cryptocurrency payments. It leverages existing technology, addresses major security concerns adequately and is expected to run on nearly any device, even off-the-shelf consumer routers.</p>\n\n<p>A few weeks ago <a href=\"https://www.rightmesh.io/\">Rightmesh</a>, a cell phone mesh product, published their <a href=\"https://www.rightmesh.io/wp-content/uploads/2017/07/RightMesh-Technical-Whitepaper1.pdf\">technical paper</a> which provides an interesting alternative architecture with very different focus from our own.</p>\n\n<p>In this post we’ll be comparing our products and contrasting different vulnerabilities, performance, and implementation challenges that come inherent to each product. We will also identify several potential problems in both Althea and the version of RightMesh described in their paper and suggest how they could be addressed.</p>\n\n<p><strong>Principles</strong></p>\n\n<p>This commentary is somewhat limited by the fact that RightMesh publishes has yet to publish any cryptocurrency-related code on their  <a href=\"https://github.com/rightmesh\">Github</a>. Unlike Althea, large components of the RightMesh software stack will be closed source. They will publish the cryptocurrency-related components while using a proprietary mesh networking protocol from their parent company <a href=\"https://left.io/\">Left</a>.</p>\n\n<p>We publish our code as we write it. The <a href=\"https://github.com/althea-mesh\">Althea Github</a> contains all the code we’ve written and everything you need to build the systems we are using from scratch. We are committed to open source. </p>\n\n<p>Regardless of our principles, without open source specifications we have to infer the capabilities of Left’s mesh protocol from off-hand claims made by RightMesh about its capabilities. We’ll try and be clear about the assumptions behind our descriptions below, pending feedback from RightMesh. </p>\n\n<p><strong>Target devices</strong></p>\n\n<p>Althea’s primary goal is to lower the cost of bandwidth for everyone. To that end we’re very focused on home internet right now. While the mobile space is compelling, we’ve chosen to focus on bringing competition to the more stagnant home internet market first. Our software is designed to be run on Linux-based routers connected to <a href=\"https://www.ubnt.com/products/#airfiber\">stationary high-bandwidth wifi transmitters</a>, or runs of cable and fiber.</p>\n\n<p>On the other side of this decision is RightMesh. RightMesh has chosen to go all-in on smartphone software. Smartphones are not designed to route large amounts of traffic, so this focus naturally shapes the usage of their system. RightMesh is more about allowing dense swarms of cell phones to extend the range of a wifi hotspot or cell tower, while Althea is about changing the economic model of home and office internet service. A swarm of cell phones will be able to extend the range of a cell tower or wifi hotspot by a few hundred feet, while the high-bandwidth networking hardware Althea is designed for gets the internet connection from a data center to an entire town or city.</p>\n\n<p>It’s this hardware decision that drives the design differences between RightMesh and Althea. A few examples:\nPhones do not offer much access to the underlying system, and most of the networking code must be rewritten as comparatively inefficient “userspace” code. Routers typically can be programmed from scratch and offer access to the lower levels of the very high performance networking code in the Linux kernel.\nPhones have omnidirectional antennas which cannot send signals as far in any particular direction, and in dense areas can interfere with each other. Much of RightMesh’s design deals with this fact, and they are forced to reimplement a lot of core networking code. Althea is designed to run on the kind of focused directional wifi beams, wires and fiber that provide internet service today, and will always be the best option for high bandwidth and low latency. Because of this, we’ve been able to leverage an enormous amount of existing, proven, and very fast networking code.</p>\n\n<p>However, taking a phone-first approach is exciting, because it could bring access to very remote areas or disaster zones where nobody has had a chance or ability to install networking equipment.</p>\n\n<p><strong>Routing security</strong></p>\n\n<p>RightMesh uses Left’s proprietary mesh protocol. However, there is not a lot of information about how it works. We do know that it is a hop-count based protocol:</p>\n\n<blockquote><p>Currently, RightMesh selects routes based on the least hop count path. At launch, it would be updated such that there is equal weight between the fewest hops and lowest cost.</p></blockquote>\n\n<p>They intend to one day add other metrics, such as latency, packet loss, etc. However, no details are given about how this will be accomplished.</p>\n\n<blockquote><p>In time, this algorithm would become increasingly complex so that performance of the mesh may be fine tuned for individual users where a best path uses a combination of speed, cost, performance, and even reputation of participating nodes.</p></blockquote>\n\n<p>To securely use a metric other than hop count, RightMesh will have to add some kind of verification to their routing protocol. We’ve found this to be one of the more important challenges of incentivized mesh networking, but RightMesh has not shown any techniques to do it. We’ll explain in more depth after a bit about Althea’s routing.</p>\n\n<p>Althea uses a modified version of the Babel routing protocol. You can find a number of papers about Babel performance and design on <a href=\"https://www.irif.fr/~jch/software/babel/\">Juliusz Chroboczek’s website</a>. Babel already supports routing based on packet loss and latency. Babel is also <a href=\"https://tools.ietf.org/html/rfc7557\">built to be extended</a>. We’re building a <a href=\"https://github.com/althea-mesh/babeld\">Babel extension</a> to route based on price as well, so at launch, Althea will route packets based on the best combination of price, packet loss, and latency.</p>\n\n<p>Verification is very important in a decentralized context. Without a trusted entity running the entire network, routers cannot count on their neighbors honestly reporting routing metrics. Althea’s verification works quite simply. To learn the quality of all the routes they can service, routers first run a “link quality estimation” with their immediate neighbors. This tests packet loss and latency of the link. This information is gossiped to the network, and routing tables are built by summing the packet loss and latency of every link on a given route.</p>\n\n<p>Althea opens encrypted tunnels with destinations that it is sending traffic to. Nodes forwarding this traffic cannot read it. Babel then runs a link quality estimation over this tunnel. If this turns out to be different than what the neighbor forwarding the traffic claims for the route quality, this neighbor is deemed to be somewhat less reliable. If this happens enough, the neighbor is not used to forward traffic any more. Additionally, new neighbors are not used to forward a lot of traffic until they have proven themselves to be reliable.</p>\n\n<p>RightMesh routes based only on hop count. For hop count, they don’t really need verification, because of the way their payment system works. Their black-box routing protocol chooses routes based on the fewest number of hops, and a smart contract pays all the nodes that can prove they were along a path. The only way to spoof this system would be to generate fake hops in an effort to get a larger proportion of the payment, but then you’d be less likely to be chosen by the routing protocol.</p>\n\n<p>However, hop count is not a very efficient way to route, because you could be choosing to send packets over routes that have few hops, but high latency or packet loss. If RightMesh chooses to use other metrics, they will need to have some way to verify them like Althea does, which their paper makes no mention of. The only other option would be to lean on the proprietary nature of their routing protocol for “security through obscurity”. Perhaps this is what they are counting on. But if there is money at stake, someone will figure out how to crack it, probably sooner rather than later.</p>\n\n<p><strong>Userspace vs kernel implementation</strong></p>\n\n<p>A machine’s networking code must handle every single packet the machine forwards, which can easily exceed thousands every second. The closer the routing operations are to the bare hardware the faster they can go. The Linux kernel has been honed over decades to eke out every last bit of performance when forwarding packets. It’s this code that Althea leans on. Althea uses Babel to populate the Linux kernel’s routing table, and the in-kernel encryption module Wireguard to handle all encryption. Because of this, machines using Althea will usually be able to forward packets at “line rate”- as fast as the transmission medium can handle them.</p>\n\n<p>RightMesh is designed to be run on un-rooted phones, and it uses non-standard proprietary routing and network protocols designed for the “smartphone swarm” scenario they envision. Because of this, all packets forwarded by a RightMesh device will have to be copied out of the kernel, and into “userspace”- an area of the OS where regular apps are allowed to run. All this copying means higher latency, and more memory consumption for lower bandwidth forwarding.</p>\n\n<p>This isn’t necessarily a bad thing though. While a RightMesh device will be limited in speed by the userspace implementation, most phone’s radios can’t handle high speeds anyway. Getting away from the longstanding patterns of traditional networking code will also let them try new techniques possibly better suited to the smartphone networks they are trying to create.</p>\n\n<p>A third factor in this choice is that while Althea will carry any kind of internet traffic from any app, the RightMesh SDK will need to be integrated into every app that wants to use their mesh networking. This could hamper adoption, but might also let them sell more SDK licenses. </p>\n\n<p><strong>Payments</strong></p>\n\n<p>Both Althea and RightMesh depend on either “super nodes” or “exit nodes” running full Ethereum clients and some mesh specialized software to provide peering for transactions to the blockchain and traffic to the internet. What differs is the amount of operations these elevated nodes are tasked to perform and the amount of reporting to them that is required. </p>\n\n<p>Althea’s design is based on the principle of <a href=\"http://altheamesh.com/blog/altheas-multihop-payment-channels/\">fast payment channels</a> between each hop. Payment for bandwidth is settled before any significant debt can be incurred.. Since the channel payments are so fast and granular, if a node does not pay for service it has received, it can immediately be cut off. This greatly reduces the trust needed in the system.</p>\n\n<p>New nodes, or previously malicious nodes returning under new identities must work their way up a local trust system starting with very small channel balances and frequent transaction costs. By keeping the maximum cut and run gain smaller than the transaction costs incurred by working up the trust system nodes can be either rationally malicious or irrationally malicious at no great harm to the network.</p>\n\n<p>Nodes pay each other in a supply chain model, the same as almost anything else that is bought and sold in our society. Alice pays Bob to forward her packets, then Bob pays the next hop slightly less, keeping some of Alice’s payment as profit.</p>\n\n<p>In RightMesh, all operations of the protocol are on-chain. On any blockchain that exists today, this would make their protocol extremely slow. They introduce the concept of sidechains, which might be able to run their smart contracts more quickly. These sidechains are not specified at all in their paper, but there are several solutions being developed, such as plasma.io and Cosmos. RightMesh will not work until they are finished and deployed.</p>\n\n<p>Instead of Althea’s supply chain model, RightMesh has sort of an auction model. We’re not going to get into all the ins and outs of this process here, but the important part is that every payment interaction in the protocol is mediated by the blockchain or sidechain. This means that the fastest that any routing decisions can happen is many seconds, if not minutes.</p>\n\n<p>Because of this, we’ve had to conclude that RightMesh works on kind of a circuit-switched model. Circuit switching is where a single path or set of paths is chosen for a long lived connection. This is the way the old analog telephone system worked. The revolution of the internet was packet switching. Internet routers are able to decide where to send traffic on a packet by packet basis. No central entity needs to know the path that any given packet takes, and any router can choose to send packets on a different route at any time. Also, the request and response packets making up any given connection do not need to take the same path. It’s this fine-grained flexibility that allows the internet to route around damage and congestion without disruption.</p>\n\n<p>Still, this is probably not an issue for RightMesh’s use case. Supplying internet access from a wifi hotspot to a phone over a few hops does not involve the demands or uptime expectations of a city-level infrastructure network. Their slower, sidechain-mediated model may be sufficient. </p>\n\n<p><strong>Conclusions</strong></p>\n\n<p>We expect to see RightMesh’s protocol change a lot as they try to implement it. They’ll need some kind of route quality verification if they want to route based on anything other than hop count, and they could probably speed up their payments by orders of magnitude with payment channel and state channel concepts. All of Althea’s code is fully open source and permissively licensed, and RightMesh is free to make use of our <a href=\"https://github.com/althea-mesh/babeld\">Babel extensions</a> and our <a href=\"https://github.com/jtremback/avocado\">state channel</a> and <a href=\"http://altheamesh.com/blog/altheas-multihop-payment-channels/\">payment channel</a> libraries.</p>\n\n<p>RightMesh’s marriage to a secret proprietary routing protocol is more concerning. In designing Althea, we found that the networking side of things is much more difficult than managing payments. There are a lot of exploits possible on routing protocols, because almost all routing protocols have been designed for use on friendly networks managed by one entity.</p>\n\n<p>Proprietary network protocols historically not  been successful. The Internet is made up of billions of devices made by tens of thousands of manufacturers and it never could have been built without everyone working together on a standard and open protocol. Especially mesh software, based around cooperation, can not be chained to secrecy. Especially not if RightMesh needs viral growth to fuel the valuation of their token.</p>\n\n<p>Once these issues are overcome, RightMesh will be complementary to Althea. Internet access can be supplied by Althea’s infrastructure-level networks, and distributed to groups of phones with RightMesh.</p>","comment_id":null,"plaintext":"We’ve been working on the architecture of Althea for nearly a year now, during that time we’ve made a lot of decisions that define how our network is structured with broad impacts on how it will perform in the real world. This post assumes you have already had a chance to read [our paper](http://altheamesh.com/documents/whitepaper.pdf) which contains our design for incentivizing mesh routing with cryptocurrency payments. It leverages existing technology, addresses major security concerns adequately and is expected to run on nearly any device, even off-the-shelf consumer routers.\n\nA few weeks ago [Rightmesh](https://www.rightmesh.io/), a cell phone mesh product, published their [technical paper](https://www.rightmesh.io/wp-content/uploads/2017/07/RightMesh-Technical-Whitepaper1.pdf) which provides an interesting alternative architecture with very different focus from our own.\n\nIn this post we’ll be comparing our products and contrasting different vulnerabilities, performance, and implementation challenges that come inherent to each product. We will also identify several potential problems in both Althea and the version of RightMesh described in their paper and suggest how they could be addressed.\n\n**Principles**\n\nThis commentary is somewhat limited by the fact that RightMesh publishes has yet to publish any cryptocurrency-related code on their  [Github](https://github.com/rightmesh). Unlike Althea, large components of the RightMesh software stack will be closed source. They will publish the cryptocurrency-related components while using a proprietary mesh networking protocol from their parent company [Left](https://left.io/).\n\nWe publish our code as we write it. The [Althea Github](https://github.com/althea-mesh) contains all the code we’ve written and everything you need to build the systems we are using from scratch. We are committed to open source. \n\nRegardless of our principles, without open source specifications we have to infer the capabilities of Left’s mesh protocol from off-hand claims made by RightMesh about its capabilities. We’ll try and be clear about the assumptions behind our descriptions below, pending feedback from RightMesh. \n\n**Target devices**\n\nAlthea’s primary goal is to lower the cost of bandwidth for everyone. To that end we’re very focused on home internet right now. While the mobile space is compelling, we’ve chosen to focus on bringing competition to the more stagnant home internet market first. Our software is designed to be run on Linux-based routers connected to [stationary high-bandwidth wifi transmitters](https://www.ubnt.com/products/#airfiber), or runs of cable and fiber.\n\nOn the other side of this decision is RightMesh. RightMesh has chosen to go all-in on smartphone software. Smartphones are not designed to route large amounts of traffic, so this focus naturally shapes the usage of their system. RightMesh is more about allowing dense swarms of cell phones to extend the range of a wifi hotspot or cell tower, while Althea is about changing the economic model of home and office internet service. A swarm of cell phones will be able to extend the range of a cell tower or wifi hotspot by a few hundred feet, while the high-bandwidth networking hardware Althea is designed for gets the internet connection from a data center to an entire town or city.\n\nIt’s this hardware decision that drives the design differences between RightMesh and Althea. A few examples:\nPhones do not offer much access to the underlying system, and most of the networking code must be rewritten as comparatively inefficient “userspace” code. Routers typically can be programmed from scratch and offer access to the lower levels of the very high performance networking code in the Linux kernel.\nPhones have omnidirectional antennas which cannot send signals as far in any particular direction, and in dense areas can interfere with each other. Much of RightMesh’s design deals with this fact, and they are forced to reimplement a lot of core networking code. Althea is designed to run on the kind of focused directional wifi beams, wires and fiber that provide internet service today, and will always be the best option for high bandwidth and low latency. Because of this, we’ve been able to leverage an enormous amount of existing, proven, and very fast networking code.\n\nHowever, taking a phone-first approach is exciting, because it could bring access to very remote areas or disaster zones where nobody has had a chance or ability to install networking equipment.\n\n**Routing security**\n\nRightMesh uses Left’s proprietary mesh protocol. However, there is not a lot of information about how it works. We do know that it is a hop-count based protocol:\n\n> Currently, RightMesh selects routes based on the least hop count path. At launch, it would be updated such that there is equal weight between the fewest hops and lowest cost.\n\nThey intend to one day add other metrics, such as latency, packet loss, etc. However, no details are given about how this will be accomplished.\n\n> In time, this algorithm would become increasingly complex so that performance of the mesh may be fine tuned for individual users where a best path uses a combination of speed, cost, performance, and even reputation of participating nodes.\n\nTo securely use a metric other than hop count, RightMesh will have to add some kind of verification to their routing protocol. We’ve found this to be one of the more important challenges of incentivized mesh networking, but RightMesh has not shown any techniques to do it. We’ll explain in more depth after a bit about Althea’s routing.\n\nAlthea uses a modified version of the Babel routing protocol. You can find a number of papers about Babel performance and design on [Juliusz Chroboczek’s website](https://www.irif.fr/~jch/software/babel/). Babel already supports routing based on packet loss and latency. Babel is also [built to be extended](https://tools.ietf.org/html/rfc7557). We’re building a [Babel extension](https://github.com/althea-mesh/babeld) to route based on price as well, so at launch, Althea will route packets based on the best combination of price, packet loss, and latency.\n\nVerification is very important in a decentralized context. Without a trusted entity running the entire network, routers cannot count on their neighbors honestly reporting routing metrics. Althea’s verification works quite simply. To learn the quality of all the routes they can service, routers first run a “link quality estimation” with their immediate neighbors. This tests packet loss and latency of the link. This information is gossiped to the network, and routing tables are built by summing the packet loss and latency of every link on a given route.\n\nAlthea opens encrypted tunnels with destinations that it is sending traffic to. Nodes forwarding this traffic cannot read it. Babel then runs a link quality estimation over this tunnel. If this turns out to be different than what the neighbor forwarding the traffic claims for the route quality, this neighbor is deemed to be somewhat less reliable. If this happens enough, the neighbor is not used to forward traffic any more. Additionally, new neighbors are not used to forward a lot of traffic until they have proven themselves to be reliable.\n\nRightMesh routes based only on hop count. For hop count, they don’t really need verification, because of the way their payment system works. Their black-box routing protocol chooses routes based on the fewest number of hops, and a smart contract pays all the nodes that can prove they were along a path. The only way to spoof this system would be to generate fake hops in an effort to get a larger proportion of the payment, but then you’d be less likely to be chosen by the routing protocol.\n\nHowever, hop count is not a very efficient way to route, because you could be choosing to send packets over routes that have few hops, but high latency or packet loss. If RightMesh chooses to use other metrics, they will need to have some way to verify them like Althea does, which their paper makes no mention of. The only other option would be to lean on the proprietary nature of their routing protocol for “security through obscurity”. Perhaps this is what they are counting on. But if there is money at stake, someone will figure out how to crack it, probably sooner rather than later.\n\n\n\n**Userspace vs kernel implementation**\n\nA machine’s networking code must handle every single packet the machine forwards, which can easily exceed thousands every second. The closer the routing operations are to the bare hardware the faster they can go. The Linux kernel has been honed over decades to eke out every last bit of performance when forwarding packets. It’s this code that Althea leans on. Althea uses Babel to populate the Linux kernel’s routing table, and the in-kernel encryption module Wireguard to handle all encryption. Because of this, machines using Althea will usually be able to forward packets at “line rate”- as fast as the transmission medium can handle them.\n\nRightMesh is designed to be run on un-rooted phones, and it uses non-standard proprietary routing and network protocols designed for the “smartphone swarm” scenario they envision. Because of this, all packets forwarded by a RightMesh device will have to be copied out of the kernel, and into “userspace”- an area of the OS where regular apps are allowed to run. All this copying means higher latency, and more memory consumption for lower bandwidth forwarding.\n\nThis isn’t necessarily a bad thing though. While a RightMesh device will be limited in speed by the userspace implementation, most phone’s radios can’t handle high speeds anyway. Getting away from the longstanding patterns of traditional networking code will also let them try new techniques possibly better suited to the smartphone networks they are trying to create.\n\nA third factor in this choice is that while Althea will carry any kind of internet traffic from any app, the RightMesh SDK will need to be integrated into every app that wants to use their mesh networking. This could hamper adoption, but might also let them sell more SDK licenses. \n\n\n\n**Payments**\n\nBoth Althea and RightMesh depend on either “super nodes” or “exit nodes” running full Ethereum clients and some mesh specialized software to provide peering for transactions to the blockchain and traffic to the internet. What differs is the amount of operations these elevated nodes are tasked to perform and the amount of reporting to them that is required. \n\nAlthea’s design is based on the principle of [fast payment channels](http://altheamesh.com/blog/altheas-multihop-payment-channels/) between each hop. Payment for bandwidth is settled before any significant debt can be incurred.. Since the channel payments are so fast and granular, if a node does not pay for service it has received, it can immediately be cut off. This greatly reduces the trust needed in the system.\n\nNew nodes, or previously malicious nodes returning under new identities must work their way up a local trust system starting with very small channel balances and frequent transaction costs. By keeping the maximum cut and run gain smaller than the transaction costs incurred by working up the trust system nodes can be either rationally malicious or irrationally malicious at no great harm to the network.\n\nNodes pay each other in a supply chain model, the same as almost anything else that is bought and sold in our society. Alice pays Bob to forward her packets, then Bob pays the next hop slightly less, keeping some of Alice’s payment as profit.\n\nIn RightMesh, all operations of the protocol are on-chain. On any blockchain that exists today, this would make their protocol extremely slow. They introduce the concept of sidechains, which might be able to run their smart contracts more quickly. These sidechains are not specified at all in their paper, but there are several solutions being developed, such as plasma.io and Cosmos. RightMesh will not work until they are finished and deployed.\n\nInstead of Althea’s supply chain model, RightMesh has sort of an auction model. We’re not going to get into all the ins and outs of this process here, but the important part is that every payment interaction in the protocol is mediated by the blockchain or sidechain. This means that the fastest that any routing decisions can happen is many seconds, if not minutes.\n\nBecause of this, we’ve had to conclude that RightMesh works on kind of a circuit-switched model. Circuit switching is where a single path or set of paths is chosen for a long lived connection. This is the way the old analog telephone system worked. The revolution of the internet was packet switching. Internet routers are able to decide where to send traffic on a packet by packet basis. No central entity needs to know the path that any given packet takes, and any router can choose to send packets on a different route at any time. Also, the request and response packets making up any given connection do not need to take the same path. It’s this fine-grained flexibility that allows the internet to route around damage and congestion without disruption.\n\nStill, this is probably not an issue for RightMesh’s use case. Supplying internet access from a wifi hotspot to a phone over a few hops does not involve the demands or uptime expectations of a city-level infrastructure network. Their slower, sidechain-mediated model may be sufficient. \n\n\n\n\n**Conclusions**\n\nWe expect to see RightMesh’s protocol change a lot as they try to implement it. They’ll need some kind of route quality verification if they want to route based on anything other than hop count, and they could probably speed up their payments by orders of magnitude with payment channel and state channel concepts. All of Althea’s code is fully open source and permissively licensed, and RightMesh is free to make use of our [Babel extensions](https://github.com/althea-mesh/babeld) and our [state channel](https://github.com/jtremback/avocado) and [payment channel](http://altheamesh.com/blog/altheas-multihop-payment-channels/) libraries.\n\nRightMesh’s marriage to a secret proprietary routing protocol is more concerning. In designing Althea, we found that the networking side of things is much more difficult than managing payments. There are a lot of exploits possible on routing protocols, because almost all routing protocols have been designed for use on friendly networks managed by one entity.\n\nProprietary network protocols historically not  been successful. The Internet is made up of billions of devices made by tens of thousands of manufacturers and it never could have been built without everyone working together on a standard and open protocol. Especially mesh software, based around cooperation, can not be chained to secrecy. Especially not if RightMesh needs viral growth to fuel the valuation of their token.\n\nOnce these issues are overcome, RightMesh will be complementary to Althea. Internet access can be supplied by Althea’s infrastructure-level networks, and distributed to groups of phones with RightMesh.\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-10-14 00:00:00","created_by":"1","updated_at":"2017-10-14 00:00:00","updated_by":"1","published_at":"2017-10-14 00:00:00","published_by":"1","custom_excerpt":"Althea has made many careful design decisions to optimize performance and reduce overhead. In this post we compare Althea to a different incentivized mesh architecture and show how each of these choices impacts the final product.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc761","uuid":"aa8ed33b-ead5-4e48-8836-a2cdceb0d6bf","title":"Live demo video","slug":"live-demo","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"We’ve been hard at work getting our hardware demo polished. It consists of 10 Raspberry Pi’s, running our extension to the Babel routing protocol that lets it route according to price as well as quality. They also have an interface allowing the user to select how much to charge per gigabyte forwarded, and tallying up how much the user has made. When they are all turned on, they create a real live incentivized mesh network. By giving them out to people at talks and events, they can experience what it’s like to participate and compete in an incentivized mesh network. Lower your prices, and you’ll get more traffic. Lower them too much, and you won’t make as much money.\"]]],[1,\"p\",[[0,[],0,\"Check out the video:\"]]],[1,\"p\",[[0,[],0,\"<iframe width=\\\"560\\\" height=\\\"315\\\" src=\\\"https://www.youtube.com/embed/IyFEYEcHJyA?rel=0\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>\"]]]]}","html":"<p>We’ve been hard at work getting our hardware demo polished. It consists of 10 Raspberry Pi’s, running our extension to the Babel routing protocol that lets it route according to price as well as quality. They also have an interface allowing the user to select how much to charge per gigabyte forwarded, and tallying up how much the user has made. When they are all turned on, they create a real live incentivized mesh network. By giving them out to people at talks and events, they can experience what it’s like to participate and compete in an incentivized mesh network. Lower your prices, and you’ll get more traffic. Lower them too much, and you won’t make as much money.</p>\n\n<p>Check out the video:</p>\n\n<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/IyFEYEcHJyA?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</p>","comment_id":null,"plaintext":"We’ve been hard at work getting our hardware demo polished. It consists of 10 Raspberry Pi’s, running our extension to the Babel routing protocol that lets it route according to price as well as quality. They also have an interface allowing the user to select how much to charge per gigabyte forwarded, and tallying up how much the user has made. When they are all turned on, they create a real live incentivized mesh network. By giving them out to people at talks and events, they can experience what it’s like to participate and compete in an incentivized mesh network. Lower your prices, and you’ll get more traffic. Lower them too much, and you won’t make as much money.\n\nCheck out the video:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IyFEYEcHJyA?rel=0\" frameborder=\"0\" allowfullscreen></iframe>\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-10-06 00:00:00","created_by":"1","updated_at":"2017-10-06 00:00:00","updated_by":"1","published_at":"2017-10-06 00:00:00","published_by":"1","custom_excerpt":"We’ve been hard at work getting our hardware demo polished. It consists of 10 Raspberry Pi’s, running our extension to the Babel routing protocol that lets it route according to price as well as quality.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc762","uuid":"6789ec07-e616-4d3f-a502-e60b2defc448","title":"Scrooge development: Running code","slug":"dev-update-3","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://github.com/incentivized-mesh-infrastructure/scrooge\"]],[\"a\",[\"href\",\"/blog/dev-update-2/\"]],[\"code\"],[\"a\",[\"href\",\"/blog/using-core-for-network-simulation/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"I've been focusing my efforts on \"],[0,[0],1,\"Scrooge\"],[0,[],0,\", a piece of software that will implement the tunnel-based traffic control scheme I've written about \"],[0,[1],1,\"here\"],[0,[],0,\". To recap, I'm trying to build somethign that:\"]]],[3,\"ul\",[[[0,[],0,\"Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.\"]],[[0,[],0,\"Blocks packets that have not come over one of the authenticated tunnels from being forwarded.\"]],[[0,[],0,\"Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I'll just pass it in manually.\"]],[[0,[],0,\"Allows nodes to choose what proportion of their total bandwidth they will share/sell.\"]]]],[1,\"p\",[[0,[],0,\"In the previous post, I wrote about doing this with shell scripts. These were fast and easy to write, and a good way to test the technique. Now I am working on doing the same thing with a robust, configurable, and well-tested piece of software that does not rely on manual tweaking.\"]]],[1,\"p\",[[0,[],0,\"I've been writing it in Go. The first thing that needs to be done is discovery. Neighbors must be able to establish an initial contact with one another. I've been doing this by sending UDP packets to a specific port on the IPv6 multicast address. Nodes send \\\"hello\\\" messages on this port. The hello messages contain the node's public key and \\\"control address\\\", where messages can be sent to communicate with the node.\"]]],[1,\"h3\",[[0,[],0,\"Scrooge hello message\"]]],[1,\"p\",[[0,[],0,\"This is sent on the multicast port to discover neighbors. It can also be sent directly to a neighbor to notify them of an update of the control address. \"]]],[1,\"p\",[[0,[2],1,\"scrooge_hello <publicKey> <control address> <seq num> <signature>\"]]],[3,\"ul\",[[[0,[],0,\"PublicKey: base64 encoded ed25519 public key. This is used by neighbors to identify each other and sign messages, including the \"],[0,[2],1,\"scrooge_hello\"],[0,[],0,\" message.\"]],[[0,[],0,\"Control address: The IP address and port where one can send out of band control information.\"]],[[0,[],0,\"Sequence number: Incremented with each hello to prevent playback attacks\"]],[[0,[],0,\"Signature: The signature of the publicKey over the fields of this message, concatenated as byte strings with no spaces (we may want to tweak this?)\"]]]],[1,\"p\",[[0,[],0,\"When a node receives one of these messages:  - It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key).  - It checks the SeqNum to prevent replay attack. - It updates the ControlAddress of the neighbor with the given PublicKey. - It sends a \"],[0,[2],1,\"scrooge_hello_confirm\"],[0,[],0,\" message to the neighbor’s control address\"]]],[1,\"h3\",[[0,[],0,\"Scrooge hello confirm message\"]]],[1,\"p\",[[0,[2],1,\"scrooge_hello_confirm <publicKey> <control address> <seq num> <signature>\"]]],[1,\"p\",[[0,[],0,\"When a node receives one of these messages:  - It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key).  - It checks the SeqNum to prevent replay attack. - It updates the ControlAddress of the neighbor with the given PublicKey. - It may start a tunnel and send a scrooge tunnel message as described below.\"]]],[1,\"h3\",[[0,[],0,\"Scrooge tunnel message\"]]],[1,\"p\",[[0,[],0,\"Sometimes a node wants to establish a tunnel with one of its neighbor nodes. Maybe it has just received a hello_confirm from this neighbor after it has broadcasted a hello, or maybe it needs to refresh the tunnel for some reason.\"]]],[3,\"ul\",[[[0,[],0,\"It first stops and removes any existing tunnel with the neighbor. \"]],[[0,[],0,\"It then starts a new tunnel on an available port and sends the message.\"]]]],[1,\"p\",[[0,[2],1,\"scrooge_tunnel <publicKey> <tunnel publicKey> <tunnel endpoint> <seq num> <signature>\"]]],[1,\"p\",[[0,[],0,\"When a node receives this message, - It adds the tunnel publicKey and endpoint to the tunnel record for that node and starts a tunnel listening on an available port. - It then sends a \"],[0,[2],1,\"scrooge_tunnel_confirm\"],[0,[],0,\" message back.\"]]],[1,\"h3\",[[0,[],0,\"Scrooge tunnel confirm message\"]]],[1,\"p\",[[0,[2],1,\"scrooge_tunnel_confirm <publicKey> <tunnel publicKey> <tunnel endpoint> <seq num> <signature>\"]]],[1,\"p\",[[0,[],0,\"This is the same as the \"],[0,[2],1,\"scrooge_tunnel\"],[0,[],0,\" message, except that when a node receives it, it does not send a message back. This is to stop an infinite loop of \"],[0,[2],1,\"scrooge_tunnel\"],[0,[],0,\" messages from occurring.\"]]],[1,\"p\",[[0,[],0,\"The parsing and handling of these messages is all unit tested, and I'm currently working on integration tests, running in \"],[0,[3],1,\"CORE\"],[0,[],0,\". \"]]]]}","html":"<p>I&#39;ve been focusing my efforts on <a href=\"https://github.com/incentivized-mesh-infrastructure/scrooge\">Scrooge</a>, a piece of software that will implement the tunnel-based traffic control scheme I&#39;ve written about <a href=\"/blog/dev-update-2/\">here</a>. To recap, I&#39;m trying to build somethign that:</p>\n\n<blockquote><ul><li>Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.</li><li>Blocks packets that have not come over one of the authenticated tunnels from being forwarded.</li><li>Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I&#39;ll just pass it in manually.</li><li>Allows nodes to choose what proportion of their total bandwidth they will share/sell.</li></ul></blockquote>\n\n<p>In the previous post, I wrote about doing this with shell scripts. These were fast and easy to write, and a good way to test the technique. Now I am working on doing the same thing with a robust, configurable, and well-tested piece of software that does not rely on manual tweaking.</p>\n\n<p>I&#39;ve been writing it in Go. The first thing that needs to be done is discovery. Neighbors must be able to establish an initial contact with one another. I&#39;ve been doing this by sending UDP packets to a specific port on the IPv6 multicast address. Nodes send &quot;hello&quot; messages on this port. The hello messages contain the node&#39;s public key and &quot;control address&quot;, where messages can be sent to communicate with the node.</p>\n\n<h3>Scrooge hello message</h3>\n\n<p>This is sent on the multicast port to discover neighbors. It can also be sent directly to a neighbor to notify them of an update of the control address. </p>\n\n<p><code>scrooge_hello &lt;publicKey&gt; &lt;control address&gt; &lt;seq num&gt; &lt;signature&gt;</code></p>\n\n<ul><li>PublicKey: base64 encoded ed25519 public key. This is used by neighbors to identify each other and sign messages, including the <code>scrooge_hello</code> message.</li><li>Control address: The IP address and port where one can send out of band control information.</li><li>Sequence number: Incremented with each hello to prevent playback attacks</li><li>Signature: The signature of the publicKey over the fields of this message, concatenated as byte strings with no spaces (we may want to tweak this?)</li></ul>\n\n<p>When a node receives one of these messages: \n- It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key). \n- It checks the SeqNum to prevent replay attack.\n- It updates the ControlAddress of the neighbor with the given PublicKey.\n- It sends a <code>scrooge_hello_confirm</code> message to the neighbor’s control address</p>\n\n<h3>Scrooge hello confirm message</h3>\n\n<p><code>scrooge_hello_confirm &lt;publicKey&gt; &lt;control address&gt; &lt;seq num&gt; &lt;signature&gt;</code></p>\n\n<p>When a node receives one of these messages: \n- It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key). \n- It checks the SeqNum to prevent replay attack.\n- It updates the ControlAddress of the neighbor with the given PublicKey.\n- It may start a tunnel and send a scrooge tunnel message as described below.</p>\n\n<h3>Scrooge tunnel message</h3>\n\n<p>Sometimes a node wants to establish a tunnel with one of its neighbor nodes. Maybe it has just received a hello_confirm from this neighbor after it has broadcasted a hello, or maybe it needs to refresh the tunnel for some reason.</p>\n\n<ul><li>It first stops and removes any existing tunnel with the neighbor. </li><li>It then starts a new tunnel on an available port and sends the message.</li></ul>\n\n<p><code>scrooge_tunnel &lt;publicKey&gt; &lt;tunnel publicKey&gt; &lt;tunnel endpoint&gt; &lt;seq num&gt; &lt;signature&gt;</code></p>\n\n<p>When a node receives this message,\n- It adds the tunnel publicKey and endpoint to the tunnel record for that node and starts a tunnel listening on an available port.\n- It then sends a <code>scrooge_tunnel_confirm</code> message back.</p>\n\n<h3>Scrooge tunnel confirm message</h3>\n\n<p><code>scrooge_tunnel_confirm &lt;publicKey&gt; &lt;tunnel publicKey&gt; &lt;tunnel endpoint&gt; &lt;seq num&gt; &lt;signature&gt;</code></p>\n\n<p>This is the same as the <code>scrooge_tunnel</code> message, except that when a node receives it, it does not send a message back. This is to stop an infinite loop of <code>scrooge_tunnel</code> messages from occurring.</p>\n\n<p>The parsing and handling of these messages is all unit tested, and I&#39;m currently working on integration tests, running in <a href=\"/blog/using-core-for-network-simulation/\">CORE</a>. </p>","comment_id":null,"plaintext":"I've been focusing my efforts on [Scrooge](https://github.com/incentivized-mesh-infrastructure/scrooge), a piece of software that will implement the tunnel-based traffic control scheme I've written about [here](/blog/dev-update-2/). To recap, I'm trying to build somethign that:\n\n> - Establishes authenticated tunnels with each of its neighbors. This is so that nodes can reliably tell each others traffic apart. Simply relying on MAC addresses would allow any node to spoof the traffic of another node to get free service.\n> - Blocks packets that have not come over one of the authenticated tunnels from being forwarded.\n> - Prioritizes traffic from some neighbors more highly than others. This will ultimately be linked to payment, but for now I'll just pass it in manually.\n> - Allows nodes to choose what proportion of their total bandwidth they will share/sell.\n\nIn the previous post, I wrote about doing this with shell scripts. These were fast and easy to write, and a good way to test the technique. Now I am working on doing the same thing with a robust, configurable, and well-tested piece of software that does not rely on manual tweaking.\n\nI've been writing it in Go. The first thing that needs to be done is discovery. Neighbors must be able to establish an initial contact with one another. I've been doing this by sending UDP packets to a specific port on the IPv6 multicast address. Nodes send \"hello\" messages on this port. The hello messages contain the node's public key and \"control address\", where messages can be sent to communicate with the node.\n\n### Scrooge hello message\n\nThis is sent on the multicast port to discover neighbors. It can also be sent directly to a neighbor to notify them of an update of the control address. \n\n`scrooge_hello <publicKey> <control address> <seq num> <signature>`\n\n- PublicKey: base64 encoded ed25519 public key. This is used by neighbors to identify each other and sign messages, including the `scrooge_hello` message.\n- Control address: The IP address and port where one can send out of band control information.\n- Sequence number: Incremented with each hello to prevent playback attacks\n- Signature: The signature of the publicKey over the fields of this message, concatenated as byte strings with no spaces (we may want to tweak this?)\n\nWhen a node receives one of these messages: \n- It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key). \n- It checks the SeqNum to prevent replay attack.\n- It updates the ControlAddress of the neighbor with the given PublicKey.\n- It sends a `scrooge_hello_confirm` message to the neighbor’s control address\n\n### Scrooge hello confirm message\n`scrooge_hello_confirm <publicKey> <control address> <seq num> <signature>`\n\nWhen a node receives one of these messages: \n- It first checks the signature, and adds a record of this Neighbor if it does not already exist (neighbors are identified by public key). \n- It checks the SeqNum to prevent replay attack.\n- It updates the ControlAddress of the neighbor with the given PublicKey.\n- It may start a tunnel and send a scrooge tunnel message as described below.\n\n### Scrooge tunnel message\n\nSometimes a node wants to establish a tunnel with one of its neighbor nodes. Maybe it has just received a hello_confirm from this neighbor after it has broadcasted a hello, or maybe it needs to refresh the tunnel for some reason.\n\n- It first stops and removes any existing tunnel with the neighbor. \n- It then starts a new tunnel on an available port and sends the message.\n\n`scrooge_tunnel <publicKey> <tunnel publicKey> <tunnel endpoint> <seq num> <signature>`\n\nWhen a node receives this message,\n- It adds the tunnel publicKey and endpoint to the tunnel record for that node and starts a tunnel listening on an available port.\n- It then sends a `scrooge_tunnel_confirm` message back.\n\n### Scrooge tunnel confirm message\n\n`scrooge_tunnel_confirm <publicKey> <tunnel publicKey> <tunnel endpoint> <seq num> <signature>`\n\nThis is the same as the `scrooge_tunnel` message, except that when a node receives it, it does not send a message back. This is to stop an infinite loop of `scrooge_tunnel` messages from occurring.\n\nThe parsing and handling of these messages is all unit tested, and I'm currently working on integration tests, running in [CORE](/blog/using-core-for-network-simulation/). \n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-02-10 00:00:00","created_by":"1","updated_at":"2017-02-10 00:00:00","updated_by":"1","published_at":"2017-02-10 00:00:00","published_by":"1","custom_excerpt":"I've been focusing my efforts on Scrooge, a piece of software that will implement the tunnel-based traffic control scheme I've written about previously.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc763","uuid":"78c1e86f-9b0a-4c17-9ce9-144291877d4e","title":"Pay for forward v.s. pay for internet","slug":"pay-for-forward-vs-pay-for-internet","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"http://altheamesh.com/blog/althea-paper/\"]],[\"a\",[\"href\",\"https://www.reddit.com/r/hocnet/\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"We've considered two main mechanisms for an incentivized mesh network so far. Pay for forward is the mechanism laid out in \"],[0,[0],1,\"Althea v1\"],[0,[],0,\", and \"],[0,[1],1,\"Hocnet\"],[0,[],0,\". Pay for internet is something I've been working on as Althea v2 and it is also kind of how ISPs work now. This is a brief summary of both approaches.\"]]],[1,\"h2\",[[0,[],0,\"Pay for forward\"]]],[3,\"ul\",[[[0,[],0,\"A (secured) routing protocol propagates price along with the route quality metric.The routing protocol makes routing decisions based on the price and the metric.It is secured by running speedtests to destinations on the network and seeing how they match up to the advertised metrics.Using a \\\"circular ack\\\" speedtests can be reused many times by all the nodes on a route to a given destination. This also works with asymmetric routes.\"]],[[0,[],0,\"Nodes tally up what they are owed their neighbors according to which destinations the neighbors are sending packets to.Payments are settled with payment channels.If payments are not made, a node can stop forwarding a neighbor's packets using tunnels.\"]],[[0,[],0,\"On top of the pay-for-forward system, there is a gateway discovery and payment system.Somehow end-user nodes discover \\\"gateway\\\" nodes, nodes with a connection to the internet.Gateway nodes charge a certain amount for the internet connection.When a gateway is chosen by an end-user node, a payment channel is opened with that gateway.The gateway is paid for the amount of data used from the internet, as well as the amount that it cost the gateway to pay-for-forward to send the packets back to the end-user node.Gateways would need to be speedtested. Speedtests could be done between the end-user node and arbitrary servers on the internet.\"]]]],[1,\"h2\",[[0,[],0,\"Pay for internet\"]]],[3,\"ul\",[[[0,[],0,\"Nodes pay each other for access to the internet.\"]],[[0,[],0,\"Some secure source of routes is neccesary, but it remains completely separate and unspecified by this scheme.\"]],[[0,[],0,\"A node which is closer to the internet will be paid to both send and receive packets on behalf of a node which is further away (upstream and downstream connection).\"]],[[0,[],0,\"Nodes must discover and verify the quality of the internet access provided by their neighbors.This somewhat mirrors the quality metric discovery and verification in a secure routing protocol.To verify the upstream quality of a neighbor, a node sends traffic to a speedtest server on the internet.To verify the downstream quality of a neighbor, a node has a speedtest server on the internet send it traffic.In most routing protocols, there will only be one upstream neighbor and one downstream neighbor at once (and they will often be the same neighbor).However, if there are multiple upstream or downstream neighbors, it would be very difficult to tell which one is responsible for the quality of a route.\"]],[[0,[],0,\"Nodes could tally up what they are owed by their downstream neighbors according to how much data they have sent or received on behalf of a given downstream neighbor.Payments are settled with payment channels.If payments are not made, a node can stop forwarding packets to or from a neighbor using tunnels.\"]],[[0,[],0,\"Instead of announcing an all-or nothing price for access, nodes could instead prioritize traffic to and from neighbors according to how much each neighbor was paying at a given time.This might allow a natural range of quality/price options.It makes access discovery and verification harder. How do you know how much a neighbor's quality will improve if you pay it more?\"]]]]]}","html":"<p>We&#39;ve considered two main mechanisms for an incentivized mesh network so far. Pay for forward is the mechanism laid out in <a href=\"http://altheamesh.com/blog/althea-paper/\">Althea v1</a>, and <a href=\"https://www.reddit.com/r/hocnet/\">Hocnet</a>. Pay for internet is something I&#39;ve been working on as Althea v2 and it is also kind of how ISPs work now. This is a brief summary of both approaches.</p>\n\n<h2>Pay for forward</h2>\n\n<ul><li><p>A (secured) routing protocol propagates price along with the route quality metric.</p><ul><li>The routing protocol makes routing decisions based on the price and the metric.</li><li>It is secured by running speedtests to destinations on the network and seeing how they match up to the advertised metrics.</li><li><p>Using a &quot;circular ack&quot; speedtests can be reused many times by all the nodes on a route to a given destination. This also works with asymmetric routes.</p></li></ul></li><li><p>Nodes tally up what they are owed their neighbors according to which destinations the neighbors are sending packets to.</p><ul><li>Payments are settled with payment channels.</li><li><p>If payments are not made, a node can stop forwarding a neighbor&#39;s packets using tunnels.</p></li></ul></li><li><p>On top of the pay-for-forward system, there is a gateway discovery and payment system.</p><ul><li>Somehow end-user nodes discover &quot;gateway&quot; nodes, nodes with a connection to the internet.</li><li>Gateway nodes charge a certain amount for the internet connection.</li><li>When a gateway is chosen by an end-user node, a payment channel is opened with that gateway.</li><li>The gateway is paid for the amount of data used from the internet, as well as the amount that it cost the gateway to pay-for-forward to send the packets back to the end-user node.</li><li>Gateways would need to be speedtested. Speedtests could be done between the end-user node and arbitrary servers on the internet.</li></ul></li></ul>\n\n<h2>Pay for internet</h2>\n\n<ul><li>Nodes pay each other for access to the internet.</li><li><p>Some secure source of routes is neccesary, but it remains completely separate and unspecified by this scheme.</p></li><li><p>A node which is closer to the internet will be paid to both send and receive packets on behalf of a node which is further away (upstream and downstream connection).</p></li><li><p>Nodes must discover and verify the quality of the internet access provided by their neighbors.</p><ul><li>This somewhat mirrors the quality metric discovery and verification in a secure routing protocol.</li><li>To verify the upstream quality of a neighbor, a node sends traffic to a speedtest server on the internet.</li><li>To verify the downstream quality of a neighbor, a node has a speedtest server on the internet send it traffic.</li><li>In most routing protocols, there will only be one upstream neighbor and one downstream neighbor at once (and they will often be the same neighbor).</li><li><p>However, if there are multiple upstream or downstream neighbors, it would be very difficult to tell which one is responsible for the quality of a route.</p></li></ul></li><li><p>Nodes could tally up what they are owed by their downstream neighbors according to how much data they have sent or received on behalf of a given downstream neighbor.</p><ul><li>Payments are settled with payment channels.</li><li><p>If payments are not made, a node can stop forwarding packets to or from a neighbor using tunnels.</p></li></ul></li><li><p>Instead of announcing an all-or nothing price for access, nodes could instead prioritize traffic to and from neighbors according to how much each neighbor was paying at a given time.</p><ul><li>This might allow a natural range of quality/price options.</li><li>It makes access discovery and verification harder. How do you know how much a neighbor&#39;s quality will improve if you pay it more?</li></ul></li></ul>","comment_id":null,"plaintext":"We've considered two main mechanisms for an incentivized mesh network so far. Pay for forward is the mechanism laid out in [Althea v1](http://altheamesh.com/blog/althea-paper/), and [Hocnet](https://www.reddit.com/r/hocnet/). Pay for internet is something I've been working on as Althea v2 and it is also kind of how ISPs work now. This is a brief summary of both approaches.\n\n## Pay for forward\n- A (secured) routing protocol propagates price along with the route quality metric.\n  - The routing protocol makes routing decisions based on the price and the metric.\n  - It is secured by running speedtests to destinations on the network and seeing how they match up to the advertised metrics.\n  - Using a \"circular ack\" speedtests can be reused many times by all the nodes on a route to a given destination. This also works with asymmetric routes.\n\n- Nodes tally up what they are owed their neighbors according to which destinations the neighbors are sending packets to.\n  - Payments are settled with payment channels.\n  - If payments are not made, a node can stop forwarding a neighbor's packets using tunnels.\n\n- On top of the pay-for-forward system, there is a gateway discovery and payment system.\n  - Somehow end-user nodes discover \"gateway\" nodes, nodes with a connection to the internet.\n  - Gateway nodes charge a certain amount for the internet connection.\n  - When a gateway is chosen by an end-user node, a payment channel is opened with that gateway.\n  - The gateway is paid for the amount of data used from the internet, as well as the amount that it cost the gateway to pay-for-forward to send the packets back to the end-user node.\n  - Gateways would need to be speedtested. Speedtests could be done between the end-user node and arbitrary servers on the internet.\n\n## Pay for internet\n- Nodes pay each other for access to the internet.\n- Some secure source of routes is neccesary, but it remains completely separate and unspecified by this scheme.\n\n- A node which is closer to the internet will be paid to both send and receive packets on behalf of a node which is further away (upstream and downstream connection).\n- Nodes must discover and verify the quality of the internet access provided by their neighbors.\n  - This somewhat mirrors the quality metric discovery and verification in a secure routing protocol.\n  - To verify the upstream quality of a neighbor, a node sends traffic to a speedtest server on the internet.\n  - To verify the downstream quality of a neighbor, a node has a speedtest server on the internet send it traffic.\n  - In most routing protocols, there will only be one upstream neighbor and one downstream neighbor at once (and they will often be the same neighbor).\n  - However, if there are multiple upstream or downstream neighbors, it would be very difficult to tell which one is responsible for the quality of a route.\n\n- Nodes could tally up what they are owed by their downstream neighbors according to how much data they have sent or received on behalf of a given downstream neighbor.\n  - Payments are settled with payment channels.\n  - If payments are not made, a node can stop forwarding packets to or from a neighbor using tunnels.\n\n- Instead of announcing an all-or nothing price for access, nodes could instead prioritize traffic to and from neighbors according to how much each neighbor was paying at a given time.\n  - This might allow a natural range of quality/price options.\n  - It makes access discovery and verification harder. How do you know how much a neighbor's quality will improve if you pay it more?","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-04-08 00:00:00","created_by":"1","updated_at":"2017-04-08 00:00:00","updated_by":"1","published_at":"2017-04-08 00:00:00","published_by":"1","custom_excerpt":"We've considered two main mechanisms for an incentivized mesh network so far. Pay for forward is the mechanism laid out in Althea v1, and Hocnet. Pay for internet is something I've been working on as Althea v2 and it is also kind of how ISPs work now. This is a brief summary of both approaches.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc764","uuid":"2e265da1-4bbf-459a-a164-cee305e27a32","title":"Development Roadmap","slug":"development-roadmap","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://github.com/althea-mesh/physical-node\"]],[\"a\",[\"href\",\"https://github.com/althea-mesh/exit-node\"]],[\"strong\"],[\"a\",[\"href\",\"https://riot.im/app/#/room/#althea:matrix.org\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"We are developing Althea incrementally over several stages. The first couple stages are not anywhere near the full capabilities that Althea will have. They are not even mesh networks. However, developing software in an incremental manner lets us test and prove out various elements of the system continously. Most development is happening in the \"],[0,[0],1,\"physical-node\"],[0,[],0,\" and \"],[0,[1],1,\"exit-node\"],[0,[],0,\" repos. These repos will also pull in various daemons that we are creating to run the network.\"]]],[1,\"p\",[[0,[2],1,\"Exit node to user node tunnel:\"],[0,[],0,\" The exit node is basically a VPN server, and the physical node uses the VPN for internet access. Users of physical nodes can select an exit node to use and access the internet over a secure tunnel without having to mess with VPN clients on their personal devices. This does not have much to do with incentivized mesh yet, but it forms a base of security and privacy. It can also be useful for people who don't want ISPs selling their browsing history and don't mind setting up a VPN server themselves.\"]]],[1,\"p\",[[0,[2],1,\"Metering and payments: (under development)\"],[0,[],0,\" The physical node and the exit node both keep track of how much traffic has been sent over the tunnel, and the physical node automatically pays for the traffic. This lets us start to build infrastructure around metering traffic, paying for it, and cutting off service in the case of non-payment. It can also be useful for people who want to set up VPN servers and charge others for the service.\"]]],[1,\"p\",[[0,[2],1,\"Unverified mesh:\"],[0,[],0,\" Several physical nodes can form a mesh network, which routes traffic to one or more exit nodes, over the best and cheapest paths. Physical nodes meter traffic forwarded for their neighbors, and charge each other for it. This remains vulnerable to low-level attacks on the routing protocol, but will allow us to test the network in a controlled real-world environment, giving users internet access, and receiving payment.\"]]],[1,\"p\",[[0,[2],1,\"Verified mesh:\"],[0,[],0,\" Physical nodes constantly test the routing metrics advertised by their neighbors, allowing them to verify the quality of the routes, and building a \\\"local reputation\\\" database about their neighbors. This starts to open the network up to secure participation by a wider range of operators, allowing it to grow quickly. Physical nodes still can't be that mobile though, because they need to open channels and verify the routes of other nodes they are paying to forward.\"]]],[1,\"p\",[[0,[2],1,\"Future evolution...:\"],[0,[],0,\" The \\\"Verified mesh\\\" stage proves out the basic concept. But there's still a lot of work beyond that, some of which is not yet covered even in the white paper:   - Rigorous security testing.   - Multihop channels: Using hashlock techniques, nodes could transfer payments to their neighbors over a network of multihop channels, allowing them to move to a new physical location without waiting for a channel to open to pay for a connection to their new neighbors.   - Transitive reputation: Nodes could also get information on the accuracy of new neighbors from other nodes that they trust on some level. This will also enable mobility.   - On-device user node: Build a stripped down \\\"physical node\\\" app for laptops and mobile devices. This will allow users to pay for traffic and roam without carrying a physical OpenWRT node with them.\"]]],[1,\"h2\",[[0,[],0,\"How to help\"]]],[1,\"p\",[[0,[],0,\"Building this system out requires a large range of skills:\"]]],[3,\"ul\",[[[0,[],0,\"Linux networking: Obviously a big part of the system.\"]],[[0,[],0,\"Cryptocurrency: We'll be using pretty basic payment channels to start out, so it's not like we need a huge amount of consensus and blockchain wonkery at first. However, the choices we make early on will have big effects, since the space is changing raidly. Multihop channels and transitive reputation will require a bit more expertise later on.\"]],[[0,[],0,\"Frontend design and development: The concept of paying per kilobyte on a cryptocurrency mesh network will be unfamiliar to most people. We'll need intuitive UX/UI design and solid cross-platform frontend code.\"]]]],[1,\"p\",[[0,[],0,\"If you want to help, or just say hi, introduce yourself in our \"],[0,[3],1,\"Matrix chat\"]]]]}","html":"<p>We are developing Althea incrementally over several stages. The first couple stages are not anywhere near the full capabilities that Althea will have. They are not even mesh networks. However, developing software in an incremental manner lets us test and prove out various elements of the system continously. Most development is happening in the <a href=\"https://github.com/althea-mesh/physical-node\">physical-node</a> and <a href=\"https://github.com/althea-mesh/exit-node\">exit-node</a> repos. These repos will also pull in various daemons that we are creating to run the network.</p>\n\n<p><strong>Exit node to user node tunnel:</strong> The exit node is basically a VPN server, and the physical node uses the VPN for internet access. Users of physical nodes can select an exit node to use and access the internet over a secure tunnel without having to mess with VPN clients on their personal devices. This does not have much to do with incentivized mesh yet, but it forms a base of security and privacy. It can also be useful for people who don&#39;t want ISPs selling their browsing history and don&#39;t mind setting up a VPN server themselves.</p>\n\n<p><strong>Metering and payments: (under development)</strong> The physical node and the exit node both keep track of how much traffic has been sent over the tunnel, and the physical node automatically pays for the traffic. This lets us start to build infrastructure around metering traffic, paying for it, and cutting off service in the case of non-payment. It can also be useful for people who want to set up VPN servers and charge others for the service.</p>\n\n<p><strong>Unverified mesh:</strong> Several physical nodes can form a mesh network, which routes traffic to one or more exit nodes, over the best and cheapest paths. Physical nodes meter traffic forwarded for their neighbors, and charge each other for it. This remains vulnerable to low-level attacks on the routing protocol, but will allow us to test the network in a controlled real-world environment, giving users internet access, and receiving payment.</p>\n\n<p><strong>Verified mesh:</strong> Physical nodes constantly test the routing metrics advertised by their neighbors, allowing them to verify the quality of the routes, and building a &quot;local reputation&quot; database about their neighbors. This starts to open the network up to secure participation by a wider range of operators, allowing it to grow quickly. Physical nodes still can&#39;t be that mobile though, because they need to open channels and verify the routes of other nodes they are paying to forward.</p>\n\n<p><strong>Future evolution...:</strong> The &quot;Verified mesh&quot; stage proves out the basic concept. But there&#39;s still a lot of work beyond that, some of which is not yet covered even in the white paper:\n  - Rigorous security testing.\n  - Multihop channels: Using hashlock techniques, nodes could transfer payments to their neighbors over a network of multihop channels, allowing them to move to a new physical location without waiting for a channel to open to pay for a connection to their new neighbors.\n  - Transitive reputation: Nodes could also get information on the accuracy of new neighbors from other nodes that they trust on some level. This will also enable mobility.\n  - On-device user node: Build a stripped down &quot;physical node&quot; app for laptops and mobile devices. This will allow users to pay for traffic and roam without carrying a physical OpenWRT node with them.</p>\n\n<h2>How to help</h2>\n\n<p>Building this system out requires a large range of skills:</p>\n\n<ul><li>Linux networking: Obviously a big part of the system.</li><li>Cryptocurrency: We&#39;ll be using pretty basic payment channels to start out, so it&#39;s not like we need a huge amount of consensus and blockchain wonkery at first. However, the choices we make early on will have big effects, since the space is changing raidly. Multihop channels and transitive reputation will require a bit more expertise later on.</li><li>Frontend design and development: The concept of paying per kilobyte on a cryptocurrency mesh network will be unfamiliar to most people. We&#39;ll need intuitive UX/UI design and solid cross-platform frontend code.</li></ul>\n\n<p>If you want to help, or just say hi, introduce yourself in our <a href=\"https://riot.im/app/#/room/#althea:matrix.org\">Matrix chat</a></p>","comment_id":null,"plaintext":"We are developing Althea incrementally over several stages. The first couple stages are not anywhere near the full capabilities that Althea will have. They are not even mesh networks. However, developing software in an incremental manner lets us test and prove out various elements of the system continously. Most development is happening in the [physical-node](https://github.com/althea-mesh/physical-node) and [exit-node](https://github.com/althea-mesh/exit-node) repos. These repos will also pull in various daemons that we are creating to run the network.\n\n**Exit node to user node tunnel:** The exit node is basically a VPN server, and the physical node uses the VPN for internet access. Users of physical nodes can select an exit node to use and access the internet over a secure tunnel without having to mess with VPN clients on their personal devices. This does not have much to do with incentivized mesh yet, but it forms a base of security and privacy. It can also be useful for people who don't want ISPs selling their browsing history and don't mind setting up a VPN server themselves.\n\n**Metering and payments: (under development)** The physical node and the exit node both keep track of how much traffic has been sent over the tunnel, and the physical node automatically pays for the traffic. This lets us start to build infrastructure around metering traffic, paying for it, and cutting off service in the case of non-payment. It can also be useful for people who want to set up VPN servers and charge others for the service.\n\n**Unverified mesh:** Several physical nodes can form a mesh network, which routes traffic to one or more exit nodes, over the best and cheapest paths. Physical nodes meter traffic forwarded for their neighbors, and charge each other for it. This remains vulnerable to low-level attacks on the routing protocol, but will allow us to test the network in a controlled real-world environment, giving users internet access, and receiving payment.\n\n**Verified mesh:** Physical nodes constantly test the routing metrics advertised by their neighbors, allowing them to verify the quality of the routes, and building a \"local reputation\" database about their neighbors. This starts to open the network up to secure participation by a wider range of operators, allowing it to grow quickly. Physical nodes still can't be that mobile though, because they need to open channels and verify the routes of other nodes they are paying to forward.\n\n**Future evolution...:** The \"Verified mesh\" stage proves out the basic concept. But there's still a lot of work beyond that, some of which is not yet covered even in the white paper:\n  - Rigorous security testing.\n  - Multihop channels: Using hashlock techniques, nodes could transfer payments to their neighbors over a network of multihop channels, allowing them to move to a new physical location without waiting for a channel to open to pay for a connection to their new neighbors.\n  - Transitive reputation: Nodes could also get information on the accuracy of new neighbors from other nodes that they trust on some level. This will also enable mobility.\n  - On-device user node: Build a stripped down \"physical node\" app for laptops and mobile devices. This will allow users to pay for traffic and roam without carrying a physical OpenWRT node with them.\n\n## How to help\nBuilding this system out requires a large range of skills:\n\n- Linux networking: Obviously a big part of the system.\n- Cryptocurrency: We'll be using pretty basic payment channels to start out, so it's not like we need a huge amount of consensus and blockchain wonkery at first. However, the choices we make early on will have big effects, since the space is changing raidly. Multihop channels and transitive reputation will require a bit more expertise later on.\n- Frontend design and development: The concept of paying per kilobyte on a cryptocurrency mesh network will be unfamiliar to most people. We'll need intuitive UX/UI design and solid cross-platform frontend code.\n\nIf you want to help, or just say hi, introduce yourself in our [Matrix chat](https://riot.im/app/#/room/#althea:matrix.org)\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-06-29 00:00:00","created_by":"1","updated_at":"2017-06-29 00:00:00","updated_by":"1","published_at":"2017-06-29 00:00:00","published_by":"1","custom_excerpt":"We are developing Althea incrementally over several stages. The first couple stages are not anywhere near the full capabilities that Althea will have. They are not even mesh networks. However, developing software in an incremental manner lets us test and prove out various elements of the system cont","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc765","uuid":"cc220100-f8e7-48fb-abd6-424ecc51a8b5","title":"Battlemesh talk","slug":"battlemesh-talk","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://www.youtube.com/watch?v=f21KCNw7EWw\"]]],\"sections\":[[1,\"p\",[[0,[],0,\"Just realized that I forgot to post my talk from Battlemesh. \"],[0,[0],1,\"Here it is\"],[0,[],0,\".\"]]]]}","html":"<p>Just realized that I forgot to post my talk from Battlemesh. <a href=\"https://www.youtube.com/watch?v=f21KCNw7EWw\">Here it is</a>.</p>","comment_id":null,"plaintext":"Just realized that I forgot to post my talk from Battlemesh. [Here it is](https://www.youtube.com/watch?v=f21KCNw7EWw).\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-08-25 00:00:00","created_by":"1","updated_at":"2017-08-25 00:00:00","updated_by":"1","published_at":"2017-08-25 00:00:00","published_by":"1","custom_excerpt":"Just realized that I forgot to post my talk from Battlemesh. Here it is:","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null},{"id":"5c2f90c52b5def72fffcc766","uuid":"dabd0c59-19e4-472b-b81e-0674d5eea723","title":"Althea's multihop payment channels","slug":"altheas-multihop-payment-channels","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"code\",{\"code\":\"    uint256 balance0;\\n    uint256 balance1;\\n    bytes hashlocks;\\n    uint256 sequenceNumber;\\n\\n    uint256 settlingPeriodLength;\\n    bool settlingPeriodStarted;\\n    uint256 settlingPeriodEnd;\\n    bool closed;\\n}\\n\\nmapping (bytes32 => Channel) public channels;\\nmapping (bytes32 => bool) seenPreimage;\"}],[\"code\",{\"code\":\"address _address0,\\naddress _address1,\\n\\nuint256 _balance0,\\nuint256 _balance1,\\n\\nuint256 _settlingPeriodLength,\\n\\nbytes _signature0,\\nbytes _signature1\"}],[\"code\",{\"code\":\"    _address0,\\n    _address1,\\n\\n    _balance0,\\n    _balance1,\\n\\n    _settlingPeriodLength\\n);\\n\\nsignedByBoth(\\n    fingerprint,\\n    _signature0,\\n    _signature1,\\n    _address0,\\n    _address1\\n);\\n\\ndecrementBalance(_address0, _balance0);\\ndecrementBalance(_address1, _balance1);\\n\\nchannels[_channelId] = Channel(\\n    _channelId,                  // bytes32 channelId;\\n    _address0,                   // address address0;\\n    _address1,                   // address address1;\\n    _balance0.add(_balance1),    // uint256 totalBalance;\\n\\n    _balance0,                   // uint256 balance0;\\n    _balance1,                   // uint256 balance1;\\n    new bytes(0),                // bytes hashlocks\\n    0,                           // uint256 sequenceNumber;\\n\\n    _settlingPeriodLength,       // uint256 settlingPeriodLength;\\n    false,                       // bool settlingPeriodStarted;\\n    0,                           // uint256 settlingPeriodEnd;\\n    false                        // bool closed;\\n\\n);\"}],[\"code\",{\"code\":\"uint256 _balance0,\\nuint256 _balance1,\\n\\nbytes _hashlocks,\\n\\nbytes _signature0,\\nbytes _signature1\"}],[\"code\",{\"code\":\"bytes32 fingerprint = sha3(\\n    \\\"updateState\\\",\\n    _channelId,\\n    _sequenceNumber,\\n    _balance0,\\n    _balance1,\\n    _hashlocks\\n);\\n\\nsignedByBoth(\\n    fingerprint,\\n    _signature0,\\n    _signature1,\\n    channels[_channelId].address0,\\n    channels[_channelId].address1\\n);\\n\\nupdateStateInternal(\\n    _channelId,\\n    _sequenceNumber,\\n\\n    _balance0,\\n    _balance1,\\n\\n    _hashlocks\\n);\"}],[\"code\",{\"code\":\"uint256 _balance0,\\nuint256 _balance1,\\n\\nbytes _hashlocks\"}],[\"code\",{\"code\":\"uint256 _balance0,\\nuint256 _balance1,\\n\\nbytes _hashlocks,\\n\\nbytes _signature0,\\nbytes _signature1,\\n\\nuint256 _bountyAmount,\\nbytes _bountySignature\"}],[\"code\",{\"code\":\"bytes32 fingerprint = sha3(\\n    \\\"updateStateWithBounty\\\",\\n    _channelId,\\n    _sequenceNumber,\\n    _balance0,\\n    _balance1,\\n    _hashlocks,\\n    _signature0,\\n    _signature1,\\n    _bountyAmount\\n);\\n\\naddress bountyPayer = ecrecovery(fingerprint, _bountySignature);\\n\\ndecrementBalance(bountyPayer, _bountyAmount);\\nincrementBalance(msg.sender, _bountyAmount);\\n\\nupdateState(\\n    _channelId,\\n    _sequenceNumber,\\n\\n    _balance0,\\n    _balance1,\\n\\n    _hashlocks,\\n\\n    _signature0,\\n    _signature1\\n);\"}],[\"code\",{\"code\":\"for (uint256 i = 0; i < pairs.length; i += 64) {\\n    uint256 hashedOffset = i + 32;\\n    uint256 preimageOffset = i + 64;\\n\\n    assembly {\\n        hashed := mload(add(pairs, hashedOffset))\\n        preimage := mload(add(pairs, preimageOffset))\\n    }\\n\\n    submitPreimage(hashed, preimage);\\n}\"}],[\"code\",{\"code\":\"bytes32 fingerprint = sha3(\\n    \\\"startSettlingPeriod\\\",\\n    _channelId\\n);\\n\\nsignedByOne(\\n    fingerprint,\\n    _signature,\\n    channels[_channelId].address0,\\n    channels[_channelId].address1\\n);\\n\\nchannels[_channelId].settlingPeriodStarted = true;\\nchannels[_channelId].settlingPeriodEnd = block.number + channels[_channelId].settlingPeriodLength;\"}],[\"code\",{\"code\":\"closeChannelInternal(_channelId);\"}],[\"code\",{\"code\":\"uint256 _sequenceNumber,\\nuint256 _balance0,\\nuint256 _balance1,\\nbytes _hashlocks,\\n\\nbytes _signature0,\\nbytes _signature1\"}],[\"code\",{\"code\":\"bytes32 fingerprint = sha3(\\n    \\\"closeChannelFast\\\",\\n    _channelId,\\n    _sequenceNumber,\\n    _balance0,\\n    _balance1,\\n    _hashlocks\\n);\\n\\nsignedByBoth(\\n    fingerprint,\\n    _signature0,\\n    _signature1,\\n    channels[_channelId].address0,\\n    channels[_channelId].address1\\n);\\n\\nupdateStateInternal(\\n    _channelId,\\n    _sequenceNumber,\\n    _balance0,\\n    _balance1,\\n    _hashlocks\\n);\\n\\ncloseChannelInternal(_channelId);\"}],[\"code\",{\"code\":\"int256 adjustment = getHashlockAdjustment(channels[_channelId].hashlocks);\\n\\nuint256 balance0;\\nuint256 balance1;\\n(balance0, balance1) = applyHashlockAdjustment(\\n    _channelId,\\n    channels[_channelId].balance0,\\n    channels[_channelId].balance1,\\n    adjustment\\n);\\n\\nincrementBalance(channels[_channelId].address0, balance0);\\nincrementBalance(channels[_channelId].address1, balance1);\"}],[\"code\",{\"code\":\"for (uint256 i = 0; i < _hashlocks.length; i += 64) {\\n    uint256 hashedOffset = i + 32;\\n    uint256 adjustmentOffset = i + 64;\\n\\n    assembly {\\n        hashed := mload(add(_hashlocks, hashedOffset))\\n        adjustment := mload(add(_hashlocks, adjustmentOffset))\\n    }\\n\\n    if (seenPreimage[hashed]) {\\n        totalAdjustment += adjustment;\\n    }\\n}\\n\\nreturn totalAdjustment;\"}],[\"code\",{\"code\":\"if (_totalAdjustment > 0) {\\n    balance0 = _currentBalance0.add(uint256(_totalAdjustment));\\n    balance1 = _currentBalance1.sub(uint256(_totalAdjustment));\\n}\\n\\nif (_totalAdjustment < 0) {\\n    balance0 = _currentBalance0.sub(uint256(-_totalAdjustment));\\n    balance1 = _currentBalance1.add(uint256(-_totalAdjustment));\\n}\\n\\nif (_totalAdjustment == 0) {\\n    balance0 = _currentBalance0;\\n    balance1 = _currentBalance1;\\n}\\n\\nbalancesEqualTotal(_channelId, balance0, balance1);\\nreturn (balance0, balance1);\"}]],\"markups\":[[\"a\",[\"href\",\"https://github.com/althea-mesh/guac\"]],[\"a\",[\"href\",\"/blog/universal-payment-channels\"]],[\"code\"],[\"em\"]],\"sections\":[[1,\"p\",[[0,[],0,\"This is an article about our payment channel library, \"],[0,[0],1,\"Guac\"],[0,[],0,\" on github.\"]]],[1,\"p\",[[0,[],0,\"Althea's payment channels are key to how it works, but they are also one of the simpler parts to implement and explain. Payment channels allow payments to be made with a minimum of overhead. In the simple case, a payment can be made between two neighbors in the network with only one packet. The catch is that the neighbors need to have deposited money into the a payment channel contract beforehand to \\\"open the channel\\\". However, channels can also be chained together using something called a \\\"hashlock\\\" to allow nodes to transact trustlessly over linked payment channels, without needing to be directly linked by a channel.\"]]],[1,\"p\",[[0,[],0,\"There are already several channel implementations for Ethereum. The best-known one is Raiden. We found Raiden to be very monolithic and tied to a large Python offchain codebase. We cannot use Python on our routers. We need to use a language suited to embedded device programming, so we are using Rust (however, this blog post is only about the Solidity contract). Raiden also includes a lot of functionality we don't need, and is very complex in general. For example, they implement their own Merkel tree in Solidity. Maybe the complexity is warranted because it's intended to be a payment channel for every use case. Our application has relatively simple needs and payment channels are a concept that is well understood, so we decided it would be more expedient to use our own simple solution. \"]]],[1,\"p\",[[0,[],0,\"There's also Machinomy. Machinomy is pretty clean, but it is a unidirectional channel. This means that money can only ever flow in one direction. You could set up two unidirectional channels, but this is still not as good as a bidirectional channel. To illustrate why, let's say Alice and Bob have both put 100 Ether in a bidirectional channel. If Alice sends Bob 100 Ether, and then Bob sends Alice 100 Ether, the channel will be back in the state it started at and ready to be used some more. If instead there are 2 unidirectional channels, then both participants sending each other 100 Ether over their 2 channels will result in both channels being exhausted. New channels will then need to be created, resulting in more blockchain transaction fees and waiting for confirmations. You could get into some stuff like letting unidirectional channels refill each other, but this is more complex than a bidirectional channel.\"]]],[1,\"p\",[[0,[],0,\"We developed the theory underlying our payment channels based on some of Zack Hess's work back in 2015. You can read an explanation of the theory \"],[0,[1],1,\"here\"],[0,[],0,\". For this blog post I'm going to be focusing specifically on the Solidity payment channel contract in the current implementation of Althea.\"]]],[1,\"p\",[[0,[],0,\"This code has not been audited, and may have obvious or subtle exploits that we are not aware of. Don't just copy and paste this and put a lot of money in it. If you do see an issue, let us know because we will gladly update this blog post to credit you and discuss the vulnerability.\"]]],[1,\"h2\",[[0,[],0,\"Imports\"]]],[1,\"p\",[[0,[2],1,\"pragma solidity ^0.4.11; import \\\"./ECVerify.sol\\\"; import \\\"zeppelin-solidity/contracts/token/MintableToken.sol\\\"; \"],[0,[],0,\"First, we import a couple of other contracts. \"],[0,[2],1,\"./ECVerify.sol\"],[0,[],0,\" is a piece of code written by Alex Beregszaszi (@axic). The type of signatures used by Ethereum normally consist of 3 values, \"],[0,[2],1,\"R\"],[0,[],0,\", \"],[0,[2],1,\"S\"],[0,[],0,\", and \"],[0,[2],1,\"V\"],[0,[],0,\". ECVerify takes a byte array which consists of these three values concatenated. This keeps us from having to pass around 3 extra variables all over the place (the EVM can have issues with too many local variables) and is just cleaner. It also smoothes out some other quirks in the Ethereum signature scheme which are too ridiculous to get into.\"]]],[1,\"p\",[[0,[2],1,\"MintableToken.sol\"],[0,[],0,\" is an ERC20 token contract provided by Open Zeppelin. It's probably more secure than if we were to try to make our own ERC20 token. None of the stuff in this contract deals with the ERC20 token functionality much, so we could probably plug in lots of different ERC20 variations if we wanted to.\"]]],[1,\"h2\",[[0,[],0,\"Data structures\"]]],[1,\"p\",[[0,[],0,\"`js contract PaymentChannels is ECVerify, MintableToken {     struct Channel {         bytes32 channelId;         address address0;         address address1;         uint256 totalBalance;\"]]],[10,0],[1,\"p\",[[0,[],0,\"... \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"Now we get into the actual contract. We inherit from the other contracts we imported above, so that we can use their functionalities. We also declare the channel data structure:\"]]],[3,\"ul\",[[[0,[2],1,\"channelID\"],[0,[],0,\" is a unique identifier for the channel.\"]],[[0,[2],1,\"address0\"],[0,[],0,\" and address1 are the two Ethereum addresses that will be transacting over the channel.\"]],[[0,[2],1,\"totalBalance\"],[0,[],0,\" is the total amount of money that both participants are putting in the channel. It needs to be the sum of balance0 and balance1\"]],[[0,[2],1,\"balance0\"],[0,[],0,\" and balance1 are the amounts that address0 and address1 are putting in the channel.\"]],[[0,[2],1,\"hashlocks\"],[0,[],0,\" is a byte array encoding any hashlocks that are active in the channel. There's parsing logic later in the contract that parses the hashlocks out of the byte array, since passing arrays of structs is not currently supported by Solidity.\"]],[[0,[2],1,\"sequenceNumber\"],[0,[],0,\" is incremented with every channel update transaction, allowing this contract to only honor the latest valid update.\"]],[[0,[2],1,\"settlingPeriodLength\"],[0,[],0,\" is the amount of time after a channel's settling period has started that must elapse before the channel can be closed and the money can be taken out.\"]],[[0,[2],1,\"settlingPeriodStarted\"],[0,[],0,\": whether the channel's settling period has started.\"]],[[0,[2],1,\"closed\"],[0,[],0,\": whether the channel has been closed.\"]],[[0,[2],1,\"settlingPeriodEnd\"],[0,[],0,\" is the block height after which the channel can be closed.\"]]]],[1,\"p\",[[0,[],0,\"We also declare 2 mappings. \"],[0,[2],1,\"channels\"],[0,[],0,\" is for storing channels that have been created with the contract. \"],[0,[2],1,\"seenPreimage\"],[0,[],0,\" is a mapping of hashes that records whether the contract has already been shown the preimage of the hash. This is used to implement the hashlocks. Making it global allows the reveal of one preimage to unlock hashlocked funds in several different channels, and uses less storage space. \"]]],[1,\"h2\",[[0,[],0,\"Modifiers\"]]],[1,\"p\",[[0,[],0,\"Next come the modifiers. They are not declared with the \"],[0,[2],1,\"modifier\"],[0,[],0,\" keyword, because for some reason it causes the Solidity compiler to complain about too many local variables. However, they have the exact same effect as modifiers when they are declared as functions and called at the top of a function body.\"]]],[1,\"h3\",[[0,[],0,\"Lifecycle modifiers\"]]],[1,\"p\",[[0,[],0,\"These deal with the various lifecycle phases of the channel. This is to prevent functions getting called in phases of the lifecycle they are not allowed.\"]]],[1,\"p\",[[0,[],0,\"`js function channelDoesNotExist (bytes32 _channelId) {     require(channels[\"],[0,[3],1,\"channelId].channelId != \"],[0,[],0,\"channelId); }\"]]],[1,\"p\",[[0,[],0,\"function channelExists (bytes32 _channelId) {     require(channels[\"],[0,[3],1,\"channelId].channelId == \"],[0,[],0,\"channelId); }\"]]],[1,\"p\",[[0,[],0,\"function channelSettlingPeriodStarted (bytes32 _channelId) {     require(channels[_channelId].settlingPeriodStarted); }\"]]],[1,\"p\",[[0,[],0,\"function channelSettlingPeriodNotStarted (bytes32 _channelId) {     require(!channels[_channelId].settlingPeriodStarted); }\"]]],[1,\"p\",[[0,[],0,\"function channelIsNotClosed (bytes32 _channelId) {     require(!channels[_channelId].closed); }\"]]],[1,\"p\",[[0,[],0,\"function channelIsSettled (bytes32 _channelId) {     require(         channels[_channelId].settlingPeriodStarted && // If the settling period has started         block.number >= channels[_channelId].settlingPeriodEnd // And ended     ); }\"]]],[1,\"p\",[[0,[],0,\"function channelIsNotSettled (bytes32 _channelId) {     require(!( // Negate the below         channels[_channelId].settlingPeriodStarted && // If the settling period is started         block.number >= channels[_channelId].settlingPeriodEnd // And ended     )); } \"],[0,[],0,\"`\"]]],[1,\"h3\",[[0,[],0,\"State validity modifiers\"]]],[1,\"p\",[[0,[],0,\"These deal with making sure that state updates are valid. For a state update to be accepted, the new balances have to equal the total that was put in the channel, and it has to have the highest sequence number of all the updates that have been submitted.\"]]],[1,\"p\",[[0,[],0,\"`js function balancesEqualTotal (bytes32 \"],[0,[3],1,\"channelId, uint256 \"],[0,[],0,\"balance0, uint256 \"],[0,[3],1,\"balance1) {     require(\"],[0,[],0,\"balance0.add(_balance1) == channels[_channelId].totalBalance); }\"]]],[1,\"p\",[[0,[],0,\"function sequenceNumberIsHighest (bytes32 \"],[0,[3],1,\"channelId, uint256 \"],[0,[],0,\"sequenceNumber) {     require(_sequenceNumber > channels[_channelId].sequenceNumber); } \"],[0,[],0,\"`\"]]],[1,\"h3\",[[0,[],0,\"Signature modifiers\"]]],[1,\"p\",[[0,[],0,\"These check that the signatures submitted with function calls are correct. Some functions need signatures from both participants, and some only need signatures from one. Some functions only need one specific signature.\"]]],[1,\"p\",[[0,[],0,\"`js function signedByBoth (     bytes32 \"],[0,[3],1,\"fingerprint,      bytes \"],[0,[],0,\"signature0,      bytes \"],[0,[3],1,\"signature1,      address \"],[0,[],0,\"address0,     address \"],[0,[3],1,\"address1 ) {     require(         ecverify(\"],[0,[],0,\"fingerprint, \"],[0,[3],1,\"signature0, \"],[0,[],0,\"address0) &&         ecverify(\"],[0,[3],1,\"fingerprint, \"],[0,[],0,\"signature1, _address1)     ); }\"]]],[1,\"p\",[[0,[],0,\"function signedByOne (     bytes32 \"],[0,[3],1,\"fingerprint,     bytes \"],[0,[],0,\"signature,     address \"],[0,[3],1,\"address0,     address \"],[0,[],0,\"address1 ) {     require(         ecverify(\"],[0,[3],1,\"fingerprint, \"],[0,[],0,\"signature, \"],[0,[3],1,\"address0) ||         ecverify(\"],[0,[],0,\"fingerprint, \"],[0,[3],1,\"signature, \"],[0,[],0,\"address1)     ); } \"],[0,[],0,\"`\"]]],[1,\"h2\",[[0,[],0,\"ERC20 balance adjustment\"]]],[1,\"p\",[[0,[],0,\"`js function incrementBalance(address \"],[0,[3],1,\"addr, uint \"],[0,[],0,\"value)     internal {     balances[_addr] = balances[\"],[0,[3],1,\"addr].add(\"],[0,[],0,\"value); }\"]]],[1,\"p\",[[0,[],0,\"function decrementBalance(address \"],[0,[3],1,\"addr, uint \"],[0,[],0,\"value)     internal {     balances[_addr] = balances[\"],[0,[3],1,\"addr].sub(\"],[0,[],0,\"value); } \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"These functions increment and decrement the ERC20 balances. These could be used to create money out of thin air, so they must be handled carefully. They are used to put money into channels and take it out. It might have been possible to give each channel its own address in the ERC20 \"],[0,[2],1,\"balances\"],[0,[],0,\" mapping to avoid doing this, but it would have had a lot more complexity and moving parts. The safe math functions (\"],[0,[2],1,\".add\"],[0,[],0,\" and \"],[0,[2],1,\".sub\"],[0,[],0,\") supplied by the Zeppelin framework prevent any issues like balances going lower than 0.\"]]],[1,\"h2\",[[0,[],0,\"Creating a channel\"]]],[1,\"p\",[[0,[],0,\"`js function newChannel(     bytes32 _channelId,\"]]],[10,1],[1,\"p\",[[0,[],0,\") {     channelDoesNotExist(\"],[0,[3],1,\"channelId);     bytes32 fingerprint = sha3(         \\\"newChannel\\\",         \"],[0,[],0,\"channelId,\"]]],[10,2],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"To create a new channel, someone needs to call \"],[0,[2],1,\"newChannel()\"],[0,[],0,\" with the signatures of both participants. We first check that a channel with that \"],[0,[2],1,\"channelId\"],[0,[],0,\" does not already exist. Then we check the signatures and attempt to withdraw the money from the accounts of both participants. Finally, we create a record of the channel.\"]]],[1,\"h2\",[[0,[],0,\"Updating channel state\"]]],[1,\"p\",[[0,[],0,\"`js function updateState(     bytes32 \"],[0,[3],1,\"channelId,     uint256 \"],[0,[],0,\"sequenceNumber,\"]]],[10,3],[1,\"p\",[[0,[],0,\") {     channelExists(\"],[0,[3],1,\"channelId);     channelIsNotSettled(\"],[0,[],0,\"channelId);     channelIsNotClosed(\"],[0,[3],1,\"channelId);     sequenceNumberIsHighest(\"],[0,[],0,\"channelId, _sequenceNumber);\"]]],[10,4],[1,\"p\",[[0,[],0,\"}\"]]],[1,\"p\",[[0,[],0,\"function updateStateInternal (     bytes32 \"],[0,[3],1,\"channelId,     uint256 \"],[0,[],0,\"sequenceNumber,\"]]],[10,5],[1,\"p\",[[0,[],0,\")     internal {     channels[\"],[0,[3],1,\"channelId].sequenceNumber = \"],[0,[],0,\"sequenceNumber;     channels[\"],[0,[3],1,\"channelId].balance0 = \"],[0,[],0,\"balance0;     channels[\"],[0,[3],1,\"channelId].balance1 = \"],[0,[],0,\"balance1;     channels[\"],[0,[3],1,\"channelId].hashlocks = \"],[0,[],0,\"hashlocks; } \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"To pay each other, participants send payments in the form of channel updates that can be passed into this function. We check that the channel exists, that it is not settled, that it is not closed, and that the sequence number of this update is the highest of any received. We then check that all the arguments were signed by both participants. We've broken the actual update logic out into \"],[0,[2],1,\"updateStateInternal\"],[0,[],0,\", because it is called by other functions in the contract. You might notice that we don't check here if the amounts are correct. Someone could submit an update where the balances exceed the total that was put into the channel. We check the balances later, when the channel is closed, after all the hashlocks have been added up.\"]]],[1,\"h2\",[[0,[],0,\"State update bounties\"]]],[1,\"p\",[[0,[],0,\"`js function updateStateWithBounty(     bytes32 \"],[0,[3],1,\"channelId,     uint256 \"],[0,[],0,\"sequenceNumber,\"]]],[10,6],[1,\"p\",[[0,[],0,\") {     channelSettlingPeriodStarted(_channelId);\"]]],[10,7],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[2],1,\"updateStateWithBounty()\"],[0,[],0,\" allows channel participants to incentivize third parties to protect against cheating. Remember, the settling period gives anyone a chance to submit a signed update that has a higher sequence number than the currently accepted update. This prevents dishonest participants from submitting old updates where they have a higher balance. However, someone needs to be online to check whether the settling period has been started with an old update. This function allows the participants to reward someone who is online and stops them from being cheated. The participant simply sends the third party the state update and signatures and their signature on those values and a bounty amount. The third party can now watch the blockchain for an attempt to start the settling period with an old update. If it sees this, it can submit the correct update and collect the bounty.\"]]],[1,\"h2\",[[0,[],0,\"Submitting preimages\"]]],[1,\"p\",[[0,[],0,\"`js function submitPreimage (     bytes32 \"],[0,[3],1,\"hashed,     bytes32 \"],[0,[],0,\"preimage ) {     require(\"],[0,[3],1,\"hashed == sha3(\"],[0,[],0,\"preimage));     seenPreimage[_hashed] = true; }\"]]],[1,\"p\",[[0,[],0,\"function submitPreimages (     bytes pairs ) {     bytes32 hashed;     bytes32 preimage;\"]]],[10,8],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"As you will soon see, Guac's hashlocks follow a simple rule: if anyone has submitted the preimage of the hash, the associated money is unlocked. These functions are for submitting preimages. Preimages are not associated with any one channel. This makes the contract simpler, as well as allowing the reveal of a preimage motivated by money locked in any one particular channel to unlock the money in all the channels participating in that multihop transaction.\"]]],[1,\"h2\",[[0,[],0,\"Starting the settling period\"]]],[1,\"p\",[[0,[],0,\"`js function startSettlingPeriod (     bytes32 \"],[0,[3],1,\"channelId,     bytes \"],[0,[],0,\"signature ) {     channelExists(\"],[0,[3],1,\"channelId);     channelSettlingPeriodNotStarted(\"],[0,[],0,\"channelId);\"]]],[10,9],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"This only happens when one participant wants to close the channel without the participation of the other. After the settling period is over, the channel can be closed and the money can be taken out. We check that the channel exists and that the settling period has not already been started. We then check for a signature from one of the channel participants, and set \"],[0,[2],1,\"settlingPeriodStarted\"],[0,[],0,\" to true and settlingPeriodEnd to the current block plus the settling period length.\"]]],[1,\"h2\",[[0,[],0,\"Closing the channel\"]]],[1,\"p\",[[0,[],0,\"`js function closeChannel (     bytes32 \"],[0,[3],1,\"channelId ) {     channelExists(\"],[0,[],0,\"channelId);     channelIsSettled(\"],[0,[3],1,\"channelId);     channelIsNotClosed(\"],[0,[],0,\"channelId);\"]]],[10,10],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"If the channel is settled and has not yet been closed, it can be closed. This checks if the channel is settled and has not already been closed, then calls \"],[0,[2],1,\"closeChannelInternal()\"],[0,[],0,\", which contains the real business logic.\"]]],[1,\"h2\",[[0,[],0,\"Skipping the settling period\"]]],[1,\"p\",[[0,[],0,\"`js function closeChannelFast (     bytes32 _channelId,\"]]],[10,11],[1,\"p\",[[0,[],0,\") {     channelExists(\"],[0,[3],1,\"channelId);     sequenceNumberIsHighest(\"],[0,[],0,\"channelId, _sequenceNumber);\"]]],[10,12],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"If both participants agree to close the channel, they can skip the settling period with \"],[0,[2],1,\"closeChannelFast()\"],[0,[],0,\". They include the final state of the channel, and this function both applies the final update and closes the channel.\"]]],[1,\"h2\",[[0,[],0,\"Channel closing business logic\"]]],[1,\"p\",[[0,[],0,\"`js function closeChannelInternal (     bytes32 _channelId )     internal {     channels[_channelId].closed = true;\"]]],[10,13],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"This is the real meat of the payment channel logic. It figures out how much money to transfer back to each participant, while taking hashlocks into account. First, \"],[0,[2],1,\"closed\"],[0,[],0,\" is set to true. Then the amount of all the hashlocks is calculated by \"],[0,[2],1,\"getHashlockAdjustment()\"],[0,[],0,\", and applied to the balances by \"],[0,[2],1,\"applyHashlockAdjustment()\"],[0,[],0,\". Then the balances of the participants are incremented by the proper amounts, releasing the money from the channel.\"]]],[1,\"h3\",[[0,[],0,\"Calculating hashlocks\"]]],[1,\"p\",[[0,[],0,\"`js function getHashlockAdjustment (     bytes _hashlocks )      internal     returns (int256) {     bytes32 hashed;     int256 adjustment;     int256 totalAdjustment;\"]]],[10,14],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"getHashlockAdjustment()\"],[0,[2],1,\" calculates what effect the hashlocks in the last update have on the balances. We loop through and parse hashes and adjustments out of the hashlock array. There is a \"],[0,[],0,\"totalAdjustment` that is added to if the preimage for the hash corresponding to a given hashlock's adjustment has been seen. Putting all the hashlocks in an array like this lets us easily sign them all. This way of doing things does have a limit: you can only submit about 100-120 hashlocks before running out of gas (at least on our testing framework). However if it is necessary, large hubs processing a lot of transactions could have several parallel payment channels.\"]]],[1,\"h3\",[[0,[],0,\"Applying hashlocks\"]]],[1,\"p\",[[0,[],0,\"`js function applyHashlockAdjustment (     bytes32 \"],[0,[3],1,\"channelId,     uint256 \"],[0,[],0,\"currentBalance0,     uint256 \"],[0,[3],1,\"currentBalance1,     int256 \"],[0,[],0,\"totalAdjustment )     internal     returns (uint256, uint256) {     uint256 balance0;     uint256 balance1;\"]]],[10,15],[1,\"p\",[[0,[],0,\"} \"],[0,[],0,\"`\"]]],[1,\"p\",[[0,[],0,\"A hashlock's adjustment, and by extension the summed \"],[0,[2],1,\"totalAdjustment\"],[0,[],0,\" of all valid hashlocks, is a signed integer that is added to \"],[0,[2],1,\"balance0\"],[0,[],0,\" and subtracted from \"],[0,[2],1,\"balance1\"],[0,[],0,\". Because of peculiarities in Solidity's number types, it seemed safer and clearer to handle the case of negative and positive adjustments separately. A positive adjustment is straight forward. We cast it to an unsigned integer and do the math. However, when the adjustment is negative casting in Solidity doesn't work correctly. So we invert the sign to ensure that the number is positive and also subtract from balance0 instead of adding and vice versa for balance1. We then check that the balances still equal the total amount that was placed into the channel at the beginning and return the new balances.\"]]]]}","html":"<p>This is an article about our payment channel library, <a href=\"https://github.com/althea-mesh/guac\">Guac</a> on github.</p>\n\n<p>Althea&#39;s payment channels are key to how it works, but they are also one of the simpler parts to implement and explain. Payment channels allow payments to be made with a minimum of overhead. In the simple case, a payment can be made between two neighbors in the network with only one packet. The catch is that the neighbors need to have deposited money into the a payment channel contract beforehand to &quot;open the channel&quot;. However, channels can also be chained together using something called a &quot;hashlock&quot; to allow nodes to transact trustlessly over linked payment channels, without needing to be directly linked by a channel.</p>\n\n<p>There are already several channel implementations for Ethereum. The best-known one is Raiden. We found Raiden to be very monolithic and tied to a large Python offchain codebase. We cannot use Python on our routers. We need to use a language suited to embedded device programming, so we are using Rust (however, this blog post is only about the Solidity contract). Raiden also includes a lot of functionality we don&#39;t need, and is very complex in general. For example, they implement their own Merkel tree in Solidity. Maybe the complexity is warranted because it&#39;s intended to be a payment channel for every use case. Our application has relatively simple needs and payment channels are a concept that is well understood, so we decided it would be more expedient to use our own simple solution. </p>\n\n<p>There&#39;s also Machinomy. Machinomy is pretty clean, but it is a unidirectional channel. This means that money can only ever flow in one direction. You could set up two unidirectional channels, but this is still not as good as a bidirectional channel. To illustrate why, let&#39;s say Alice and Bob have both put 100 Ether in a bidirectional channel. If Alice sends Bob 100 Ether, and then Bob sends Alice 100 Ether, the channel will be back in the state it started at and ready to be used some more. If instead there are 2 unidirectional channels, then both participants sending each other 100 Ether over their 2 channels will result in both channels being exhausted. New channels will then need to be created, resulting in more blockchain transaction fees and waiting for confirmations. You could get into some stuff like letting unidirectional channels refill each other, but this is more complex than a bidirectional channel.</p>\n\n<p>We developed the theory underlying our payment channels based on some of Zack Hess&#39;s work back in 2015. You can read an explanation of the theory <a href=\"/blog/universal-payment-channels\">here</a>. For this blog post I&#39;m going to be focusing specifically on the Solidity payment channel contract in the current implementation of Althea.</p>\n\n<p>This code has not been audited, and may have obvious or subtle exploits that we are not aware of. Don&#39;t just copy and paste this and put a lot of money in it. If you do see an issue, let us know because we will gladly update this blog post to credit you and discuss the vulnerability.</p>\n\n<h2>Imports</h2>\n\n<p><code>\npragma solidity ^0.4.11;\nimport &quot;./ECVerify.sol&quot;;\nimport &quot;zeppelin-solidity/contracts/token/MintableToken.sol&quot;;\n</code>\nFirst, we import a couple of other contracts. <code>./ECVerify.sol</code> is a piece of code written by Alex Beregszaszi (@axic). The type of signatures used by Ethereum normally consist of 3 values, <code>R</code>, <code>S</code>, and <code>V</code>. ECVerify takes a byte array which consists of these three values concatenated. This keeps us from having to pass around 3 extra variables all over the place (the EVM can have issues with too many local variables) and is just cleaner. It also smoothes out some other quirks in the Ethereum signature scheme which are too ridiculous to get into.</p>\n\n<p><code>MintableToken.sol</code> is an ERC20 token contract provided by Open Zeppelin. It&#39;s probably more secure than if we were to try to make our own ERC20 token. None of the stuff in this contract deals with the ERC20 token functionality much, so we could probably plug in lots of different ERC20 variations if we wanted to.</p>\n\n<h2>Data structures</h2>\n\n<p><code></code>`js\ncontract PaymentChannels is ECVerify, MintableToken {\n    struct Channel {\n        bytes32 channelId;\n        address address0;\n        address address1;\n        uint256 totalBalance;</p>\n\n<pre><code>    uint256 balance0;\n    uint256 balance1;\n    bytes hashlocks;\n    uint256 sequenceNumber;\n\n    uint256 settlingPeriodLength;\n    bool settlingPeriodStarted;\n    uint256 settlingPeriodEnd;\n    bool closed;\n}\n\nmapping (bytes32 =&gt; Channel) public channels;\nmapping (bytes32 =&gt; bool) seenPreimage;</code></pre>\n\n<p>...\n<code></code>`</p>\n\n<p>Now we get into the actual contract. We inherit from the other contracts we imported above, so that we can use their functionalities. We also declare the channel data structure:</p>\n\n<ul><li><code>channelID</code> is a unique identifier for the channel.</li><li><code>address0</code> and address1 are the two Ethereum addresses that will be transacting over the channel.</li><li><code>totalBalance</code> is the total amount of money that both participants are putting in the channel. It needs to be the sum of balance0 and balance1</li><li><code>balance0</code> and balance1 are the amounts that address0 and address1 are putting in the channel.</li><li><code>hashlocks</code> is a byte array encoding any hashlocks that are active in the channel. There&#39;s parsing logic later in the contract that parses the hashlocks out of the byte array, since passing arrays of structs is not currently supported by Solidity.</li><li><p><code>sequenceNumber</code> is incremented with every channel update transaction, allowing this contract to only honor the latest valid update.</p></li><li><p><code>settlingPeriodLength</code> is the amount of time after a channel&#39;s settling period has started that must elapse before the channel can be closed and the money can be taken out.</p></li><li><code>settlingPeriodStarted</code>: whether the channel&#39;s settling period has started.</li><li><code>closed</code>: whether the channel has been closed.</li><li><code>settlingPeriodEnd</code> is the block height after which the channel can be closed.</li></ul>\n\n<p>We also declare 2 mappings. <code>channels</code> is for storing channels that have been created with the contract. <code>seenPreimage</code> is a mapping of hashes that records whether the contract has already been shown the preimage of the hash. This is used to implement the hashlocks. Making it global allows the reveal of one preimage to unlock hashlocked funds in several different channels, and uses less storage space. </p>\n\n<h2>Modifiers</h2>\n\n<p>Next come the modifiers. They are not declared with the <code>modifier</code> keyword, because for some reason it causes the Solidity compiler to complain about too many local variables. However, they have the exact same effect as modifiers when they are declared as functions and called at the top of a function body.</p>\n\n<h3>Lifecycle modifiers</h3>\n\n<p>These deal with the various lifecycle phases of the channel. This is to prevent functions getting called in phases of the lifecycle they are not allowed.</p>\n\n<p><code></code>`js\nfunction channelDoesNotExist (bytes32 _channelId) {\n    require(channels[<em>channelId].channelId != </em>channelId);\n}</p>\n\n<p>function channelExists (bytes32 _channelId) {\n    require(channels[<em>channelId].channelId == </em>channelId);\n}</p>\n\n<p>function channelSettlingPeriodStarted (bytes32 _channelId) {\n    require(channels[_channelId].settlingPeriodStarted);\n}</p>\n\n<p>function channelSettlingPeriodNotStarted (bytes32 _channelId) {\n    require(!channels[_channelId].settlingPeriodStarted);\n}</p>\n\n<p>function channelIsNotClosed (bytes32 _channelId) {\n    require(!channels[_channelId].closed);\n}</p>\n\n<p>function channelIsSettled (bytes32 _channelId) {\n    require(\n        channels[_channelId].settlingPeriodStarted &amp;&amp; // If the settling period has started\n        block.number &gt;= channels[_channelId].settlingPeriodEnd // And ended\n    );\n}</p>\n\n<p>function channelIsNotSettled (bytes32 _channelId) {\n    require(!( // Negate the below\n        channels[_channelId].settlingPeriodStarted &amp;&amp; // If the settling period is started\n        block.number &gt;= channels[_channelId].settlingPeriodEnd // And ended\n    ));\n}\n<code></code>`</p>\n\n<h3>State validity modifiers</h3>\n\n<p>These deal with making sure that state updates are valid. For a state update to be accepted, the new balances have to equal the total that was put in the channel, and it has to have the highest sequence number of all the updates that have been submitted.</p>\n\n<p><code></code>`js\nfunction balancesEqualTotal (bytes32 <em>channelId, uint256 </em>balance0, uint256 <em>balance1) {\n    require(</em>balance0.add(_balance1) == channels[_channelId].totalBalance);\n}</p>\n\n<p>function sequenceNumberIsHighest (bytes32 <em>channelId, uint256 </em>sequenceNumber) {\n    require(_sequenceNumber &gt; channels[_channelId].sequenceNumber);\n}\n<code></code>`</p>\n\n<h3>Signature modifiers</h3>\n\n<p>These check that the signatures submitted with function calls are correct. Some functions need signatures from both participants, and some only need signatures from one. Some functions only need one specific signature.</p>\n\n<p><code></code>`js\nfunction signedByBoth (\n    bytes32 <em>fingerprint, \n    bytes </em>signature0, \n    bytes <em>signature1, \n    address </em>address0,\n    address <em>address1\n) {\n    require(\n        ecverify(</em>fingerprint, <em>signature0, </em>address0) &amp;&amp;\n        ecverify(<em>fingerprint, </em>signature1, _address1)\n    );\n}</p>\n\n<p>function signedByOne (\n    bytes32 <em>fingerprint,\n    bytes </em>signature,\n    address <em>address0,\n    address </em>address1\n) {\n    require(\n        ecverify(<em>fingerprint, </em>signature, <em>address0) ||\n        ecverify(</em>fingerprint, <em>signature, </em>address1)\n    );\n}\n<code></code>`</p>\n\n<h2>ERC20 balance adjustment</h2>\n\n<p><code></code>`js\nfunction incrementBalance(address <em>addr, uint </em>value)\n    internal\n{\n    balances[_addr] = balances[<em>addr].add(</em>value);\n}</p>\n\n<p>function decrementBalance(address <em>addr, uint </em>value)\n    internal\n{\n    balances[_addr] = balances[<em>addr].sub(</em>value);\n}\n<code></code>`</p>\n\n<p>These functions increment and decrement the ERC20 balances. These could be used to create money out of thin air, so they must be handled carefully. They are used to put money into channels and take it out. It might have been possible to give each channel its own address in the ERC20 <code>balances</code> mapping to avoid doing this, but it would have had a lot more complexity and moving parts. The safe math functions (<code>.add</code> and <code>.sub</code>) supplied by the Zeppelin framework prevent any issues like balances going lower than 0.</p>\n\n<h2>Creating a channel</h2>\n\n<p><code></code>`js\nfunction newChannel(\n    bytes32 _channelId,</p>\n\n<pre><code>address _address0,\naddress _address1,\n\nuint256 _balance0,\nuint256 _balance1,\n\nuint256 _settlingPeriodLength,\n\nbytes _signature0,\nbytes _signature1</code></pre>\n\n<p>) {\n    channelDoesNotExist(<em>channelId);\n    bytes32 fingerprint = sha3(\n        &quot;newChannel&quot;,\n        </em>channelId,</p>\n\n<pre><code>    _address0,\n    _address1,\n\n    _balance0,\n    _balance1,\n\n    _settlingPeriodLength\n);\n\nsignedByBoth(\n    fingerprint,\n    _signature0,\n    _signature1,\n    _address0,\n    _address1\n);\n\ndecrementBalance(_address0, _balance0);\ndecrementBalance(_address1, _balance1);\n\nchannels[_channelId] = Channel(\n    _channelId,                  // bytes32 channelId;\n    _address0,                   // address address0;\n    _address1,                   // address address1;\n    _balance0.add(_balance1),    // uint256 totalBalance;\n\n    _balance0,                   // uint256 balance0;\n    _balance1,                   // uint256 balance1;\n    new bytes(0),                // bytes hashlocks\n    0,                           // uint256 sequenceNumber;\n\n    _settlingPeriodLength,       // uint256 settlingPeriodLength;\n    false,                       // bool settlingPeriodStarted;\n    0,                           // uint256 settlingPeriodEnd;\n    false                        // bool closed;\n\n);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>To create a new channel, someone needs to call <code>newChannel()</code> with the signatures of both participants. We first check that a channel with that <code>channelId</code> does not already exist. Then we check the signatures and attempt to withdraw the money from the accounts of both participants. Finally, we create a record of the channel.</p>\n\n<h2>Updating channel state</h2>\n\n<p><code></code>`js\nfunction updateState(\n    bytes32 <em>channelId,\n    uint256 </em>sequenceNumber,</p>\n\n<pre><code>uint256 _balance0,\nuint256 _balance1,\n\nbytes _hashlocks,\n\nbytes _signature0,\nbytes _signature1</code></pre>\n\n<p>) {\n    channelExists(<em>channelId);\n    channelIsNotSettled(</em>channelId);\n    channelIsNotClosed(<em>channelId);\n    sequenceNumberIsHighest(</em>channelId, _sequenceNumber);</p>\n\n<pre><code>bytes32 fingerprint = sha3(\n    &quot;updateState&quot;,\n    _channelId,\n    _sequenceNumber,\n    _balance0,\n    _balance1,\n    _hashlocks\n);\n\nsignedByBoth(\n    fingerprint,\n    _signature0,\n    _signature1,\n    channels[_channelId].address0,\n    channels[_channelId].address1\n);\n\nupdateStateInternal(\n    _channelId,\n    _sequenceNumber,\n\n    _balance0,\n    _balance1,\n\n    _hashlocks\n);</code></pre>\n\n<p>}</p>\n\n<p>function updateStateInternal (\n    bytes32 <em>channelId,\n    uint256 </em>sequenceNumber,</p>\n\n<pre><code>uint256 _balance0,\nuint256 _balance1,\n\nbytes _hashlocks</code></pre>\n\n<p>)\n    internal\n{\n    channels[<em>channelId].sequenceNumber = </em>sequenceNumber;\n    channels[<em>channelId].balance0 = </em>balance0;\n    channels[<em>channelId].balance1 = </em>balance1;\n    channels[<em>channelId].hashlocks = </em>hashlocks;\n}\n<code></code>`</p>\n\n<p>To pay each other, participants send payments in the form of channel updates that can be passed into this function. We check that the channel exists, that it is not settled, that it is not closed, and that the sequence number of this update is the highest of any received. We then check that all the arguments were signed by both participants. We&#39;ve broken the actual update logic out into <code>updateStateInternal</code>, because it is called by other functions in the contract. You might notice that we don&#39;t check here if the amounts are correct. Someone could submit an update where the balances exceed the total that was put into the channel. We check the balances later, when the channel is closed, after all the hashlocks have been added up.</p>\n\n<h2>State update bounties</h2>\n\n<p><code></code>`js\nfunction updateStateWithBounty(\n    bytes32 <em>channelId,\n    uint256 </em>sequenceNumber,</p>\n\n<pre><code>uint256 _balance0,\nuint256 _balance1,\n\nbytes _hashlocks,\n\nbytes _signature0,\nbytes _signature1,\n\nuint256 _bountyAmount,\nbytes _bountySignature</code></pre>\n\n<p>) {\n    channelSettlingPeriodStarted(_channelId);</p>\n\n<pre><code>bytes32 fingerprint = sha3(\n    &quot;updateStateWithBounty&quot;,\n    _channelId,\n    _sequenceNumber,\n    _balance0,\n    _balance1,\n    _hashlocks,\n    _signature0,\n    _signature1,\n    _bountyAmount\n);\n\naddress bountyPayer = ecrecovery(fingerprint, _bountySignature);\n\ndecrementBalance(bountyPayer, _bountyAmount);\nincrementBalance(msg.sender, _bountyAmount);\n\nupdateState(\n    _channelId,\n    _sequenceNumber,\n\n    _balance0,\n    _balance1,\n\n    _hashlocks,\n\n    _signature0,\n    _signature1\n);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p><code>updateStateWithBounty()</code> allows channel participants to incentivize third parties to protect against cheating. Remember, the settling period gives anyone a chance to submit a signed update that has a higher sequence number than the currently accepted update. This prevents dishonest participants from submitting old updates where they have a higher balance. However, someone needs to be online to check whether the settling period has been started with an old update. This function allows the participants to reward someone who is online and stops them from being cheated. The participant simply sends the third party the state update and signatures and their signature on those values and a bounty amount. The third party can now watch the blockchain for an attempt to start the settling period with an old update. If it sees this, it can submit the correct update and collect the bounty.</p>\n\n<h2>Submitting preimages</h2>\n\n<p><code></code>`js\nfunction submitPreimage (\n    bytes32 <em>hashed,\n    bytes32 </em>preimage\n) {\n    require(<em>hashed == sha3(</em>preimage));\n    seenPreimage[_hashed] = true;\n}</p>\n\n<p>function submitPreimages (\n    bytes pairs\n) {\n    bytes32 hashed;\n    bytes32 preimage;</p>\n\n<pre><code>for (uint256 i = 0; i &lt; pairs.length; i += 64) {\n    uint256 hashedOffset = i + 32;\n    uint256 preimageOffset = i + 64;\n\n    assembly {\n        hashed := mload(add(pairs, hashedOffset))\n        preimage := mload(add(pairs, preimageOffset))\n    }\n\n    submitPreimage(hashed, preimage);\n}</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>As you will soon see, Guac&#39;s hashlocks follow a simple rule: if anyone has submitted the preimage of the hash, the associated money is unlocked. These functions are for submitting preimages. Preimages are not associated with any one channel. This makes the contract simpler, as well as allowing the reveal of a preimage motivated by money locked in any one particular channel to unlock the money in all the channels participating in that multihop transaction.</p>\n\n<h2>Starting the settling period</h2>\n\n<p><code></code>`js\nfunction startSettlingPeriod (\n    bytes32 <em>channelId,\n    bytes </em>signature\n) {\n    channelExists(<em>channelId);\n    channelSettlingPeriodNotStarted(</em>channelId);</p>\n\n<pre><code>bytes32 fingerprint = sha3(\n    &quot;startSettlingPeriod&quot;,\n    _channelId\n);\n\nsignedByOne(\n    fingerprint,\n    _signature,\n    channels[_channelId].address0,\n    channels[_channelId].address1\n);\n\nchannels[_channelId].settlingPeriodStarted = true;\nchannels[_channelId].settlingPeriodEnd = block.number + channels[_channelId].settlingPeriodLength;</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>This only happens when one participant wants to close the channel without the participation of the other. After the settling period is over, the channel can be closed and the money can be taken out. We check that the channel exists and that the settling period has not already been started. We then check for a signature from one of the channel participants, and set <code>settlingPeriodStarted</code> to true and settlingPeriodEnd to the current block plus the settling period length.</p>\n\n<h2>Closing the channel</h2>\n\n<p><code></code>`js\nfunction closeChannel (\n    bytes32 <em>channelId\n) {\n    channelExists(</em>channelId);\n    channelIsSettled(<em>channelId);\n    channelIsNotClosed(</em>channelId);</p>\n\n<pre><code>closeChannelInternal(_channelId);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>If the channel is settled and has not yet been closed, it can be closed. This checks if the channel is settled and has not already been closed, then calls <code>closeChannelInternal()</code>, which contains the real business logic.</p>\n\n<h2>Skipping the settling period</h2>\n\n<p><code></code>`js\nfunction closeChannelFast (\n    bytes32 _channelId,</p>\n\n<pre><code>uint256 _sequenceNumber,\nuint256 _balance0,\nuint256 _balance1,\nbytes _hashlocks,\n\nbytes _signature0,\nbytes _signature1</code></pre>\n\n<p>) {\n    channelExists(<em>channelId);\n    sequenceNumberIsHighest(</em>channelId, _sequenceNumber);</p>\n\n<pre><code>bytes32 fingerprint = sha3(\n    &quot;closeChannelFast&quot;,\n    _channelId,\n    _sequenceNumber,\n    _balance0,\n    _balance1,\n    _hashlocks\n);\n\nsignedByBoth(\n    fingerprint,\n    _signature0,\n    _signature1,\n    channels[_channelId].address0,\n    channels[_channelId].address1\n);\n\nupdateStateInternal(\n    _channelId,\n    _sequenceNumber,\n    _balance0,\n    _balance1,\n    _hashlocks\n);\n\ncloseChannelInternal(_channelId);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>If both participants agree to close the channel, they can skip the settling period with <code>closeChannelFast()</code>. They include the final state of the channel, and this function both applies the final update and closes the channel.</p>\n\n<h2>Channel closing business logic</h2>\n\n<p><code></code>`js\nfunction closeChannelInternal (\n    bytes32 _channelId\n)\n    internal\n{\n    channels[_channelId].closed = true;</p>\n\n<pre><code>int256 adjustment = getHashlockAdjustment(channels[_channelId].hashlocks);\n\nuint256 balance0;\nuint256 balance1;\n(balance0, balance1) = applyHashlockAdjustment(\n    _channelId,\n    channels[_channelId].balance0,\n    channels[_channelId].balance1,\n    adjustment\n);\n\nincrementBalance(channels[_channelId].address0, balance0);\nincrementBalance(channels[_channelId].address1, balance1);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>This is the real meat of the payment channel logic. It figures out how much money to transfer back to each participant, while taking hashlocks into account. First, <code>closed</code> is set to true. Then the amount of all the hashlocks is calculated by <code>getHashlockAdjustment()</code>, and applied to the balances by <code>applyHashlockAdjustment()</code>. Then the balances of the participants are incremented by the proper amounts, releasing the money from the channel.</p>\n\n<h3>Calculating hashlocks</h3>\n\n<p><code></code>`js\nfunction getHashlockAdjustment (\n    bytes _hashlocks\n) \n    internal\n    returns (int256)\n{\n    bytes32 hashed;\n    int256 adjustment;\n    int256 totalAdjustment;</p>\n\n<pre><code>for (uint256 i = 0; i &lt; _hashlocks.length; i += 64) {\n    uint256 hashedOffset = i + 32;\n    uint256 adjustmentOffset = i + 64;\n\n    assembly {\n        hashed := mload(add(_hashlocks, hashedOffset))\n        adjustment := mload(add(_hashlocks, adjustmentOffset))\n    }\n\n    if (seenPreimage[hashed]) {\n        totalAdjustment += adjustment;\n    }\n}\n\nreturn totalAdjustment;</code></pre>\n\n<p>}\n<code></code><code>\n</code>getHashlockAdjustment()<code> calculates what effect the hashlocks in the last update have on the balances. We loop through and parse hashes and adjustments out of the hashlock array. There is a </code>totalAdjustment` that is added to if the preimage for the hash corresponding to a given hashlock&#39;s adjustment has been seen. Putting all the hashlocks in an array like this lets us easily sign them all. This way of doing things does have a limit: you can only submit about 100-120 hashlocks before running out of gas (at least on our testing framework). However if it is necessary, large hubs processing a lot of transactions could have several parallel payment channels.</p>\n\n<h3>Applying hashlocks</h3>\n\n<p><code></code>`js\nfunction applyHashlockAdjustment (\n    bytes32 <em>channelId,\n    uint256 </em>currentBalance0,\n    uint256 <em>currentBalance1,\n    int256 </em>totalAdjustment\n)\n    internal\n    returns (uint256, uint256)\n{\n    uint256 balance0;\n    uint256 balance1;</p>\n\n<pre><code>if (_totalAdjustment &gt; 0) {\n    balance0 = _currentBalance0.add(uint256(_totalAdjustment));\n    balance1 = _currentBalance1.sub(uint256(_totalAdjustment));\n}\n\nif (_totalAdjustment &lt; 0) {\n    balance0 = _currentBalance0.sub(uint256(-_totalAdjustment));\n    balance1 = _currentBalance1.add(uint256(-_totalAdjustment));\n}\n\nif (_totalAdjustment == 0) {\n    balance0 = _currentBalance0;\n    balance1 = _currentBalance1;\n}\n\nbalancesEqualTotal(_channelId, balance0, balance1);\nreturn (balance0, balance1);</code></pre>\n\n<p>}\n<code></code>`</p>\n\n<p>A hashlock&#39;s adjustment, and by extension the summed <code>totalAdjustment</code> of all valid hashlocks, is a signed integer that is added to <code>balance0</code> and subtracted from <code>balance1</code>. Because of peculiarities in Solidity&#39;s number types, it seemed safer and clearer to handle the case of negative and positive adjustments separately. A positive adjustment is straight forward. We cast it to an unsigned integer and do the math. However, when the adjustment is negative casting in Solidity doesn&#39;t work correctly. So we invert the sign to ensure that the number is positive and also subtract from balance0 instead of adding and vice versa for balance1. We then check that the balances still equal the total amount that was placed into the channel at the beginning and return the new balances.</p>","comment_id":null,"plaintext":"This is an article about our payment channel library, [Guac](https://github.com/althea-mesh/guac) on github.\n\nAlthea's payment channels are key to how it works, but they are also one of the simpler parts to implement and explain. Payment channels allow payments to be made with a minimum of overhead. In the simple case, a payment can be made between two neighbors in the network with only one packet. The catch is that the neighbors need to have deposited money into the a payment channel contract beforehand to \"open the channel\". However, channels can also be chained together using something called a \"hashlock\" to allow nodes to transact trustlessly over linked payment channels, without needing to be directly linked by a channel.\n\nThere are already several channel implementations for Ethereum. The best-known one is Raiden. We found Raiden to be very monolithic and tied to a large Python offchain codebase. We cannot use Python on our routers. We need to use a language suited to embedded device programming, so we are using Rust (however, this blog post is only about the Solidity contract). Raiden also includes a lot of functionality we don't need, and is very complex in general. For example, they implement their own Merkel tree in Solidity. Maybe the complexity is warranted because it's intended to be a payment channel for every use case. Our application has relatively simple needs and payment channels are a concept that is well understood, so we decided it would be more expedient to use our own simple solution. \n\nThere's also Machinomy. Machinomy is pretty clean, but it is a unidirectional channel. This means that money can only ever flow in one direction. You could set up two unidirectional channels, but this is still not as good as a bidirectional channel. To illustrate why, let's say Alice and Bob have both put 100 Ether in a bidirectional channel. If Alice sends Bob 100 Ether, and then Bob sends Alice 100 Ether, the channel will be back in the state it started at and ready to be used some more. If instead there are 2 unidirectional channels, then both participants sending each other 100 Ether over their 2 channels will result in both channels being exhausted. New channels will then need to be created, resulting in more blockchain transaction fees and waiting for confirmations. You could get into some stuff like letting unidirectional channels refill each other, but this is more complex than a bidirectional channel.\n\nWe developed the theory underlying our payment channels based on some of Zack Hess's work back in 2015. You can read an explanation of the theory [here](/blog/universal-payment-channels). For this blog post I'm going to be focusing specifically on the Solidity payment channel contract in the current implementation of Althea.\n\nThis code has not been audited, and may have obvious or subtle exploits that we are not aware of. Don't just copy and paste this and put a lot of money in it. If you do see an issue, let us know because we will gladly update this blog post to credit you and discuss the vulnerability.\n\n## Imports\n\n```\npragma solidity ^0.4.11;\nimport \"./ECVerify.sol\";\nimport \"zeppelin-solidity/contracts/token/MintableToken.sol\";\n```\nFirst, we import a couple of other contracts. `./ECVerify.sol` is a piece of code written by Alex Beregszaszi (@axic). The type of signatures used by Ethereum normally consist of 3 values, `R`, `S`, and `V`. ECVerify takes a byte array which consists of these three values concatenated. This keeps us from having to pass around 3 extra variables all over the place (the EVM can have issues with too many local variables) and is just cleaner. It also smoothes out some other quirks in the Ethereum signature scheme which are too ridiculous to get into.\n\n`MintableToken.sol` is an ERC20 token contract provided by Open Zeppelin. It's probably more secure than if we were to try to make our own ERC20 token. None of the stuff in this contract deals with the ERC20 token functionality much, so we could probably plug in lots of different ERC20 variations if we wanted to.\n\n## Data structures\n\n```js\ncontract PaymentChannels is ECVerify, MintableToken {\n    struct Channel {\n        bytes32 channelId;\n        address address0;\n        address address1;\n        uint256 totalBalance;\n\n        uint256 balance0;\n        uint256 balance1;\n        bytes hashlocks;\n        uint256 sequenceNumber;\n\n        uint256 settlingPeriodLength;\n        bool settlingPeriodStarted;\n        uint256 settlingPeriodEnd;\n        bool closed;\n    }\n\n    mapping (bytes32 => Channel) public channels;\n    mapping (bytes32 => bool) seenPreimage;\n...\n```\n\nNow we get into the actual contract. We inherit from the other contracts we imported above, so that we can use their functionalities. We also declare the channel data structure:\n\n- `channelID` is a unique identifier for the channel.\n- `address0` and address1 are the two Ethereum addresses that will be transacting over the channel.\n- `totalBalance` is the total amount of money that both participants are putting in the channel. It needs to be the sum of balance0 and balance1\n- `balance0` and balance1 are the amounts that address0 and address1 are putting in the channel.\n- `hashlocks` is a byte array encoding any hashlocks that are active in the channel. There's parsing logic later in the contract that parses the hashlocks out of the byte array, since passing arrays of structs is not currently supported by Solidity.\n- `sequenceNumber` is incremented with every channel update transaction, allowing this contract to only honor the latest valid update.\n\n- `settlingPeriodLength` is the amount of time after a channel's settling period has started that must elapse before the channel can be closed and the money can be taken out.\n- `settlingPeriodStarted`: whether the channel's settling period has started.\n- `closed`: whether the channel has been closed.\n- `settlingPeriodEnd` is the block height after which the channel can be closed.\n\nWe also declare 2 mappings. `channels` is for storing channels that have been created with the contract. `seenPreimage` is a mapping of hashes that records whether the contract has already been shown the preimage of the hash. This is used to implement the hashlocks. Making it global allows the reveal of one preimage to unlock hashlocked funds in several different channels, and uses less storage space. \n\n\n\n## Modifiers\n\nNext come the modifiers. They are not declared with the `modifier` keyword, because for some reason it causes the Solidity compiler to complain about too many local variables. However, they have the exact same effect as modifiers when they are declared as functions and called at the top of a function body.\n\n### Lifecycle modifiers\n\nThese deal with the various lifecycle phases of the channel. This is to prevent functions getting called in phases of the lifecycle they are not allowed.\n\n```js\nfunction channelDoesNotExist (bytes32 _channelId) {\n    require(channels[_channelId].channelId != _channelId);\n}\n\nfunction channelExists (bytes32 _channelId) {\n    require(channels[_channelId].channelId == _channelId);\n}\n\nfunction channelSettlingPeriodStarted (bytes32 _channelId) {\n    require(channels[_channelId].settlingPeriodStarted);\n}\n\nfunction channelSettlingPeriodNotStarted (bytes32 _channelId) {\n    require(!channels[_channelId].settlingPeriodStarted);\n}\n\nfunction channelIsNotClosed (bytes32 _channelId) {\n    require(!channels[_channelId].closed);\n}\n\nfunction channelIsSettled (bytes32 _channelId) {\n    require(\n        channels[_channelId].settlingPeriodStarted && // If the settling period has started\n        block.number >= channels[_channelId].settlingPeriodEnd // And ended\n    );\n}\n\nfunction channelIsNotSettled (bytes32 _channelId) {\n    require(!( // Negate the below\n        channels[_channelId].settlingPeriodStarted && // If the settling period is started\n        block.number >= channels[_channelId].settlingPeriodEnd // And ended\n    ));\n}\n```\n\n### State validity modifiers\n\nThese deal with making sure that state updates are valid. For a state update to be accepted, the new balances have to equal the total that was put in the channel, and it has to have the highest sequence number of all the updates that have been submitted.\n\n```js\nfunction balancesEqualTotal (bytes32 _channelId, uint256 _balance0, uint256 _balance1) {\n    require(_balance0.add(_balance1) == channels[_channelId].totalBalance);\n}\n\nfunction sequenceNumberIsHighest (bytes32 _channelId, uint256 _sequenceNumber) {\n    require(_sequenceNumber > channels[_channelId].sequenceNumber);\n}\n```\n\n### Signature modifiers\n\nThese check that the signatures submitted with function calls are correct. Some functions need signatures from both participants, and some only need signatures from one. Some functions only need one specific signature.\n\n```js\nfunction signedByBoth (\n    bytes32 _fingerprint, \n    bytes _signature0, \n    bytes _signature1, \n    address _address0,\n    address _address1\n) {\n    require(\n        ecverify(_fingerprint, _signature0, _address0) &&\n        ecverify(_fingerprint, _signature1, _address1)\n    );\n}\n\nfunction signedByOne (\n    bytes32 _fingerprint,\n    bytes _signature,\n    address _address0,\n    address _address1\n) {\n    require(\n        ecverify(_fingerprint, _signature, _address0) ||\n        ecverify(_fingerprint, _signature, _address1)\n    );\n}\n```\n\n## ERC20 balance adjustment\n\n```js\nfunction incrementBalance(address _addr, uint _value)\n    internal\n{\n    balances[_addr] = balances[_addr].add(_value);\n}\n\nfunction decrementBalance(address _addr, uint _value)\n    internal\n{\n    balances[_addr] = balances[_addr].sub(_value);\n}\n```\n\nThese functions increment and decrement the ERC20 balances. These could be used to create money out of thin air, so they must be handled carefully. They are used to put money into channels and take it out. It might have been possible to give each channel its own address in the ERC20 `balances` mapping to avoid doing this, but it would have had a lot more complexity and moving parts. The safe math functions (`.add` and `.sub`) supplied by the Zeppelin framework prevent any issues like balances going lower than 0.\n\n## Creating a channel\n\n```js\nfunction newChannel(\n    bytes32 _channelId,\n\n    address _address0,\n    address _address1,\n\n    uint256 _balance0,\n    uint256 _balance1,\n\n    uint256 _settlingPeriodLength,\n\n    bytes _signature0,\n    bytes _signature1\n) {\n    channelDoesNotExist(_channelId);\n    bytes32 fingerprint = sha3(\n        \"newChannel\",\n        _channelId,\n\n        _address0,\n        _address1,\n\n        _balance0,\n        _balance1,\n\n        _settlingPeriodLength\n    );\n\n    signedByBoth(\n        fingerprint,\n        _signature0,\n        _signature1,\n        _address0,\n        _address1\n    );\n\n    decrementBalance(_address0, _balance0);\n    decrementBalance(_address1, _balance1);\n\n    channels[_channelId] = Channel(\n        _channelId,                  // bytes32 channelId;\n        _address0,                   // address address0;\n        _address1,                   // address address1;\n        _balance0.add(_balance1),    // uint256 totalBalance;\n        \n        _balance0,                   // uint256 balance0;\n        _balance1,                   // uint256 balance1;\n        new bytes(0),                // bytes hashlocks\n        0,                           // uint256 sequenceNumber;\n\n        _settlingPeriodLength,       // uint256 settlingPeriodLength;\n        false,                       // bool settlingPeriodStarted;\n        0,                           // uint256 settlingPeriodEnd;\n        false                        // bool closed;\n\n    );\n}\n```\n\nTo create a new channel, someone needs to call `newChannel()` with the signatures of both participants. We first check that a channel with that `channelId` does not already exist. Then we check the signatures and attempt to withdraw the money from the accounts of both participants. Finally, we create a record of the channel.\n\n## Updating channel state\n\n```js\nfunction updateState(\n    bytes32 _channelId,\n    uint256 _sequenceNumber,\n\n    uint256 _balance0,\n    uint256 _balance1,\n\n    bytes _hashlocks,\n\n    bytes _signature0,\n    bytes _signature1\n) {\n    channelExists(_channelId);\n    channelIsNotSettled(_channelId);\n    channelIsNotClosed(_channelId);\n    sequenceNumberIsHighest(_channelId, _sequenceNumber);\n\n    bytes32 fingerprint = sha3(\n        \"updateState\",\n        _channelId,\n        _sequenceNumber,\n        _balance0,\n        _balance1,\n        _hashlocks\n    );\n\n    signedByBoth(\n        fingerprint,\n        _signature0,\n        _signature1,\n        channels[_channelId].address0,\n        channels[_channelId].address1\n    );\n\n    updateStateInternal(\n        _channelId,\n        _sequenceNumber,\n\n        _balance0,\n        _balance1,\n\n        _hashlocks\n    );\n}\n\nfunction updateStateInternal (\n    bytes32 _channelId,\n    uint256 _sequenceNumber,\n\n    uint256 _balance0,\n    uint256 _balance1,\n\n    bytes _hashlocks\n)\n    internal\n{\n    channels[_channelId].sequenceNumber = _sequenceNumber;\n    channels[_channelId].balance0 = _balance0;\n    channels[_channelId].balance1 = _balance1;\n    channels[_channelId].hashlocks = _hashlocks;\n}\n```\n\nTo pay each other, participants send payments in the form of channel updates that can be passed into this function. We check that the channel exists, that it is not settled, that it is not closed, and that the sequence number of this update is the highest of any received. We then check that all the arguments were signed by both participants. We've broken the actual update logic out into `updateStateInternal`, because it is called by other functions in the contract. You might notice that we don't check here if the amounts are correct. Someone could submit an update where the balances exceed the total that was put into the channel. We check the balances later, when the channel is closed, after all the hashlocks have been added up.\n\n## State update bounties\n\n\n```js\nfunction updateStateWithBounty(\n    bytes32 _channelId,\n    uint256 _sequenceNumber,\n\n    uint256 _balance0,\n    uint256 _balance1,\n\n    bytes _hashlocks,\n\n    bytes _signature0,\n    bytes _signature1,\n\n    uint256 _bountyAmount,\n    bytes _bountySignature\n) {\n    channelSettlingPeriodStarted(_channelId);\n\n    bytes32 fingerprint = sha3(\n        \"updateStateWithBounty\",\n        _channelId,\n        _sequenceNumber,\n        _balance0,\n        _balance1,\n        _hashlocks,\n        _signature0,\n        _signature1,\n        _bountyAmount\n    );\n\n    address bountyPayer = ecrecovery(fingerprint, _bountySignature);\n\n    decrementBalance(bountyPayer, _bountyAmount);\n    incrementBalance(msg.sender, _bountyAmount);\n\n    updateState(\n        _channelId,\n        _sequenceNumber,\n\n        _balance0,\n        _balance1,\n\n        _hashlocks,\n\n        _signature0,\n        _signature1\n    );\n}\n```\n\n`updateStateWithBounty()` allows channel participants to incentivize third parties to protect against cheating. Remember, the settling period gives anyone a chance to submit a signed update that has a higher sequence number than the currently accepted update. This prevents dishonest participants from submitting old updates where they have a higher balance. However, someone needs to be online to check whether the settling period has been started with an old update. This function allows the participants to reward someone who is online and stops them from being cheated. The participant simply sends the third party the state update and signatures and their signature on those values and a bounty amount. The third party can now watch the blockchain for an attempt to start the settling period with an old update. If it sees this, it can submit the correct update and collect the bounty.\n\n## Submitting preimages\n\n```js\nfunction submitPreimage (\n    bytes32 _hashed,\n    bytes32 _preimage\n) {\n    require(_hashed == sha3(_preimage));\n    seenPreimage[_hashed] = true;\n}\n\nfunction submitPreimages (\n    bytes pairs\n) {\n    bytes32 hashed;\n    bytes32 preimage;\n\n    for (uint256 i = 0; i < pairs.length; i += 64) {\n        uint256 hashedOffset = i + 32;\n        uint256 preimageOffset = i + 64;\n\n        assembly {\n            hashed := mload(add(pairs, hashedOffset))\n            preimage := mload(add(pairs, preimageOffset))\n        }\n\n        submitPreimage(hashed, preimage);\n    }\n}\n```\n\nAs you will soon see, Guac's hashlocks follow a simple rule: if anyone has submitted the preimage of the hash, the associated money is unlocked. These functions are for submitting preimages. Preimages are not associated with any one channel. This makes the contract simpler, as well as allowing the reveal of a preimage motivated by money locked in any one particular channel to unlock the money in all the channels participating in that multihop transaction.\n\n## Starting the settling period\n\n```js\nfunction startSettlingPeriod (\n    bytes32 _channelId,\n    bytes _signature\n) {\n    channelExists(_channelId);\n    channelSettlingPeriodNotStarted(_channelId);\n\n    bytes32 fingerprint = sha3(\n        \"startSettlingPeriod\",\n        _channelId\n    );\n\n    signedByOne(\n        fingerprint,\n        _signature,\n        channels[_channelId].address0,\n        channels[_channelId].address1\n    );\n\n    channels[_channelId].settlingPeriodStarted = true;\n    channels[_channelId].settlingPeriodEnd = block.number + channels[_channelId].settlingPeriodLength;\n}\n```\n\nThis only happens when one participant wants to close the channel without the participation of the other. After the settling period is over, the channel can be closed and the money can be taken out. We check that the channel exists and that the settling period has not already been started. We then check for a signature from one of the channel participants, and set `settlingPeriodStarted` to true and settlingPeriodEnd to the current block plus the settling period length.\n\n## Closing the channel\n\n```js\nfunction closeChannel (\n    bytes32 _channelId\n) {\n    channelExists(_channelId);\n    channelIsSettled(_channelId);\n    channelIsNotClosed(_channelId);\n\n    closeChannelInternal(_channelId);\n}\n```\n\nIf the channel is settled and has not yet been closed, it can be closed. This checks if the channel is settled and has not already been closed, then calls `closeChannelInternal()`, which contains the real business logic.\n\n## Skipping the settling period\n\n```js\nfunction closeChannelFast (\n    bytes32 _channelId,\n\n    uint256 _sequenceNumber,\n    uint256 _balance0,\n    uint256 _balance1,\n    bytes _hashlocks,\n\n    bytes _signature0,\n    bytes _signature1\n) {\n    channelExists(_channelId);\n    sequenceNumberIsHighest(_channelId, _sequenceNumber);\n\n    bytes32 fingerprint = sha3(\n        \"closeChannelFast\",\n        _channelId,\n        _sequenceNumber,\n        _balance0,\n        _balance1,\n        _hashlocks\n    );\n\n    signedByBoth(\n        fingerprint,\n        _signature0,\n        _signature1,\n        channels[_channelId].address0,\n        channels[_channelId].address1\n    );\n\n    updateStateInternal(\n        _channelId,\n        _sequenceNumber,\n        _balance0,\n        _balance1,\n        _hashlocks\n    );\n\n    closeChannelInternal(_channelId);\n}\n```\n\nIf both participants agree to close the channel, they can skip the settling period with `closeChannelFast()`. They include the final state of the channel, and this function both applies the final update and closes the channel.\n\n## Channel closing business logic\n\n```js\nfunction closeChannelInternal (\n    bytes32 _channelId\n)\n    internal\n{\n    channels[_channelId].closed = true;\n\n    int256 adjustment = getHashlockAdjustment(channels[_channelId].hashlocks);\n\n    uint256 balance0;\n    uint256 balance1;\n    (balance0, balance1) = applyHashlockAdjustment(\n        _channelId,\n        channels[_channelId].balance0,\n        channels[_channelId].balance1,\n        adjustment\n    );\n\n    incrementBalance(channels[_channelId].address0, balance0);\n    incrementBalance(channels[_channelId].address1, balance1);\n}\n```\n\nThis is the real meat of the payment channel logic. It figures out how much money to transfer back to each participant, while taking hashlocks into account. First, `closed` is set to true. Then the amount of all the hashlocks is calculated by `getHashlockAdjustment()`, and applied to the balances by `applyHashlockAdjustment()`. Then the balances of the participants are incremented by the proper amounts, releasing the money from the channel.\n\n### Calculating hashlocks\n\n```js\nfunction getHashlockAdjustment (\n    bytes _hashlocks\n) \n    internal\n    returns (int256)\n{\n    bytes32 hashed;\n    int256 adjustment;\n    int256 totalAdjustment;\n\n    for (uint256 i = 0; i < _hashlocks.length; i += 64) {\n        uint256 hashedOffset = i + 32;\n        uint256 adjustmentOffset = i + 64;\n\n        assembly {\n            hashed := mload(add(_hashlocks, hashedOffset))\n            adjustment := mload(add(_hashlocks, adjustmentOffset))\n        }\n\n        if (seenPreimage[hashed]) {\n            totalAdjustment += adjustment;\n        }\n    }\n\n    return totalAdjustment;\n}\n```\n`getHashlockAdjustment()` calculates what effect the hashlocks in the last update have on the balances. We loop through and parse hashes and adjustments out of the hashlock array. There is a `totalAdjustment` that is added to if the preimage for the hash corresponding to a given hashlock's adjustment has been seen. Putting all the hashlocks in an array like this lets us easily sign them all. This way of doing things does have a limit: you can only submit about 100-120 hashlocks before running out of gas (at least on our testing framework). However if it is necessary, large hubs processing a lot of transactions could have several parallel payment channels.\n\n### Applying hashlocks\n\n```js\nfunction applyHashlockAdjustment (\n    bytes32 _channelId,\n    uint256 _currentBalance0,\n    uint256 _currentBalance1,\n    int256 _totalAdjustment\n)\n    internal\n    returns (uint256, uint256)\n{\n    uint256 balance0;\n    uint256 balance1;\n\n    if (_totalAdjustment > 0) {\n        balance0 = _currentBalance0.add(uint256(_totalAdjustment));\n        balance1 = _currentBalance1.sub(uint256(_totalAdjustment));\n    }\n\n    if (_totalAdjustment < 0) {\n        balance0 = _currentBalance0.sub(uint256(-_totalAdjustment));\n        balance1 = _currentBalance1.add(uint256(-_totalAdjustment));\n    }\n\n    if (_totalAdjustment == 0) {\n        balance0 = _currentBalance0;\n        balance1 = _currentBalance1;\n    }\n\n    balancesEqualTotal(_channelId, balance0, balance1);\n    return (balance0, balance1);\n}\n```\n\nA hashlock's adjustment, and by extension the summed `totalAdjustment` of all valid hashlocks, is a signed integer that is added to `balance0` and subtracted from `balance1`. Because of peculiarities in Solidity's number types, it seemed safer and clearer to handle the case of negative and positive adjustments separately. A positive adjustment is straight forward. We cast it to an unsigned integer and do the math. However, when the adjustment is negative casting in Solidity doesn't work correctly. So we invert the sign to ensure that the number is positive and also subtract from balance0 instead of adding and vice versa for balance1. We then check that the balances still equal the total amount that was placed into the channel at the beginning and return the new balances.\n","feature_image":null,"featured":0,"page":0,"status":"published","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"author_id":"1","created_at":"2017-09-10 00:00:00","created_by":"1","updated_at":"2017-09-10 00:00:00","updated_by":"1","published_at":"2017-09-10 00:00:00","published_by":"1","custom_excerpt":"Althea's payment channels are key to how it works, but they are also one of the simpler parts to implement and explain. Payment channels allow payments to be made with a minimum of overhead. In the simple case, a payment can be made between two neighbors in the network with only one packet.","codeinjection_head":null,"codeinjection_foot":null,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"custom_template":null}]}
