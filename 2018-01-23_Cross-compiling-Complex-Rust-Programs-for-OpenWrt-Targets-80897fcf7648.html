<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Cross-compiling Complex Rust Programs for OpenWrt Targets</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Cross-compiling Complex Rust Programs for OpenWrt Targets</h1>
</header>
<section data-field="subtitle" class="p-summary">
We made Rust our language of choice for Althea because we wanted to have our cake and eat it to. The ability to use a rich ecosystem of…
</section>
<section data-field="body" class="e-content">
<section name="a14a" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4a6e" id="4a6e" class="graf graf--h3 graf--leading graf--title">Cross-compiling Complex Rust Programs for OpenWrt Targets</h3><p name="7e96" id="7e96" class="graf graf--p graf-after--h3">We made Rust our language of choice for Althea because we wanted to have our cake and eat it to. The ability to use a rich ecosystem of existing libraries, have strong guarantees on safety, and small and efficient binaries that could run on our target OpenWrt devices.</p><p name="bc09" id="bc09" class="graf graf--p graf-after--p">After overcoming several different compilation and size issues we’ve mostly achieved our goal. While Rust binaries are still very big by normal embedded device standards (on the order of 2mb) they are small enough that we can ship full featured applications developed without restrictions and have them run well.</p><p name="fbe2" id="fbe2" class="graf graf--p graf-after--p graf--trailing">This guide is about issues with advanced syntax and building more complex crates, if you want to cross compile a simple ‘hello world’ program start with the excellent <a href="https://github.com/japaric/rust-cross" data-href="https://github.com/japaric/rust-cross" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">rust-cross</a> guide.</p></div></div></section><section name="03a7" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="57d2" id="57d2" class="graf graf--h3 graf--leading">proc_macro</h3><p name="9bec" id="9bec" class="graf graf--p graf-after--h3">High level abstractions with low level results are littered through out the Rust language. In this example we’ve defined serialization for the base types and then can simply automatically derive it for all objects containing those types.</p><pre name="a630" id="a630" class="graf graf--pre graf-after--p">#[derive(Debug, Serialize, Deserialize, PartialEq)]<br>    struct MyStruct {<br>        addr: EthAddress,<br>        sig: EthSignature,<br>        key: EthPrivateKey<br>    }</pre><p name="d279" id="d279" class="graf graf--p graf-after--pre">This compiles perfectly on normal x86 targets, works perfectly too. Everything seems perfect until.</p><pre name="75ea" id="75ea" class="graf graf--pre graf-after--p">[justin@aperturescience.robot serde]$ cargo build --target mips-unknown-linux-musl<br>   Compiling proc-macro2 v0.2.1<br>   Compiling serde_test v1.0.27 (file:///home/justin/repos/serde/serde_test)<br>   Compiling quote v0.4.2<br>error[E0463]: can&#39;t find crate for `proc_macro`<br>  --&gt; /home/justin/.cargo/registry/src/github.com-1ecc6299db9ec823/proc-macro2-0.2.1/src/lib.rs:27:1<br>   |<br>27 | extern crate proc_macro;<br>   | ^^^^^^^^^^^^^^^^^^^^^^^^ can&#39;t find crate</pre><pre name="edad" id="edad" class="graf graf--pre graf-after--pre">error: aborting due to previous error</pre><pre name="b980" id="b980" class="graf graf--pre graf-after--pre">error: Could not compile `proc-macro2`.<br>warning: build failed, waiting for other jobs to finish...<br>error: build failed</pre><p name="e47a" id="e47a" class="graf graf--p graf-after--pre">What is proc_macro and why doesn’t it exist when compiling for targets that aren’t x86? proc_macro is a compiler plugin system. Since Rust allows crates like Serde to provide syntactic sugar that gets turned into actual code the compiler structure has to accommodate code generation from a different source than itself.</p><p name="2636" id="2636" class="graf graf--p graf-after--p">When you go to compile a Rust program with #[derive(Serialize)] or some other property provided by a crate like Serde you’re building a proc_macro crate, these special crates generate a compiler plugin that’s used at compile time to build the code that #[derive(Serialize)] translates to.</p><p name="df3f" id="df3f" class="graf graf--p graf-after--p">So trying to crosscompile a proc_macro crate doesn’t really make any sense. You only need the plugin to generate code and all of it’s functionality is useless on the cross architecture you’re building for. Therefore Cargo just tells you that this useless version of proc_macro doesn’t exist.</p><p name="efad" id="efad" class="graf graf--p graf-after--p">This is caused by having a specific type of useless dependency. If you’ve tried to extend or define other proc macro traits you may have a <code class="markup--code markup--p-code">extern crate quote</code> and or <code class="markup--code markup--p-code">extern crate syn</code> somewhere that’s no longer needed.</p><p name="8bd3" id="8bd3" class="graf graf--p graf-after--p">This can happen if you wrote some derivations that used proc-macro functionality and then re-factored them out without removing the dependency import. Since you aren’t defining anything that actually needs a macro the compiler will let you leave off the required tag in the Cargo.toml.</p><p name="de86" id="de86" class="graf graf--p graf-after--p">Inside of this edge case you will get the above error, it can be corrected by either removing the creates <code class="markup--code markup--p-code">quote</code> and <code class="markup--code markup--p-code">syn</code> if they are no longer needed or properly defining and using a macro in the crate that imports them.</p><p name="bf90" id="bf90" class="graf graf--p graf-after--p graf--trailing">Big thanks to <a href="https://medium.com/@manishearth?source=post_header_lockup" data-href="https://medium.com/@manishearth?source=post_header_lockup" class="markup--anchor markup--p-anchor" target="_blank">Manish Goregaokar</a> for helping improve this section of the article.</p></div></div></section><section name="723f" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="494c" id="494c" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Linking</strong></h3><p name="d7a9" id="d7a9" class="graf graf--p graf-after--h3">With the proc_macro issue gone we can try again. Only to see this.</p><pre name="3a37" id="3a37" class="graf graf--pre graf-after--p">error: linking with `/home/justin/repos/althea-firmware/build/staging_dir/toolchain-mips_24kc_gcc-5.5.0_musl/bin/mips-openwrt-linux-gcc` failed: exit code: 1<br>  |<br>  = note: &quot;/home/justin/repos/althea-firmware/build/staging_dir/toolchain-mips_24kc_gcc-5.5.0_musl/bin/mips-openwrt-linux-gcc&quot; &quot;-Wl,--as-needed&quot; &quot;-Wl,-z,noexecstack&quot; &quot;-L&quot;</pre><p name="a3a8" id="a3a8" class="graf graf--p graf-after--pre">Followed by a horrifyingly large number of libs. But the key line is at the bottom.</p><pre name="d3ad" id="d3ad" class="graf graf--pre graf-after--p">/home/justin/repos/althea_rs/target/mips-unknown-linux-musl/debug/deps/libminiz_sys-9df090e5aeaaf6af.rlib: error adding symbols: File in wrong format</pre><p name="da3a" id="da3a" class="graf graf--p graf-after--pre">Oh no, an x86 library has found it’s way into our mips linking operation! Cargo was building and linking for the right platform but somehow those flags got ignored for some subset of the libraries.</p><p name="d196" id="d196" class="graf graf--p graf-after--p">Crates like <a href="https://github.com/alexcrichton/cc-rs" data-href="https://github.com/alexcrichton/cc-rs" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">cc-rs</a> are used to link external C or C++ libraries into Rust programs at compile time. You might notice that the popular <a href="https://github.com/sfackler/rust-openssl/tree/master/openssl-sys" data-href="https://github.com/sfackler/rust-openssl/tree/master/openssl-sys" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">rust-openssl</a> crate uses this method to link against the system OpenSSL.</p><p name="d43b" id="d43b" class="graf graf--p graf-after--p">It’s not enough to tell Cargo what to compile for, you must also let cc-rs know that it’s cross compiling and rust-openssl needs to know where the target OpenSSL headers are located.</p><pre name="db87" id="db87" class="graf graf--pre graf-after--p">#!/bin/bash<br>export CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_LINKER=/home/justin/repos/althea-firmware/build/staging_dir/toolchain-mips_24kc_gcc-5.5.0_musl/bin/mips-openwrt-linux-gcc<br>export TARGET_CC=/home/justin/repos/althea-firmware/build/staging_dir/toolchain-mips_24kc_gcc-5.5.0_musl/bin/mips-openwrt-linux-gcc<br>export HOST_CC=gcc<br>export MIPS_UNKNOWN_LINUX_MUSL_OPENSSL_DIR=/home/justin/repos/althea-firmware/build/staging_dir/target-mips_24kc_musl/usr/<br>export PKG_CONFIG_ALLOW_CROSS=1</pre><pre name="3e29" id="3e29" class="graf graf--pre graf-after--pre">cargo build --target mips-unknown-linux-musl --release</pre><p name="478c" id="478c" class="graf graf--p graf-after--pre graf--trailing">Notice how in this build script we not only specify CARGO_TARGET but also TARGET_CC and HOST_CC which are read by cc-rs to determine what to compile for where. Finally we specify the OPENSSL_DIR for our target architecture. This script can be simplified some, but is useful to illustrate all the moving parts clearly.</p></div></div></section><section name="99c0" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="560e" id="560e" class="graf graf--h3 graf--leading">Building natively</h3><p name="2434" id="2434" class="graf graf--p graf-after--h3">Now that we have our binary compiled how do we get it onto a OpenWRT device? The easiest and best integrated way is to build as part of a build system feed using a makefile.</p><p name="cddc" id="cddc" class="graf graf--p graf-after--p">You can find ours in the <a href="https://github.com/althea-mesh/althea-packages/blob/master/althea/althea-rust-binaries/Makefile#L49" data-href="https://github.com/althea-mesh/althea-packages/blob/master/althea/althea-rust-binaries/Makefile#L49" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">althea-packages</a> repo with the final and most minimal set of flags you need to compile.</p><pre name="3563" id="3563" class="graf graf--pre graf-after--p">define Build/Compile<br>	(\<br>		cd $(PKG_BUILD_DIR) &amp;&amp; \<br>\<br>		PKG_CONFIG_ALLOW_CROSS=1 \<br>		OPENSSL_DIR=$(STAGING_DIR)/usr/ \<br>		RUSTFLAGS=&quot;-C linker=$(TARGET_CC)&quot; \<br>		TARGET=$(RUST_TRIPLE) \<br>		CC=$(TARGET_CC) \<br>		CFLAGS=&quot;$(TARGET_CFLAGS)&quot; \<br>		TARGET_CFLAGS=&quot;$(TARGET_CFLAGS)&quot; \<br>		CXX=$(TARGET_CXX) \<br>		CXXFLAGS=&quot;$(TARGET_CXXFLAGS)&quot; \<br>		TARGET_CXXFLAGS=&quot;$(TARGET_CXXFLAGS)&quot; \<br>\<br>		cargo build --all --release --target $(RUST_TRIPLE) \<br>	)<br>	$(STRIP) $(RUST_BIN_PATHS)<br>endef</pre><p name="99bd" id="99bd" class="graf graf--p graf-after--pre graf--trailing">Be sure to include the binary stripping step and use some of the less invasive options to shrink binary size in <a href="https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html" data-href="https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this guide</a>.</p></div></div></section><section name="9eef" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="fecc" id="fecc" class="graf graf--p graf--leading graf--trailing">We can’t guarantee that these steps will work for all Crates, for example our makefile may need HOST_CC defined if cc-rs required it. But we wanted to document how we managed to get no compromises Rust code onto OpenWRT. Fulfilling the promise of a high level development environment with low level outcomes.</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/rust" class="p-tag">Rust</a>, <a href="https://medium.com/tag/openwrt" class="p-tag">Openwrt</a>, <a href="https://medium.com/tag/linux" class="p-tag">Linux</a>, <a href="https://medium.com/tag/mesh-networks" class="p-tag">Mesh Networks</a></p><p>By <a href="https://medium.com/@kilpatrickjustin" class="p-author h-card">Justin Kilpatrick</a> on <a href="https://medium.com/p/80897fcf7648"><time class="dt-published" datetime="2018-01-23T18:58:02.979Z">January 23, 2018</time></a>.</p><p><a href="https://medium.com/@kilpatrickjustin/cross-compiling-complex-rust-programs-for-openwrt-targets-80897fcf7648" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 9, 2019.</p></footer></article></body></html>